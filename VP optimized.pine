//@version=6
indicator(title='Volume Profile - Optimized Final', shorttitle='VP Final', overlay=true, max_bars_back=5000, max_boxes_count=500)

// === INPUTS ===
vp_lookback_depth = input.int(200, 'Lookback Bars', minval=20, maxval=1000, group='Core Settings')
vp_num_levels = input.int(60, 'Price Levels', minval=20, maxval=200, group='Core Settings')
vp_bar_width = input.int(30, 'Bar Width', minval=10, maxval=100, group='Core Settings')
vp_right_offset = input.int(40, 'Right Offset', minval=0, maxval=150, group='Core Settings')

// Multi-timeframe settings
auto_adjust_tf = input.bool(true, 'Auto-Adjust for Timeframe', group='Multi-Timeframe')
execution_sensitivity = input.string('Medium', 'Update Sensitivity', options=['Low', 'Medium', 'High', 'Ultra'], group='Multi-Timeframe')

// Session and volume settings
session_focus = input.bool(true, 'Focus on Current Session', group='Session Settings')
session_weight = input.float(1.5, 'Session Weight', minval=1.0, maxval=3.0, step=0.1, group='Session Settings')
vp_volume_type = input.string('Both', 'Volume Type', options=['Both', 'Bullish', 'Bearish'], group='Session Settings')

// Intraday-specific inputs (for 12-14h holds)
intraday_mode = input.bool(true, 'Intraday Mode (12-14h holds)', group='Session Settings')
intraday_start_hour = input.int(10, 'Intraday Window Start (hour)', minval=0, maxval=23, group='Session Settings') // default local / exchange hour
intraday_end_hour   = input.int(14, 'Intraday Window End (hour)',   minval=0, maxval=23, group='Session Settings')
intraday_lookback_days = input.int(5, 'Intraday Lookback (days)', minval=1, maxval=30, group='Session Settings')

// Display settings
vp_show_poc = input.bool(true, 'Show POC', group='Display')
vp_show_va = input.bool(true, 'Show Value Area', group='Display')
vp_va_percent = input.int(70, 'Value Area %', minval=50, maxval=95, group='Display')
vp_show_hva = input.bool(false, 'Show High Volume Areas', group='Display')
vp_hva_threshold = input.int(80, 'HVA Threshold %', minval=60, maxval=95, group='Display')
// Add intraday-specific VA%
intraday_va_percent = input.int(80, 'Intraday VA %', minval=60, maxval=95, group='Display')

// Colors
vp_vol_color = input.color(color.new(color.gray, 70), 'Volume Bar Color', group='Colors')
vp_poc_color = input.color(color.red, 'POC Color', group='Colors')
vp_va_color = input.color(color.new(color.blue, 80), 'Value Area Color', group='Colors')
vp_hva_color = input.color(color.new(color.orange, 70), 'HVA Color', group='Colors')

// === VARIABLES ===
// Replace generic constructor with explicit float-array constructor so elements are typed as float
// var array<float> volume_at_price = array.new_float(vp_num_levels, 0.0)
// var array<box> volume_boxes = array.new<box>()
var float[] volume_at_price = array.new_float(vp_num_levels, 0.0)
var box[]   volume_boxes    = array.new_box()
var box poc_box = na
var int last_calc_bar = 0
// Store last calculated values for info display
var float last_price_low = na
var float last_price_step = na
// NEW: move info label to global scope to avoid NA-type errors inside blocks
var label info_label = na

// --- NEW: top-level price grid vars so they can be referenced inside main logic ---
var float price_high = na
var float price_low  = na
var float price_step = na
// Also keep per-bar precomputed grid holders (allow NA safely)
var float price_high_all = na
var float price_low_all  = na
var float price_step_all = na

// === HELPER FUNCTIONS ===
f_safe_array_get(arr, index, default_val) =>
    if index >= 0 and index < array.size(arr)
        array.get(arr, index)
    else
        default_val

f_safe_array_set(arr, index, value) =>
    if index >= 0 and index < array.size(arr)
        array.set(arr, index, value)

// NEW: safe wrapper to avoid calling array.size on NA arrays
f_array_size_safe(arr) =>
    na(arr) ? 0 : array.size(arr)

f_get_timeframe_mode() =>
    if auto_adjust_tf
        tf_minutes = timeframe.in_seconds() / 60
        if tf_minutes >= 1440
            '1D'
        else if tf_minutes >= 240
            '4H'
        else if tf_minutes >= 60
            '1H'
        else if tf_minutes >= 15
            '15m'
        else if tf_minutes >= 5
            '5m'
        else
            '1m'
    else
        '1H'  // Default fallback

// --- streamline helpers ---
f_effective_lookback(tf_mode) =>
    if intraday_mode
        tf_mode == '1D'  ? int(math.min(vp_lookback_depth, intraday_lookback_days)) :
        tf_mode == '4H'  ? int(math.min(vp_lookback_depth, intraday_lookback_days * 6)) :
        tf_mode == '1H'  ? int(math.min(vp_lookback_depth, intraday_lookback_days * 24)) :
        tf_mode == '15m' ? int(math.min(vp_lookback_depth, intraday_lookback_days * 96)) :
        tf_mode == '5m'  ? int(math.min(vp_lookback_depth, intraday_lookback_days * 288)) :
                           int(math.min(vp_lookback_depth, intraday_lookback_days * 1440))
    else
        tf_mode == '1D'  ? int(math.min(vp_lookback_depth, 40))  :
        tf_mode == '4H'  ? int(math.min(vp_lookback_depth, 120)) :
        tf_mode == '1H'  ? int(math.min(vp_lookback_depth, 240)) :
        tf_mode == '15m' ? int(math.min(vp_lookback_depth, 500)) :
        tf_mode == '5m'  ? int(math.min(vp_lookback_depth, 300)) :
                           int(math.min(vp_lookback_depth, 200))

f_age_decay(tf_mode) =>
    if intraday_mode
        0.03
    else
        tf_mode == '1D'  ? 0.002 :
        tf_mode == '4H'  ? 0.006 :
        tf_mode == '1H'  ? 0.012 :
        tf_mode == '15m' ? 0.03  :
        tf_mode == '5m'  ? 0.06  : 0.1

f_price_to_index(price, price_low, price_step) =>
    if price_step > 0
        // use floor to avoid rounding volume into adjacent bucket unexpectedly
        idxf = (price - price_low) / price_step
        idx = int(math.floor(idxf))
        math.max(0, math.min(vp_num_levels - 1, idx))
    else
        0

// === CORE VOLUME DISTRIBUTION ===
// (kept for reference; not used by main logic)

// === CALCULATE VOLUME PROFILE ===
// Deprecated: main logic does inline distribution now. Return typed defaults to avoid warnings.
f_calculate_volume_profile() =>
    [false, 0.0, 0.0, 0.0]

// === GET PROFILE STATISTICS ===
f_get_profile_stats(price_low, price_step) =>
    // use safe size check to avoid calling array.size on NA
    if f_array_size_safe(volume_at_price) == 0
        [na, na, na, na]
    else
        max_volume = array.max(volume_at_price)
        if max_volume <= 0
            [na, na, na, na]
        else
            poc_index = array.indexof(volume_at_price, max_volume)  // pick actual max level (no averaging)
            poc_price = price_low + poc_index * price_step
            total_volume = array.sum(volume_at_price)
            [poc_index, poc_price, max_volume, total_volume]

// === CALCULATE VALUE AREA ===
f_calculate_value_area(poc_idx, total_vol, price_low, price_step) =>
    if poc_idx < 0 or total_vol <= 0
        [na, na]
    else
        // use effective VA% (intraday can be wider)
        target_volume = total_vol * vp_va_percent_eff / 100
        // ensure numeric/float defaults to avoid NA-type mixing
        va_volume = array.get(volume_at_price, poc_idx)
        va_upper = poc_idx
        va_lower = poc_idx
        
        while va_volume < target_volume and (va_upper < vp_num_levels - 1 or va_lower > 0)
            vol_above = va_upper < vp_num_levels - 1 ? array.get(volume_at_price, va_upper + 1) : 0.0
            vol_below = va_lower > 0 ? array.get(volume_at_price, va_lower - 1) : 0.0
            
            if vol_above >= vol_below and va_upper < vp_num_levels - 1
                va_upper += 1
                va_volume += vol_above
            else if va_lower > 0
                va_lower -= 1
                va_volume += vol_below
            else
                break
        
        va_high_price = price_low + va_upper * price_step
        va_low_price = price_low + va_lower * price_step
        [va_low_price, va_high_price]

// === CLEAR DRAWINGS ===
// Return a 'box' typed value; do not modify globals here.
f_clear_drawings(poc_in) =>
    for box_id in volume_boxes
        box.delete(box_id)
    array.clear(volume_boxes)
    if not na(poc_in)
        box.delete(poc_in)
    // Ensure typed return
    box poc_out = na
    poc_out

// === DRAW VOLUME PROFILE ===
// Return newly created POC box (or na). Do NOT modify globals here.
f_draw_volume_profile(price_high, price_low, price_step) =>
    // typed return holder
    box poc_out = na

    // Destructure with '='
    [poc_idx, poc_price, max_vol, total_vol] = f_get_profile_stats(price_low, price_step)

    if not (na(poc_idx) or max_vol <= 0)
        [va_low, va_high] = f_calculate_value_area(poc_idx, total_vol, price_low, price_step)

        x_base = bar_index + vp_right_offset
        for i = 0 to vp_num_levels - 1
            level_volume = array.get(volume_at_price, i)
            if level_volume > 0
                level_price = price_low + i * price_step
                bar_length = int(math.round(level_volume / max_vol * vp_bar_width))
                if bar_length > 0
                    x1 = x_base
                    x2 = x_base + bar_length
                    y1 = level_price - price_step / 2
                    y2 = level_price + price_step / 2
                    box_color = vp_vol_color
                    if vp_show_va and not na(va_low) and level_price >= va_low and level_price <= va_high
                        box_color := vp_va_color
                    if vp_show_hva and level_volume >= max_vol * vp_hva_threshold / 100
                        box_color := vp_hva_color
                    if i == poc_idx and vp_show_poc
                        box_color := vp_poc_color
                    vol_box = box.new(x1, y1, x2, y2, bgcolor=box_color, border_color=color.new(color.black, 100))
                    array.push(volume_boxes, vol_box)

        if vp_show_poc and not na(poc_price)
            poc_x1 = bar_index - int(math.round(vp_lookback_depth * 0.8))
            poc_x2 = x_base - 5
            // create and return as local
            poc_out := box.new(poc_x1, poc_price - price_step/4, poc_x2, poc_price + price_step/4,
                               bgcolor=vp_poc_color, border_color=vp_poc_color)

    // return the created POC box id (or na)
    poc_out

// === MAIN LOGIC ===
tf_mode = f_get_timeframe_mode()

// compute base_update_freq with explicit if/else to avoid multiline-ternary parsing issues
base_update_freq = 1
if tf_mode == '1D'
    base_update_freq := math.max(10, vp_lookback_depth / 20)
else if tf_mode == '4H'
    base_update_freq := math.max(5, vp_lookback_depth / 30)
else if tf_mode == '1H'
    base_update_freq := math.max(3, vp_lookback_depth / 40)
else if tf_mode == '15m'
    base_update_freq := math.max(2, vp_lookback_depth / 50)
else if tf_mode == '5m'
    base_update_freq := 2
else
    base_update_freq := 1

// compute final_update_freq explicitly
final_update_freq = 1
if execution_sensitivity == 'Ultra'
    final_update_freq := 1
else if execution_sensitivity == 'High'
    final_update_freq := 2
else if execution_sensitivity == 'Medium'
    final_update_freq := int(math.max(3, base_update_freq))
else
    final_update_freq := int(math.max(5, base_update_freq * 2))

// --- DYNAMIC UPDATE TRIGGERS (keeps sensitivity, reduces missed spikes) ---
// normalize volumes across TFs and detect spikes / big price moves
tf_minutes_current = math.max(1, timeframe.in_seconds() / 60)
avg_len = int(math.min(50, bar_index + 1))
avg_vol = ta.sma(volume, avg_len)
avg_vol_norm = avg_vol / tf_minutes_current
cur_vol_norm = volume / tf_minutes_current

// sensitivity thresholds (lower => more sensitive)
vol_thresh = execution_sensitivity == 'Ultra' ? 1.3 :
             execution_sensitivity == 'High'  ? 1.7 :
             execution_sensitivity == 'Medium'? 2.5 : 4.0

move_thresh = execution_sensitivity == 'Ultra' ? 0.002 :
              execution_sensitivity == 'High'  ? 0.003 :
              execution_sensitivity == 'Medium'? 0.005 : 0.01

vol_spike = cur_vol_norm > avg_vol_norm * vol_thresh and avg_vol_norm > 0
price_move = math.abs(close - nz(close[1])) / math.max(1e-9, nz(close[1])) > move_thresh

// compute needs_update (top-level var) â€” keep bar-interval update OR spikes OR last bar
needs_update = barstate.islast or (bar_index - last_calc_bar >= final_update_freq) or vol_spike or price_move

// Effective VA% per mode
var int vp_va_percent_eff = vp_va_percent
vp_va_percent_eff := intraday_mode ? intraday_va_percent : vp_va_percent

// --- NEW: compute lookback & price grid every bar to satisfy ta.* consistency warnings ---
// Use fixed/safer lookback per TF, but if intraday_mode is on use much shorter windows
// effective_lookback_all = if intraday_mode
//     // intraday-focused defaults (keep recent N days)
//     if tf_mode == '1D'
//         math.min(vp_lookback_depth, intraday_lookback_days)      // e.g. 5 days
//     else if tf_mode == '4H'
//         math.min(vp_lookback_depth, intraday_lookback_days * 6)  // ~6 * days of 4H bars
//     else if tf_mode == '1H'
//         math.min(vp_lookback_depth, intraday_lookback_days * 24) // last N days of 1H bars
//     else if tf_mode == '15m'
//         math.min(vp_lookback_depth, intraday_lookback_days * 96) // 96 bars/day
//     else if tf_mode == '5m'
//         math.min(vp_lookback_depth, intraday_lookback_days * 288) // 288 bars/day
//     else
//         math.min(vp_lookback_depth, intraday_lookback_days * 1440) // fallback
// else
//     // existing safer defaults for multi-TF scanning
//     if tf_mode == '1D'
//         math.min(vp_lookback_depth, 40)
//     else if tf_mode == '4H'
//         math.min(vp_lookback_depth, 120)
//     else if tf_mode == '1H'
//         math.min(vp_lookback_depth, 240)
//     else if tf_mode == '15m'
//         math.min(vp_lookback_depth, 500)
//     else if tf_mode == '5m'
//         math.min(vp_lookback_depth, 300)
//     else
//         math.min(vp_lookback_depth, 200)
//
// lookback_int_all = int(math.round(effective_lookback_all))
// compute lookback & price grid every bar (compact)
lookback_int_all = f_effective_lookback(tf_mode)
 price_high_all := ta.highest(high, lookback_int_all)
 price_low_all  := ta.lowest(low,  lookback_int_all)
 // FIX broken line + guard NA
 price_step_all := (na(price_high_all) or na(price_low_all)) ? na : (price_high_all - price_low_all) / vp_num_levels

// Ensure volume_at_price array has correct size at top-level (do not modify globals inside functions)
if array.size(volume_at_price) != vp_num_levels
    array.clear(volume_at_price)
    for _ = 0 to vp_num_levels - 1
        array.push(volume_at_price, 0.0)

// Perform calculation + drawing at top-level to avoid modifying globals from functions
if needs_update
    // zero contents (use array.set in top-level scope)
    for i = 0 to vp_num_levels - 1
        array.set(volume_at_price, i, 0.0)

    // Use precomputed lookback/price grid (ta.* already called each bar)
    lookback_int = lookback_int_all
    price_high := price_high_all
    price_low  := price_low_all
    price_step := price_step_all

    // distribute volume only when we have a valid price_step
    if price_step > 0
        // iterate historical bars and distribute into the global array (top-level)
        for b = 0 to math.min(lookback_int - 1, bar_index)
            bar_volume = volume[b]
            bar_open   = open[b]
            bar_high_b = high[b]
            bar_low_b  = low[b]
            bar_close  = close[b]

            is_bullish = bar_close >= bar_open
            include_volume = vp_volume_type == 'Both' or 
                             (vp_volume_type == 'Bullish' and is_bullish) or 
                             (vp_volume_type == 'Bearish' and not is_bullish)

            vol_to_distribute = include_volume and bar_volume > 0 ? bar_volume : 0.0

            // normalize volume by bar duration so volumes across TFs are comparable
            tf_minutes_local = math.max(1, timeframe.in_seconds() / 60)
            normalized_vol = vol_to_distribute / tf_minutes_local

            // timeframe-based age weight (smoother decay than aggressive pow)
            // adapt decay when intraday_mode ON to keep focus on recent 24-48h
            age_weight = 1.0 / (1.0 + f_age_decay(tf_mode) * b)

            // session weighting (intraday-aware)
            session_weight_factor = 1.0
            if session_focus
                if intraday_mode
                    h = hour(time)
                    // support window across midnight
                    in_window = intraday_start_hour <= intraday_end_hour ? (h >= intraday_start_hour and h < intraday_end_hour) :
                                (h >= intraday_start_hour or h < intraday_end_hour)
                    session_weight_factor := in_window ? session_weight : 1.0
                else
                    // existing robust new-day detection (keeps for non-intraday mode)
                    tf_minutes = timeframe.in_seconds() / 60
                    bars_per_day = int(math.max(1, math.round(1440 / math.max(1, tf_minutes))))
                    new_day_flag = ta.change(time("D")) != 0
                    bars_since_new_day = ta.barssince(new_day_flag)
                    is_current_session = bars_since_new_day <= bars_per_day
                    session_weight_factor := is_current_session ? session_weight : 1.0

            final_weight = age_weight * session_weight_factor
            weighted_volume = normalized_vol * final_weight

            // wick vs body aware typical price (dynamic weighting)
            body_mid = (bar_open + bar_close) / 2
            wick_mid = (bar_high_b + bar_low_b) / 2
            body_ratio = math.min(1.0, math.max(0.0, math.abs(bar_close - bar_open) / math.max(1e-9, bar_high_b - bar_low_b)))
            typical_price = body_ratio * body_mid + (1.0 - body_ratio) * wick_mid
            price_range = bar_high_b - bar_low_b

            if price_range <= 0 or price_step <= 0
                idx = f_price_to_index(typical_price, price_low, price_step)
                cur = f_safe_array_get(volume_at_price, idx, 0.0)
                // scale back to per-bar units for display/storage
                f_safe_array_set(volume_at_price, idx, cur + weighted_volume * tf_minutes_local)
            else
                start_idx = f_price_to_index(bar_low_b,  price_low, price_step)
                end_idx   = f_price_to_index(bar_high_b, price_low, price_step)
                denom = math.max(1, end_idx - start_idx + 1)
                // safe denom for distance factor
                dist_denom = math.max(price_range / 2, price_step)

                for j = start_idx to end_idx
                    level_price = price_low + j * price_step
                    if level_price >= bar_low_b and level_price <= bar_high_b
                        // triangular-ish weighting but clamped to [0,1]
                        distance_factor = 1.0 - math.abs(level_price - typical_price) / dist_denom
                        distance_factor := math.max(0.0, math.min(1.0, distance_factor))
                        // ensure tails still receive small weight
                        weight = math.max(0.05, distance_factor)
                        distributed_vol = weighted_volume * weight / denom
                        cur = f_safe_array_get(volume_at_price, j, 0.0)
                        f_safe_array_set(volume_at_price, j, cur + distributed_vol * tf_minutes_local)

        // compute stats after distribution
        max_vol = array.max(volume_at_price)
        if max_vol > 0
            // POC: pick actual max level (avoid artificial averaging)
            poc_idx = array.indexof(volume_at_price, max_vol)
            poc_price = price_low + poc_idx * price_step
            total_vol = array.sum(volume_at_price)

            // clear previous boxes (top-level)
            for bx in volume_boxes
                box.delete(bx)
            array.clear(volume_boxes)
            if not na(poc_box)
                box.delete(poc_box)
                poc_box := na

            // compute VA bounds
            [va_low, va_high] = f_calculate_value_area(poc_idx, total_vol, price_low, price_step)

            // draw boxes (top-level)
            for i = 0 to vp_num_levels - 1
                level_volume = array.get(volume_at_price, i)
                if level_volume > 0
                    level_price = price_low + i * price_step
                    bar_length = int(math.round(level_volume / max_vol * vp_bar_width))
                    if bar_length > 0
                        x1 = bar_index + vp_right_offset
                        x2 = x1 + bar_length
                        y1 = level_price - price_step / 2
                        y2 = level_price + price_step / 2
                        box_color = vp_vol_color
                        if vp_show_va and not na(va_low) and level_price >= va_low and level_price <= va_high
                            box_color := vp_va_color
                        if vp_show_hva and level_volume >= max_vol * vp_hva_threshold / 100
                            box_color := vp_hva_color
                        if i == poc_idx and vp_show_poc
                            box_color := vp_poc_color
                        vb = box.new(x1, y1, x2, y2, bgcolor=box_color, border_color=na)
                        array.push(volume_boxes, vb)

            if vp_show_poc and not na(poc_price)
                poc_x1 = bar_index - int(math.round(lookback_int * 0.8))
                poc_x2 = bar_index + vp_right_offset - 5
                poc_box := box.new(poc_x1, poc_price - price_step / 4, poc_x2, poc_price + price_step / 4,
                                   bgcolor=vp_poc_color, border_color=vp_poc_color)

            // persist for info display
            last_price_low  := price_low
            last_price_step := price_step

    // update last_calc_bar at top-level
    last_calc_bar := bar_index

// === INFO DISPLAY ===
if barstate.islast
    if not na(last_price_low) and not na(last_price_step)
        [poc_idx, poc_price, max_vol, total_vol] = f_get_profile_stats(last_price_low, last_price_step)
        if not na(poc_price)
            info_text = "POC: " + str.tostring(poc_price, format.mintick) + 
                       "\nLevels: " + str.tostring(vp_num_levels) + 
                       "\nBars: " + str.tostring(vp_lookback_depth) +
                       "\nTF: " + tf_mode
            if not na(info_label)
                label.delete(info_label)
            info_label := label.new(bar_index + vp_right_offset + vp_bar_width + 10, 
                                   high + (high - low) * 0.1, 
                                   info_text, 
                                   style=label.style_label_left, 
                                   color=color.new(color.black, 80), 
                                   textcolor=color.white, 
                                   size=size.small)