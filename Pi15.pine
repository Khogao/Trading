// ¬© 2025 Gemini AI - Phi's VSA Engine (PI FINAL STABLE)
// @version=5
// THAY ƒê·ªîI: Hi·ªáu ch·ªânh l·∫°i to√†n b·ªô h·ªá th·ªëng ƒë·ªãnh v·ªã nh√£n (yloc.price).
indicator("PI (Final Stable)", shorttitle="PI Final", overlay=true, max_labels_count=500)

// === GREG'S WAY (GW) - PH·∫¶N 0: KHAI B√ÅO & C·∫§U H√åNH C·ªêT L√ïI ===
var float VALUE_AREA_PERCENT = 0.7
var float CLIMAX_VOL_THRESHOLD = 0.95
var float DEFAULT_CLOSE_LOCATION = 0.5
var float MIN_PRICE_RANGE = 0.00001
var int VA_UPDATE_INTERVAL = 10
var float VA_PRICE_MOVE_THRESHOLD = 0.03
type SignalConfig
    string name
    string displayText
    color signalColor
    float score
    bool showAbove
type BarAnalysis
    bool isUp, bool isDown, bool isNarrow, bool isWide, bool isHighVol, bool isLowVol, float location
type LinePool
    array<line> pool
    int index

// === PH·∫¶N 1: B·∫¢NG ƒêI·ªÄU KHI·ªÇN & C√ÄI ƒê·∫∂T ===
var string GRP_DISPLAY = "üé® Giao Dien & Hien Thi"
showInfoPanel = input.bool(true, "Bang Thong Tin", group=GRP_DISPLAY)
showLegend = input.bool(true, "Bang Chu Giai", group=GRP_DISPLAY)
showBackground = input.bool(true, "To Nen Tin Hieu Manh", group=GRP_DISPLAY)
showScoreOnBars = input.bool(false, "Hien Thi Diem VSA", group=GRP_DISPLAY)
var string GRP_VP = "üìä Value Area"
showVALines = input.bool(true, "Hien thi POC, VAH, VAL", group=GRP_VP)
vpLookback = input.int(50, "Do dai tinh VA", group=GRP_VP, minval=20, maxval=200)
vpProximityPercent = input.float(0.3, "Bien do Tim kiem quanh VA (%)", group=GRP_VP, minval=0.1, maxval=2.0, step=0.1)
vaRowCount = input.int(100, "Do phan giai VA", group=GRP_VP, minval=50, maxval=200)
var string GRP_TR_LINES = "üìà Duong Trading Range"
showTRLines = input.bool(true, "Ve Duong S/R tu dong", group=GRP_TR_LINES)
trLineOffset = input.int(15, "Do dai ke duong", group=GRP_TR_LINES, minval=5, maxval=50)
maxLines = input.int(10, "Gioi han so duong ke", group=GRP_TR_LINES, minval=5, maxval=30)
var string GRP_SIGNALS = "üéØ Cau Hinh Tin Hieu"
enableSpringUpthrust = input.bool(true, "Spring & Upthrust", group=GRP_SIGNALS)
enableClimacticVol = input.bool(true, "Volume Cuc Dai (Climax)", group=GRP_SIGNALS)
enableNoSupplyDemand = input.bool(true, "No Supply & No Demand", group=GRP_SIGNALS)
enableStoppingVol = input.bool(true, "Stopping Volume", group=GRP_SIGNALS)
enableEffortVsResult = input.bool(true, "No Luc vs Ket Qua", group=GRP_SIGNALS)
enableShakeout = input.bool(true, "Shakeout", group=GRP_SIGNALS)
enableSOS_SOW = input.bool(true, "Sign of Strength/Weakness", group=GRP_SIGNALS)
enableTestBar = input.bool(true, "Test Bar", group=GRP_SIGNALS)
var string GRP_PARAMS = "‚öôÔ∏è Tham So Chien Luoc"
lookbackH_L = input.int(12, "Do dai tim H/L (Spring/UT)", group=GRP_PARAMS, minval=5, maxval=100)
volLookback = input.int(20, "Do dai tinh Volume TB", group=GRP_PARAMS)
volMultiplier = input.float(1.8, "He so Volume Cao", group=GRP_PARAMS, step=0.1)
lowVolMultiplier = input.float(0.6, "He so Volume Thap", group=GRP_PARAMS, step=0.1)
climaxLookback = input.int(40, "Do dai tim Volume Climax", group=GRP_PARAMS)
scoreLookback = input.int(10, "Do dai tinh Diem VSA", group=GRP_PARAMS)
narrowRangeFactor = input.float(0.7, "He so Nen Hep (Narrow)", group=GRP_PARAMS)
wideRangeFactor = input.float(1.3, "He so Nen Rong (Wide)", group=GRP_PARAMS)
bullishCloseLocation = input.float(0.6, "Nguong Dong cua Bullish", group=GRP_PARAMS, step=0.1)
bearishCloseLocation = input.float(0.4, "Nguong Dong cua Bearish", group=GRP_PARAMS, step=0.1)
var string GRP_TREND = "üåä He Thong Dan Duong"
useDualEMA = input.bool(true, "Su dung He thong EMA Kep", group = GRP_TREND)
emaFastLength = input.int(21, "   EMA Nhanh", group = GRP_TREND)
emaSlowLength = input.int(50, "   EMA Cham", group = GRP_TREND)
showEmaCloud = input.bool(true, "   Hien thi Dam may Xu huong", group = GRP_TREND)
useEma200 = input.bool(true, "Su dung EMA 200 (Boi canh)", group = GRP_TREND)
emaLength200 = input.int(200, "   Do dai EMA 200", group = GRP_TREND)

// === PH·∫¶N 2: KH·ªûI T·∫†O BI·∫æN & C·∫§U TR√öC D·ªÆ LI·ªÜU ===
var float cached_dPOC = na, var float cached_dVAH = na, var float cached_dVAL = na
var int last_va_bar = 0, var bool va_cache_valid = false
var LinePool supportPool = LinePool.new(array.new_line(maxLines), 0)
var LinePool resistancePool = LinePool.new(array.new_line(maxLines), 0)
var array<SignalConfig> allSignals = array.new<SignalConfig>()
if barstate.isfirst
    // GW FINAL FIX: Chu·∫©n h√≥a l·∫°i c·∫•u h√¨nh ƒë·ªãnh v·ªã cho t·∫•t c·∫£ c√°c t√≠n hi·ªáu.
    // Bullish signals -> showAbove = false (hi·ªÉn th·ªã b√™n d∆∞·ªõi n·∫øn)
    array.push(allSignals, SignalConfig.new("Spring", "SPR", color.lime, 2.5, false))
    array.push(allSignals, SignalConfig.new("Selling Climax", "SC", color.aqua, 2.0, false))
    array.push(allSignals, SignalConfig.new("Stopping Volume", "StV", color.blue, 2.2, false))
    array.push(allSignals, SignalConfig.new("Effort vs Fall", "EFF", color.orange, 2.0, false))
    array.push(allSignals, SignalConfig.new("Shakeout", "SO", color.fuchsia, 2.2, false))
    array.push(allSignals, SignalConfig.new("Sign of Strength", "SOS", color.green, 2.4, false))
    array.push(allSignals, SignalConfig.new("Test Bar", "TST", color.teal, 1.5, false))
    array.push(allSignals, SignalConfig.new("No Supply", "NS", color.gray, 1.0, false))
    // Bearish signals -> showAbove = true (hi·ªÉn th·ªã b√™n tr√™n n·∫øn)
    array.push(allSignals, SignalConfig.new("Upthrust", "UT", color.red, -2.5, true))
    array.push(allSignals, SignalConfig.new("Buying Climax", "BC", color.orange, -2.0, true))
    array.push(allSignals, SignalConfig.new("Effort vs Rise", "EFR", color.orange, -2.0, true))
    array.push(allSignals, SignalConfig.new("Sign of Weakness", "SOW", color.maroon, -2.4, true))
    array.push(allSignals, SignalConfig.new("No Demand", "ND", color.gray, -1.0, true))

// === PH·∫¶N 3: C√ÅC H√ÄM TI·ªÜN √çCH (HELPER FUNCTIONS) ===
f_safeDivision(n, d) => d > MIN_PRICE_RANGE ? n / d : na
f_safeSum(source, length) =>
    _sum = 0.0
    for i = 0 to math.min(length - 1, bar_index)
        _sum += nz(source[i])
    _sum
f_getLineFromPool(pool, x1, y1, x2, y2, lineColor, style) =>
    lineId = array.get(pool.pool, pool.index)
    line.set_xy1(lineId, x1, y1), line.set_xy2(lineId, x2, y2)
    line.set_color(lineId, lineColor), line.set_style(lineId, style)
    pool.index := (pool.index + 1) % maxLines
f_analyzeBar() =>
    _range = high - low
    _avgVolume = ta.sma(volume, volLookback)
    _isNarrow = _range < ta.sma(_range, volLookback) * narrowRangeFactor
    _isWide = _range > ta.sma(_range, volLookback) * wideRangeFactor
    _isHighVol = volume > _avgVolume * volMultiplier
    _isLowVol = volume < _avgVolume * lowVolMultiplier
    _location = f_safeDivision(close - low, _range)
    BarAnalysis.new(close > open, close < open, _isNarrow, _isWide, _isHighVol, _isLowVol, nz(_location, 0.5))
f_calculateValueArea() =>
    rowCount = vaRowCount
    lookback_high = ta.highest(high, vpLookback)
    lookback_low = ta.lowest(low, vpLookback)
    step_price = f_safeDivision(lookback_high - lookback_low, rowCount - 1)
    if na(step_price) or step_price <= MIN_PRICE_RANGE
        [close, high, low]
    else
        price_rows = array.new_float(rowCount, 0)
        volume_rows = array.new_float(rowCount, 0)
        array.fill(volume_rows, 0)
        for i = 0 to rowCount - 1
            array.set(price_rows, i, lookback_low + step_price * i)
        total_volume = 0.0
        for i = 0 to math.min(vpLookback - 1, bar_index)
            vol = nz(volume[i])
            price = (high[i] + low[i]) / 2
            total_volume += vol
            price_row_index = math.round(f_safeDivision(price - lookback_low, step_price))
            if not na(price_row_index) and price_row_index >= 0 and price_row_index < rowCount
                array.set(volume_rows, price_row_index, array.get(volume_rows, price_row_index) + vol)
        poc_volume = array.max(volume_rows)
        poc_index = na(poc_volume) ? na : array.indexof(volume_rows, poc_volume)
        _dPOC = na(poc_index) ? close : array.get(price_rows, poc_index)
        va_volume_target = total_volume * VALUE_AREA_PERCENT, va_volume_current = nz(poc_volume), up_index = nz(poc_index, 0) + 1, down_index = nz(poc_index, 0) - 1
        while va_volume_current < va_volume_target and (up_index < rowCount or down_index >= 0)
            vol_up = up_index < rowCount ? array.get(volume_rows, up_index) : 0
            vol_down = down_index >= 0 ? array.get(volume_rows, down_index) : 0
            if vol_up == 0 and vol_down == 0
                break
            if vol_up >= vol_down and up_index < rowCount
                va_volume_current += vol_up, up_index += 1
            else if down_index >= 0
                va_volume_current += vol_down, down_index -= 1
            else
                break
        _dVAH = up_index > nz(poc_index, 0) ? array.get(price_rows, math.min(rowCount - 1, up_index - 1)) : _dPOC
        _dVAL = down_index < nz(poc_index, 0) ? array.get(price_rows, math.max(0, down_index + 1)) : _dPOC
        [_dPOC, _dVAH, _dVAL]
f_isNearVA(price) =>
    if not va_cache_valid or na(cached_dPOC)
        false
    else
        pocDiff = f_safeDivision(math.abs(price - cached_dPOC), cached_dPOC)
        vahDiff = f_safeDivision(math.abs(price - cached_dVAH), cached_dVAH)
        valDiff = f_safeDivision(math.abs(price - cached_dVAL), cached_dVAL)
        (not na(pocDiff) and pocDiff < vpProximityPercent / 100) or (not na(vahDiff) and vahDiff < vpProximityPercent / 100) or (not na(valDiff) and valDiff < vpProximityPercent / 100)
f_processSignal(config, price, condition) =>
    if condition
        isNearVA = f_isNearVA(price)
        displayText = isNearVA ? config.displayText + " ‚≠ê" : config.displayText
        yLocation = yloc.price 
        labelStyle = config.showAbove ? label.style_label_down : label.style_label_up
        priceOffset = ta.atr(14) * 0.1
        finalPrice = config.showAbove ? price + priceOffset : price - priceOffset
        label.new(bar_index, finalPrice, yloc=yLocation, text=displayText, style=labelStyle, color=color.new(config.signalColor, 20), textcolor=color.white, size=size.normal)
        config.score
    else
        0.0

// === PH·∫¶N 4: V√íNG L·∫∂P T√çNH TO√ÅN CH√çNH ===
bar = f_analyzeBar()
fastEMA = ta.ema(close, emaFastLength), slowEMA = ta.ema(close, emaSlowLength)
ema200 = ta.ema(close, emaLength200), isUptrend = useDualEMA ? fastEMA > slowEMA : close > ema200
lowest_low_val = ta.lowest(low, lookbackH_L)[1]
highest_high_val = ta.highest(high, lookbackH_L)[1]
highest_vol_val = ta.highest(volume, climaxLookback)
shouldUpdateVA = barstate.islast and (not va_cache_valid or bar_index - last_va_bar > VA_UPDATE_INTERVAL or (va_cache_valid and f_safeDivision(math.abs(close - cached_dPOC), cached_dPOC) > VA_PRICE_MOVE_THRESHOLD))
if shouldUpdateVA
    [newPOC, newVAH, newVAL] = f_calculateValueArea()
    if not na(newPOC)
        cached_dPOC := newPOC, cached_dVAH := newVAH, cached_dVAL := newVAL
        va_cache_valid := true, last_va_bar := bar_index
bullishScore = 0.0, bearishScore = 0.0
if barstate.isconfirmed
    isSpring = enableSpringUpthrust and bar.isDown and close > lowest_low_val and low < lowest_low_val and bar.isHighVol
    isSellingClimax = enableClimacticVol and bar.isDown and bar.isWide and volume >= highest_vol_val * CLIMAX_VOL_THRESHOLD
    isStoppingVol = enableStoppingVol and bar.isDown and bar.isHighVol and bar.location > bullishCloseLocation
    isEffortVsFall = enableEffortVsResult and bar.isDown and bar.isHighVol and bar.isNarrow
    isShakeout = enableShakeout and bar.isDown and bar.isHighVol and bar.location > bullishCloseLocation
    isSOS = enableSOS_SOW and bar.isUp and bar.isHighVol and bar.location > 0.7 and (close > cached_dVAH or close > cached_dPOC)
    isTestBar = enableTestBar and bar.isDown and bar.isNarrow and bar.isLowVol and bar.location > bullishCloseLocation
    isNoSupply = enableNoSupplyDemand and bar.isDown and bar.isNarrow and bar.isLowVol
    isUpthrust = enableSpringUpthrust and bar.isUp and close < highest_high_val and high > highest_high_val and bar.isHighVol
    isBuyingClimax = enableClimacticVol and bar.isUp and bar.isWide and volume >= highest_vol_val * CLIMAX_VOL_THRESHOLD
    isEffortVsRise = enableEffortVsResult and bar.isUp and bar.isHighVol and bar.isNarrow
    isSOW = enableSOS_SOW and bar.isDown and bar.isHighVol and bar.location < bearishCloseLocation and (close < cached_dVAL or close < cached_dPOC)
    isNoDemand = enableNoSupplyDemand and bar.isUp and bar.isNarrow and bar.isLowVol
    
    // GW FINAL FIX: ƒê·∫£m b·∫£o ƒë√∫ng T·ªåA ƒê·ªò GI√Å (price coordinate) ƒë∆∞·ª£c truy·ªÅn v√†o cho m·ªói t√≠n hi·ªáu.
    bullishScore += f_processSignal(array.get(allSignals, 0), low, isSpring)
    bullishScore += f_processSignal(array.get(allSignals, 1), low, isSellingClimax)
    bullishScore += f_processSignal(array.get(allSignals, 2), low, isStoppingVol)
    bullishScore += f_processSignal(array.get(allSignals, 3), low, isEffortVsFall)
    bullishScore += f_processSignal(array.get(allSignals, 4), low, isShakeout)
    bullishScore += f_processSignal(array.get(allSignals, 5), low, isSOS)
    bullishScore += f_processSignal(array.get(allSignals, 6), low, isTestBar)
    bullishScore += f_processSignal(array.get(allSignals, 7), low, isNoSupply)
    bearishScore += f_processSignal(array.get(allSignals, 8), high, isUpthrust)
    bearishScore += f_processSignal(array.get(allSignals, 9), high, isBuyingClimax)
    bearishScore += f_processSignal(array.get(allSignals, 10), high, isEffortVsRise)
    bearishScore += f_processSignal(array.get(allSignals, 11), high, isSOW)
    bearishScore += f_processSignal(array.get(allSignals, 12), high, isNoDemand)

    if showTRLines
        if isSpring: f_getLineFromPool(supportPool, bar_index, low, bar_index + trLineOffset, low, color.new(color.green, 30), line.style_solid)
        if isUpthrust: f_getLineFromPool(resistancePool, bar_index, high, bar_index + trLineOffset, high, color.new(color.red, 30), line.style_solid)
barScore = bullishScore + bearishScore, vsaScore = f_safeSum(barScore, scoreLookback)

// === PH·∫¶N 5: HI·ªÇN TH·ªä & GIAO DI·ªÜN NG∆Ø·ªúI D√ôNG ===
p_ema200 = plot(useEma200 ? ema200 : na, "EMA 200", color.white, 2)
p_fast = plot(useDualEMA ? fastEMA : na, "EMA Nhanh", color.aqua, 2)
p_slow = plot(useDualEMA ? slowEMA : na, "EMA Cham", color.orange, 2)
fill(p_fast, p_slow, color = useDualEMA and showEmaCloud ? (fastEMA > slowEMA ? color.new(color.green, 85) : color.new(color.red, 85)) : na)
if showVALines and va_cache_valid
    f_getLineFromPool(supportPool, bar_index - vpLookback, cached_dPOC, bar_index, cached_dPOC, color.yellow, line.style_solid)
    f_getLineFromPool(supportPool, bar_index - vpLookback, cached_dVAH, bar_index, cached_dVAH, color.blue, line.style_dashed)
    f_getLineFromPool(supportPool, bar_index - vpLookback, cached_dVAL, bar_index, cached_dVAL, color.blue, line.style_dashed)
bgcolor(showBackground and math.abs(vsaScore) > 2.5 ? (vsaScore > 0 ? color.new(color.green, 90) : color.new(color.red, 90)) : na)
if showScoreOnBars and barScore != 0
    label.new(bar_index, low - ta.atr(14) * 0.5, str.tostring(vsaScore, "#.#"), style=label.style_none, textcolor=(vsaScore > 0 ? color.green : color.red))
var table infoTable = na
if showInfoPanel and barstate.islast
    if na(infoTable)
        infoTable := table.new(position.top_right, 2, 6, bgcolor=color.new(color.gray, 85), border_width=1)
        table.cell(infoTable, 0, 0, "VSA ANALYSIS", text_color=color.white, bgcolor=color.black), table.cell(infoTable, 1, 0, timeframe.period, text_color=color.white, bgcolor=color.black)
        table.cell(infoTable, 0, 1, "Trend:"), table.cell(infoTable, 0, 2, "VSA Score:")
        table.cell(infoTable, 0, 3, "Volume:"), table.cell(infoTable, 0, 4, "Range:"), table.cell(infoTable, 0, 5, "Near VA:")
    table.cell(infoTable, 1, 1, isUptrend ? "BULLISH" : "BEARISH", text_color=isUptrend ? color.green : color.red)
    table.cell(infoTable, 1, 2, str.tostring(vsaScore, "#.##"), text_color=vsaScore > 0 ? color.green : vsaScore < 0 ? color.red : color.gray)
    table.cell(infoTable, 1, 3, bar.isHighVol ? "HIGH" : bar.isLowVol ? "LOW" : "NORMAL", text_color=bar.isHighVol ? color.red : bar.isLowVol ? color.gray : color.blue)
    table.cell(infoTable, 1, 4, bar.isWide ? "WIDE" : bar.isNarrow ? "NARROW" : "NORMAL", text_color=bar.isWide ? color.orange : bar.isNarrow ? color.gray : color.blue)
    table.cell(infoTable, 1, 5, f_isNearVA(close) ? "YES" : "NO", text_color=f_isNearVA(close) ? color.yellow : color.gray)