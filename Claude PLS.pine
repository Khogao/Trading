// ¬© 2025 Gemini AI - Phi's Trade System VSA (v12.0 Enhanced)
// @version=5
// C·∫¢I THI·ªÜN: S·ª≠a l·ªói logic nghi√™m tr·ªçng, t·ªëi ∆∞u hi·ªáu su·∫•t, th√™m alert system
indicator("VSA v12.0 Enhanced", shorttitle="VSA v12.0", overlay=true, max_labels_count=500)

// --- PH·∫¶N 0: C√ÅC H√ÄM T√ôY CH·ªàNH (IMPROVED) ---
// C·∫£i thi·ªán h√†m t√≠nh t·ªïng v·ªõi validation
f_safeSum(source, length) =>
    if length <= 0 or na(source)
        0.0
    else
        _sum = 0.0
        _validBars = math.min(length, bar_index + 1)
        for i = 0 to _validBars - 1
            _sum += nz(source[i])
        _sum

// H√†m ph√°t hi·ªán timeframe ch√≠nh x√°c
getTimeframePeriod() =>
    tf = timeframe.period
    if str.contains(tf, "S") or tf == "1"
        "1m"
    else if tf == "5" 
        "5m"
    else if tf == "15"
        "15m" 
    else if tf == "30"
        "30m"
    else if tf == "60" or tf == "1H"
        "1h"
    else if tf == "240" or tf == "4H"
        "4h"
    else if tf == "1D" or tf == "D"
        "1d"
    else
        "other"

// H√†m validation input parameters
validateInputs(lookback_val, vol_mult, climax_lb, score_lb) =>
    _lookback = math.max(5, math.min(lookback_val, 500))
    _volMult = math.max(0.5, math.min(vol_mult, 20.0))
    _climaxLB = math.max(10, math.min(climax_lb, 200))
    _scoreLB = math.max(5, math.min(score_lb, 100))
    [_lookback, _volMult, _climaxLB, _scoreLB]

// --- PH·∫¶N 1: B·∫¢NG ƒêI·ªÄU KHI·ªÇN & C√ÄI ƒê·∫∂T (ENHANCED) ---
var string GRP_DISPLAY = "üé® C√†i ƒê·∫∑t Hi·ªÉn Th·ªã"
showScoreOnBars = input.bool(false, title="Hi·ªÉn Th·ªã Score D∆∞·ªõi M·ªói N·∫øn", group=GRP_DISPLAY)
scoreLabelOffset = input.float(0.5, title="     ƒê·ªô l·ªách nh√£n Score", group=GRP_DISPLAY, minval=0.1, maxval=2.0)
textColorOption = input.string("ƒêen", title="M√†u Ch·ªØ Cho B·∫£ng", options=["ƒêen", "Tr·∫Øng"], group=GRP_DISPLAY)
showInfoPanel = input.bool(true, title="B·∫≠t/T·∫Øt B·∫£ng Th√¥ng Tin", group=GRP_DISPLAY)
showLegend = input.bool(true, title="B·∫≠t/T·∫Øt B·∫£ng Ch√∫ Gi·∫£i", group=GRP_DISPLAY, inline="legend")
legendPosition = input.string("Tr√°i D∆∞·ªõi", title="V·ªã Tr√≠", options=["Tr√°i Tr√™n", "Ph·∫£i Tr√™n", "Tr√°i D∆∞·ªõi", "Ph·∫£i D∆∞·ªõi"], group=GRP_DISPLAY, inline="legend")

var string GRP_VP = "üìä Dynamic Value Area"
showVALines = input.bool(true, title="B·∫≠t/T·∫Øt ƒê∆∞·ªùng POC, VAH, VAL", group=GRP_VP)
useAutoLookback = input.bool(true, title="T·ª± ƒê·ªông Ch·ªçn Lookback", group=GRP_VP)
vpLookback_1m = input.int(40, title="Lookback 1m", group=GRP_VP, minval=10, maxval=100)
vpLookback_5m = input.int(25, title="Lookback 5m", group=GRP_VP, minval=10, maxval=100)
vpLookback_15m = input.int(20, title="Lookback 15m", group=GRP_VP, minval=10, maxval=100)
vpLookback_manual = input.int(50, title="Lookback Manual", group=GRP_VP, minval=10, maxval=200)
vpProximityPercent = input.float(0.3, title="Bi√™n ƒë·ªô t√¨m ki·∫øm quanh VA (%)", group=GRP_VP, minval=0.05, maxval=2.0)

var string GRP_TR_LINES = "üìà ƒê∆∞·ªùng Trading Range"
showTRLines = input.bool(true, title="B·∫≠t/T·∫Øt V·∫Ω ƒê∆∞·ªùng S/R", group=GRP_TR_LINES)
trLineOffset = input.int(15, title="ƒê·ªô d√†i k·∫ª sang ph·∫£i", group=GRP_TR_LINES, minval=5, maxval=50)
maxLines = input.int(20, title="Gi·ªõi h·∫°n s·ªë ƒë∆∞·ªùng S/R", group=GRP_TR_LINES, minval=5, maxval=50)

var string GRP_SIGNALS = "üéØ C√°c T√≠n Hi·ªáu VSA"
showSpringUpthrust = input.bool(true, title="Spring & Upthrust", group=GRP_SIGNALS)
showNoSupplyDemand = input.bool(true, title="No Supply & No Demand", group=GRP_SIGNALS)
showClimacticVol = input.bool(true, title="Volume Climax", group=GRP_SIGNALS)
showStoppingVol = input.bool(true, title="Stopping Volume", group=GRP_SIGNALS)
showEffortVsResult = input.bool(true, title="Effort vs Result", group=GRP_SIGNALS)

var string GRP_PARAMS = "‚öôÔ∏è Tham S·ªë T√≠nh To√°n"
lookback_input = input.int(20, title="ƒê·ªô d√†i t√¨m H/L", group=GRP_PARAMS, minval=5, maxval=100)
volMultiplier_input = input.float(2.0, title="H·ªá s·ªë Volume ƒê·ªôt Bi·∫øn", group=GRP_PARAMS, minval=1.0, maxval=5.0)
lowVolMultiplier = input.float(0.6, title="H·ªá s·ªë Volume C·∫°n Ki·ªát", group=GRP_PARAMS, minval=0.1, maxval=1.0)
climaxLookback_input = input.int(50, title="ƒê·ªô d√†i t√¨m Volume Climax", group=GRP_PARAMS, minval=20, maxval=200)
scoreLookback_input = input.int(20, title="ƒê·ªô d√†i t√≠nh ƒêi·ªÉm VSA", group=GRP_PARAMS, minval=5, maxval=50)

var string GRP_TREND = "üìà B·ªô L·ªçc Xu H∆∞·ªõng"
useTrendFilter = input.bool(true, title="B·∫≠t/T·∫Øt: B·ªô l·ªçc Xu H∆∞·ªõng (EMA)", group=GRP_TREND)
emaLength = input.int(200, title="ƒê·ªô d√†i EMA Xu H∆∞·ªõng", group=GRP_TREND, minval=20, maxval=500)

var string GRP_ALERTS = "üîî C√†i ƒê·∫∑t C·∫£nh B√°o"
enableAlerts = input.bool(false, title="B·∫≠t C·∫£nh B√°o", group=GRP_ALERTS)
alertOnStrong = input.bool(true, title="C·∫£nh b√°o t√≠n hi·ªáu m·∫°nh", group=GRP_ALERTS)
alertOnVATouch = input.bool(true, title="C·∫£nh b√°o ch·∫°m Value Area", group=GRP_ALERTS)

// --- PH·∫¶N 2: VALIDATE & INITIALIZE ---
[lookback, volMultiplier, climaxLookback, scoreLookback] = validateInputs(lookback_input, volMultiplier_input, climaxLookback_input, scoreLookback_input)

var color dynamicTextColor = textColorOption == "ƒêen" ? color.black : color.white
var array<line> supportLines = array.new<line>()
var array<line> resistanceLines = array.new<line>()

// Value Area variables - KH·ªûI T·∫†O NGAY T·ª™ ƒê·∫¶U
var float dPOC = na
var float dVAH = na  
var float dVAL = na
var line pocLine = na
var line vahLine = na
var line valLine = na

// Timeframe detection
currentTF = getTimeframePeriod()
int vpLookback = useAutoLookback ? 
    (currentTF == "1m" ? vpLookback_1m : 
     currentTF == "5m" ? vpLookback_5m : 
     currentTF == "15m" ? vpLookback_15m : vpLookback_manual) : vpLookback_manual

// --- PH·∫¶N 3: T√çNH TO√ÅN C√ÅC CH·ªà B√ÅO (OPTIMIZED) ---
float lookback_high = ta.highest(high, vpLookback)
float lookback_low = ta.lowest(low, vpLookback)
barRange = high - low
avgVolume = ta.sma(volume, lookback)
closeLocation = barRange > 0 ? (close - low) / barRange : 0.5
trendEma = ta.ema(close, emaLength)
plotRightOffset = bar_index + trLineOffset

// VSA Signal variables
var float bullishSignal = 0.0
var float bearishSignal = 0.0
isDownBar = close < open
isUpBar = close > open

// IMPROVED: H√†m ki·ªÉm tra g·∫ßn Value Area v·ªõi validation
isNearVA(price) => 
    if na(dPOC) or na(dVAH) or na(dVAL) or na(price)
        false
    else
        pocDiff = math.abs(price - dPOC) / dPOC * 100
        vahDiff = math.abs(price - dVAH) / dVAH * 100  
        valDiff = math.abs(price - dVAL) / dVAL * 100
        (pocDiff < vpProximityPercent) or (vahDiff < vpProximityPercent) or (valDiff < vpProximityPercent)

// Line management functions
addSupportLine(price, barIndex) =>
    if array.size(supportLines) >= maxLines
        oldLine = array.shift(supportLines)
        line.delete(oldLine)
    
    newLine = line.new(barIndex, price, plotRightOffset, price, 
                      color=color.new(color.green, 30), width=2)
    array.push(supportLines, newLine)

addResistanceLine(price, barIndex) =>
    if array.size(resistanceLines) >= maxLines
        oldLine = array.shift(resistanceLines)
        line.delete(oldLine)
    
    newLine = line.new(barIndex, price, plotRightOffset, price, 
                      color=color.new(color.red, 30), width=2)
    array.push(resistanceLines, newLine)

// --- PH·∫¶N 4: VALUE AREA CALCULATION (OPTIMIZED) ---
var array<float> price_rows = array.new<float>()
var array<float> volume_rows = array.new<float>()

calculateValueArea() =>
    if not showVALines
        [na, na, na]
    else
        rowCount = 100  // Gi·∫£m t·ª´ 200 xu·ªëng 100 ƒë·ªÉ t·ªëi ∆∞u
        
        // Clear arrays
        array.clear(price_rows)
        array.clear(volume_rows)
        
        step_price = (lookback_high - lookback_low) / (rowCount - 1)
        
        if step_price <= 0
            [na, na, na]
        else
            // Initialize price levels
            for i = 0 to rowCount - 1
                array.push(price_rows, lookback_low + step_price * i)
                array.push(volume_rows, 0.0)
            
            // Accumulate volume by price level
            total_volume = 0.0
            validBars = math.min(vpLookback, bar_index + 1)
            
            for i = 0 to validBars - 1
                vol = volume[i]
                price = (high[i] + low[i]) / 2
                total_volume += vol
                
                price_row_index = math.round((price - lookback_low) / step_price)
                if price_row_index >= 0 and price_row_index < rowCount
                    currentVol = array.get(volume_rows, price_row_index)
                    array.set(volume_rows, price_row_index, currentVol + vol)
            
            // Find POC
            poc_volume = array.max(volume_rows)
            poc_index = array.indexof(volume_rows, poc_volume)
            
            if poc_index == -1
                [na, na, na]
            else
                poc_price = array.get(price_rows, poc_index)
                
                // Calculate Value Area (70% of volume)
                va_volume_target = total_volume * 0.7
                va_volume_current = poc_volume
                up_index = poc_index + 1
                down_index = poc_index - 1
                
                // Expand from POC until we reach 70% volume
                while va_volume_current < va_volume_target and (up_index < rowCount or down_index >= 0)
                    vol_up = up_index < rowCount ? array.get(volume_rows, up_index) : 0
                    vol_down = down_index >= 0 ? array.get(volume_rows, down_index) : 0
                    
                    if vol_up == 0 and vol_down == 0
                        break
                        
                    if vol_up >= vol_down and up_index < rowCount
                        va_volume_current += vol_up
                        up_index += 1
                    else if down_index >= 0
                        va_volume_current += vol_down
                        down_index -= 1
                    else
                        break
                
                vah_price = up_index > poc_index and up_index <= rowCount ? 
                           array.get(price_rows, math.min(rowCount - 1, up_index - 1)) : poc_price
                val_price = down_index < poc_index and down_index >= 0 ? 
                           array.get(price_rows, math.max(0, down_index + 1)) : poc_price
                
                [poc_price, vah_price, val_price]

// Calculate Value Area on last bar
if barstate.islast
    [newPOC, newVAH, newVAL] = calculateValueArea()
    dPOC := newPOC
    dVAH := newVAH
    dVAL := newVAL
    
    // Draw Value Area lines
    if showVALines and not na(dPOC)
        // Delete old lines
        if not na(pocLine)
            line.delete(pocLine)
            line.delete(vahLine) 
            line.delete(valLine)
        
        // Draw new lines
        pocLine := line.new(bar_index - vpLookback, dPOC, bar_index + 5, dPOC, 
                           color=color.new(color.yellow, 0), width=3, style=line.style_solid)
        vahLine := line.new(bar_index - vpLookback, dVAH, bar_index + 5, dVAH, 
                           color=color.new(color.blue, 20), width=2, style=line.style_dashed)
        valLine := line.new(bar_index - vpLookback, dVAL, bar_index + 5, dVAL, 
                           color=color.new(color.blue, 20), width=2, style=line.style_dashed)

// --- PH·∫¶N 5: LOGIC T√çN HI·ªÜU VSA (ENHANCED) ---
// Reset signals
bullishSignal := 0.0
bearishSignal := 0.0

// Spring Detection
if showSpringUpthrust
    lowestLow = ta.lowest(low, lookback)[1]
    isSpring = low < lowestLow and close > lowestLow and volume > (avgVolume * volMultiplier)
    
    if isSpring
        bullishSignal := 2.5
        isNearVALevel = isNearVA(low)
        signalText = isNearVALevel ? "SPR ‚≠ê" : "SPR"
        
        label.new(bar_index, low, yloc=yloc.belowbar, text=signalText, 
                 style=label.style_none, textcolor=color.new(color.green, 0), size=size.normal)
        
        if showTRLines
            addSupportLine(low, bar_index)
            label.new(plotRightOffset, low, text="Support", 
                     style=label.style_none, textcolor=color.green, size=size.small, yloc=yloc.price)

// Upthrust Detection  
if showSpringUpthrust
    highestHigh = ta.highest(high, lookback)[1]
    isUpthrust = high > highestHigh and close < highestHigh and volume > (avgVolume * volMultiplier)
    
    if isUpthrust
        bearishSignal := -2.5
        isNearVALevel = isNearVA(high)
        signalText = isNearVALevel ? "UT ‚≠ê" : "UT"
        
        label.new(bar_index, high, yloc=yloc.abovebar, text=signalText, 
                 style=label.style_none, textcolor=color.new(color.red, 0), size=size.normal)
        
        if showTRLines
            addResistanceLine(high, bar_index)
            label.new(plotRightOffset, high, text="Resistance", 
                     style=label.style_none, textcolor=color.red, size=size.small, yloc=yloc.price)

// Climactic Volume
if showClimacticVol
    isClimacticVol = volume == ta.highest(volume, climaxLookback)
    
    if isClimacticVol
        if isDownBar
            bullishSignal := math.max(bullishSignal, 2.0)
            isNearVALevel = isNearVA(low)
            signalText = isNearVALevel ? "SC ‚≠ê" : "SC"
            
            label.new(bar_index, low, yloc=yloc.belowbar, text=signalText, 
                     style=label.style_none, textcolor=color.new(color.lime, 0), size=size.normal)
                     
            if showTRLines
                addSupportLine(low, bar_index)
        else
            bearishSignal := math.min(bearishSignal, -2.0)
            isNearVALevel = isNearVA(high)
            signalText = isNearVALevel ? "BC ‚≠ê" : "BC"
            
            label.new(bar_index, high, yloc=yloc.abovebar, text=signalText, 
                     style=label.style_none, textcolor=color.new(color.orange, 0), size=size.normal)
                     
            if showTRLines
                addResistanceLine(high, bar_index)

// No Supply/Demand
if showNoSupplyDemand
    isNarrowRange = barRange < ta.sma(barRange, lookback) * 0.7
    isLowVolume = volume < (avgVolume * lowVolMultiplier)
    
    if isDownBar and isNarrowRange and isLowVolume
        bullishSignal := math.max(bullishSignal, 1.0)
        label.new(bar_index, na, yloc=yloc.abovebar, text="NS", 
                 style=label.style_none, textcolor=color.gray, size=size.small)
    
    if isUpBar and isNarrowRange and isLowVolume
        bearishSignal := math.min(bearishSignal, -1.0)
        label.new(bar_index, na, yloc=yloc.abovebar, text="ND", 
                 style=label.style_none, textcolor=color.gray, size=size.small)

// Stopping Volume
if showStoppingVol
    isStoppingVol = isDownBar and volume > (avgVolume * volMultiplier) and closeLocation > 0.5
    
    if isStoppingVol
        bullishSignal := math.max(bullishSignal, 2.0)
        label.new(bar_index, na, yloc=yloc.belowbar, text="StV", 
                 style=label.style_none, textcolor=color.blue, size=size.normal)

// Effort vs Result
if showEffortVsResult
    isNarrowRange = barRange < ta.sma(barRange, lookback) * 0.7
    isHighVolume = volume > (avgVolume * volMultiplier)
    
    if isUpBar and isHighVolume and isNarrowRange
        bearishSignal := math.min(bearishSignal, -1.5)
        label.new(bar_index, na, yloc=yloc.abovebar, text="EFR", 
                 style=label.style_none, textcolor=color.orange, size=size.normal)
    
    if isDownBar and isHighVolume and isNarrowRange
        bullishSignal := math.max(bullishSignal, 1.5)
        label.new(bar_index, na, yloc=yloc.belowbar, text="EFF", 
                 style=label.style_none, textcolor=color.orange, size=size.normal)

// --- PH·∫¶N 6: T√çNH TO√ÅN V√Ä HI·ªÇN TH·ªä SCORE ---
barScore = bullishSignal + bearishSignal
vsaScore = f_safeSum(barScore, scoreLookback)

// Display score on bars
if showScoreOnBars
    scoreColor = vsaScore > 0 ? color.new(color.green, 20) : 
                vsaScore < 0 ? color.new(color.red, 20) : color.new(color.gray, 40)
    yPosition = low - ta.atr(14) * scoreLabelOffset
    label.new(bar_index, yPosition, str.tostring(vsaScore, "#.#"), 
             yloc=yloc.price, style=label.style_none, textcolor=scoreColor, size=size.small)

// Background for strong signals
bgcolor(vsaScore >= 4 ? color.new(color.green, 96) : 
        vsaScore <= -4 ? color.new(color.red, 96) : na, title="Strong Signal BG")

// --- PH·∫¶N 7: ALERT SYSTEM ---
if enableAlerts
    strongBullish = bullishSignal >= 2.0
    strongBearish = bearishSignal <= -2.0
    priceNearVA = isNearVA(close)
    
    if alertOnStrong and strongBullish
        alert("üü¢ Strong Bullish VSA Signal!", alert.freq_once_per_bar)
    
    if alertOnStrong and strongBearish
        alert("üî¥ Strong Bearish VSA Signal!", alert.freq_once_per_bar)
    
    if alertOnVATouch and priceNearVA
        alert("‚ö° Price Near Value Area!", alert.freq_once_per_bar)

// --- PH·∫¶N 8: HI·ªÇN TH·ªä C√ÅC B·∫¢NG (ENHANCED) ---
var table legendTable = na
var table infoTable = na

if barstate.islast
    // Clean up old tables
    if not na(infoTable)
        table.delete(infoTable)
    if not na(legendTable)
        table.delete(legendTable)
    
    // Info Panel
    if showInfoPanel
        infoTable := table.new(position.top_right, 2, 6, 
                             bgcolor=color.new(color.white, 15), border_width=1, border_color=color.gray)
        
        // Trend analysis
        isUptrend = close > trendEma
        trendText = useTrendFilter ? (isUptrend ? "üìà Uptrend" : "üìâ Downtrend") : "‚û°Ô∏è No Filter"
        trendColor = useTrendFilter ? (isUptrend ? color.green : color.red) : color.gray
        
        // Volume analysis
        volRatio = volume / avgVolume
        volText = volRatio > 1.5 ? "üî• High" : volRatio < 0.7 ? "‚ùÑÔ∏è Low" : "‚û°Ô∏è Normal"
        volColor = volRatio > 1.5 ? color.orange : volRatio < 0.7 ? color.blue : color.gray
        
        // VSA Bias
        biasText = vsaScore > 2 ? "üü¢ Strong Buy" : 
                  vsaScore > 0 ? "üü¢ Buy Bias" : 
                  vsaScore < -2 ? "üî¥ Strong Sell" : 
                  vsaScore < 0 ? "üî¥ Sell Bias" : "‚ö™ Neutral"
        biasColor = vsaScore > 0 ? color.green : vsaScore < 0 ? color.red : color.gray
        
        // Value Area Status
        vaStatus = not na(dPOC) ? 
                  (close > dVAH ? "‚¨ÜÔ∏è Above VA" : 
                   close < dVAL ? "‚¨áÔ∏è Below VA" : "‚ÜîÔ∏è In VA") : "‚ùå N/A"
        vaColor = not na(dPOC) ? 
                 (close > dVAH ? color.green : 
                  close < dVAL ? color.red : color.yellow) : color.gray
        
        // Table content
        table.cell(infoTable, 0, 0, "TREND", text_color=color.black, text_size=size.small, bgcolor=color.new(color.gray, 70))
        table.cell(infoTable, 1, 0, trendText, text_color=trendColor, text_size=size.small)
        
        table.cell(infoTable, 0, 1, "VOLUME", text_color=color.black, text_size=size.small, bgcolor=color.new(color.gray, 70))
        table.cell(infoTable, 1, 1, volText, text_color=volColor, text_size=size.small)
        
        table.cell(infoTable, 0, 2, "VSA BIAS", text_color=color.black, text_size=size.small, bgcolor=color.new(color.gray, 70))
        table.cell(infoTable, 1, 2, biasText, text_color=biasColor, text_size=size.small)
        
        table.cell(infoTable, 0, 3, "SCORE", text_color=color.black, text_size=size.small, bgcolor=color.new(color.gray, 70))
        table.cell(infoTable, 1, 3, str.tostring(vsaScore, "#.##"), text_color=biasColor, text_size=size.small)
        
        table.cell(infoTable, 0, 4, "VALUE AREA", text_color=color.black, text_size=size.small, bgcolor=color.new(color.gray, 70))
        table.cell(infoTable, 1, 4, vaStatus, text_color=vaColor, text_size=size.small)
        
        table.cell(infoTable, 0, 5, "TIMEFRAME", text_color=color.black, text_size=size.small, bgcolor=color.new(color.gray, 70))
        table.cell(infoTable, 1, 5, currentTF + " (" + str.tostring(vpLookback) + ")", text_color=color.blue, text_size=size.small)
    
    // Legend Table
    if showLegend
        legendPos = legendPosition == "Tr√°i Tr√™n" ? position.top_left :
                   legendPosition == "Ph·∫£i Tr√™n" ? position.top_right :
                   legendPosition == "Tr√°i D∆∞·ªõi" ? position.bottom_left : position.bottom_right
        
        legendTable := table.new(legendPos, 2, 9, 
                                bgcolor=color.new(color.black, 10), border_width=1, border_color=color.gray)
        
        // Header
        table.cell(legendTable, 0, 0, "SIGNAL", text_color=dynamicTextColor, text_size=size.small, 
                  text_halign=text.align_center, bgcolor=color.new(color.blue, 70))
        table.cell(legendTable, 1, 0, "MEANING", text_color=dynamicTextColor, text_size=size.small, 
                  text_halign=text.align_center, bgcolor=color.new(color.blue, 70))
        
        // Content
        table.cell(legendTable, 0, 1, "SPR", text_color=color.green, text_size=size.small)
        table.cell(legendTable, 1, 1, "Spring (Bullish)", text_color=dynamicTextColor, text_size=size.small)
        
        table.cell(legendTable, 0, 2, "UT", text_color=color.red, text_size=size.small)
        table.cell(legendTable, 1, 2, "Upthrust (Bearish)", text_color=dynamicTextColor, text_size=size.small)
        
        table.cell(legendTable, 0, 3, "SC", text_color=color.lime, text_size=size.small)
        table.cell(legendTable, 1, 3, "Selling Climax", text_color=dynamicTextColor, text_size=size.small)
        
        table.cell(legendTable, 0, 4, "BC", text_color=color.orange, text_size=size.small)
        table.cell(legendTable, 1, 4, "Buying Climax", text_color=dynamicTextColor, text_size=size.small)