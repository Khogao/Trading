//@version=5
indicator("5Y-VSA Engine â€” 3R/3S + Dashboard (Fixed-step)", overlay=true, max_labels_count=200, max_lines_count=200, max_boxes_count=50)

// ================= INPUTS =================
lenPivot      = input.int(10, "Pivot Lookback (lenPivot)", minval=2)
showDashboard = input.bool(true, "Show Dashboard")
maxStored     = input.int(10, "Max stored pivots (each side)", minval=3, maxval=30)
volMult       = input.float(1.5, "Volume spike multiplier", step=0.1)
nearestCount  = 3  // fixed: 3 resistances + 3 supports

// ================= LIGHT VSA =================
avgVol = ta.sma(volume, 20)
isHighVol = volume > avgVol * volMult

spring = ta.lowest(low, 3) == low and isHighVol and close > open
upthrust = ta.highest(high, 3) == high and isHighVol and close < open

plotshape(spring, title="Spring", location=location.belowbar, style=shape.triangleup, text="SP", textcolor=color.white, size=size.tiny, color=color.green)
plotshape(upthrust, title="Upthrust", location=location.abovebar, style=shape.triangledown, text="UT", textcolor=color.white, size=size.tiny, color=color.red)

// ================= COLLECT PIVOTS =================
ph = ta.pivothigh(high, lenPivot, lenPivot)
pl = ta.pivotlow(low, lenPivot, lenPivot)

// persistent arrays to store pivots (newest first at index 0)
var float[] resistances = array.new_float()
var float[] supports    = array.new_float()

if not na(ph)
    array.insert(resistances, 0, ph)
if not na(pl)
    array.insert(supports, 0, pl)

if array.size(resistances) > maxStored
    array.pop(resistances)  // remove oldest
if array.size(supports) > maxStored
    array.pop(supports)

// ================= HELPERS =================
// selection-sort ascending by abs(level - close) (in-place)
f_sortByDistance(_arr) =>
    n = array.size(_arr)
    if n > 1
        for i = 0 to n - 2
            minIdx = i
            minDist = math.abs(array.get(_arr, i) - close)
            for j = i + 1 to n - 1
                d = math.abs(array.get(_arr, j) - close)
                if d < minDist
                    minDist := d
                    minIdx := j
            if minIdx != i
                tmp = array.get(_arr, i)
                array.set(_arr, i, array.get(_arr, minIdx))
                array.set(_arr, minIdx, tmp)
    _arr

// returns a new array of up to `k` nearest levels from input arr that are above (if _above) or below price
f_getNearestLevels(_srcArr, _above, k) =>
    out = array.new_float()
    sz = array.size(_srcArr)
    if sz > 0
        for i = 0 to sz - 1
            lvl = array.get(_srcArr, i)
            if _above
                if lvl > close
                    array.push(out, lvl)
            else
                if lvl < close
                    array.push(out, lvl)
    // sort by distance ascending (closest first)
    if array.size(out) > 1
        out := f_sortByDistance(out)
    // trim to k
    while array.size(out) > k
        array.pop(out)
    out

// ================= GET 3 NEAREST =================
resLevels = f_getNearestLevels(resistances, true, nearestCount)
supLevels = f_getNearestLevels(supports, false, nearestCount)

// ================= DRAW LINES (clean previous each bar) =================
var line[] drawn_lines = array.new_line()
// delete previously drawn lines safely using while (no negative-step for-loop)
if array.size(drawn_lines) > 0
    idx_del = array.size(drawn_lines) - 1
    while idx_del >= 0
        l = array.get(drawn_lines, idx_del)
        if not na(l)
            line.delete(l)
        array.remove(drawn_lines, idx_del)
        idx_del := idx_del - 1

// draw resistances (if any)
szR = array.size(resLevels)
if szR > 0
    for i = 0 to szR - 1
        lvl = array.get(resLevels, i)
        l = line.new(bar_index - 1, lvl, bar_index + 40, lvl, xloc.bar_index, extend = extend.right, color=color.red, width=1)
        array.push(drawn_lines, l)

// draw supports (if any)
szS = array.size(supLevels)
if szS > 0
    for i = 0 to szS - 1
        lvl = array.get(supLevels, i)
        l = line.new(bar_index - 1, lvl, bar_index + 40, lvl, xloc.bar_index, extend = extend.right, color=color.green, width=1)
        array.push(drawn_lines, l)

// ================= DASHBOARD (3 R + 3 S with absolute price distance) =================
var table dash = table.new(position.top_right, 3, 7, border_width = 1)
if showDashboard
    // header
    table.cell(dash, 0, 0, "TYPE", text_color=color.white, bgcolor=color.black)
    table.cell(dash, 1, 0, "LEVEL", text_color=color.white, bgcolor=color.black)
    table.cell(dash, 2, 0, "DIST (price)", text_color=color.white, bgcolor=color.black)

    // Resistances R1-R3
    for i = 0 to 2
        if i < array.size(resLevels)
            lvl = array.get(resLevels, i)
            dist = lvl - close
            table.cell(dash, 0, i + 1, "R" + str.tostring(i + 1), text_color=color.red)
            table.cell(dash, 1, i + 1, str.tostring(lvl, format.mintick), text_color=color.red)
            table.cell(dash, 2, i + 1, str.tostring(dist, format.mintick), text_color=color.red)
        else
            table.cell(dash, 0, i + 1, "-", text_color=color.gray)
            table.cell(dash, 1, i + 1, "-", text_color=color.gray)
            table.cell(dash, 2, i + 1, "-", text_color=color.gray)

    // Supports S1-S3
    for i = 0 to 2
        if i < array.size(supLevels)
            lvl = array.get(supLevels, i)
            dist = close - lvl
            table.cell(dash, 0, i + 4, "S" + str.tostring(i + 1), text_color=color.green)
            table.cell(dash, 1, i + 4, str.tostring(lvl, format.mintick), text_color=color.green)
            table.cell(dash, 2, i + 4, str.tostring(dist, format.mintick), text_color=color.green)
        else
            table.cell(dash, 0, i + 4, "-", text_color=color.gray)
            table.cell(dash, 1, i + 4, "-", text_color=color.gray)
            table.cell(dash, 2, i + 4, "-", text_color=color.gray)

// ================= ALERTS =================
// alert when price tests a near level with volume spike
tol = ta.atr(14) * 0.18
tested = false
if array.size(resLevels) > 0
    for i = 0 to array.size(resLevels) - 1
        if math.abs(close - array.get(resLevels, i)) <= tol
            tested := true
if array.size(supLevels) > 0
    for i = 0 to array.size(supLevels) - 1
        if math.abs(close - array.get(supLevels, i)) <= tol
            tested := true

alertcondition(tested and isHighVol, title="Price testing near SR with Volume", message="Price is testing an SR level with high volume")
