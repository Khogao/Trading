//@version=5
indicator('SMPA+', 'SMPA+', overlay = true, max_labels_count = 500, max_lines_count = 500, max_boxes_count = 500)
//---------------------------------------------------------------------------------------------------------------------}
//CONSTANTS & STRINGS & INPUTS
//---------------------------------------------------------------------------------------------------------------------{
BULLISH_LEG                     = 1
BEARISH_LEG                     = 0

BULLISH                         = +1
BEARISH                         = -1

GREEN                           = #089981
RED                             = #F23645
BLUE                            = #2157f3
GRAY                            = #878b94
MONO_BULLISH                    = #b2b5be
MONO_BEARISH                    = #5d606b

HISTORICAL                      = 'Historical'
PRESENT                         = 'Present'

COLORED                         = 'Colored'
MONOCHROME                      = 'Monochrome'

ALL                             = 'All'
BOS                             = 'BOS'
CHOCH                           = 'CHoCH'

TINY                            = size.tiny
SMALL                           = size.small
NORMAL                          = size.normal

ATR                             = 'Atr'
RANGE                           = 'Cumulative Mean Range'

CLOSE                           = 'Close'
HIGHLOW                         = 'High/Low'

SOLID                           = '⎯⎯⎯'
DASHED                          = '----'
DOTTED                          = '····'

SMART_GROUP                     = 'Smart Money Concepts'
INTERNAL_GROUP                  = 'Real Time Internal Structure'
SWING_GROUP                     = 'Real Time Swing Structure'
BLOCKS_GROUP                    = 'Order Blocks'
EQUAL_GROUP                     = 'EQH/EQL'
GAPS_GROUP                      = 'Fair Value Gaps'
LEVELS_GROUP                    = 'Highs & Lows MTF'
ZONES_GROUP                     = 'Premium & Discount Zones'

modeTooltip                     = 'Allows to display historical Structure or only the recent ones'
styleTooltip                    = 'Indicator color theme'
showTrendTooltip                = 'Display additional candles with a color reflecting the current trend detected by structure'
showInternalsTooltip            = 'Display internal market structure'
internalFilterConfluenceTooltip = 'Filter non significant internal structure breakouts'
showStructureTooltip            = 'Display swing market Structure'
showSwingsTooltip               = 'Display swing point as labels on the chart'
showHighLowSwingsTooltip        = 'Highlight most recent strong and weak high/low points on the chart'
showInternalOrderBlocksTooltip  = 'Display internal order blocks on the chart\n\nNumber of internal order blocks to display on the chart'
showSwingOrderBlocksTooltip     = 'Display swing order blocks on the chart\n\nNumber of internal swing blocks to display on the chart'
orderBlockFilterTooltip         = 'Method used to filter out volatile order blocks \n\nIt is recommended to use the cumulative mean range method when a low amount of data is available'
orderBlockMitigationTooltip     = 'Select what values to use for order block mitigation'
showEqualHighsLowsTooltip       = 'Display equal highs and equal lows on the chart'
equalHighsLowsLengthTooltip     = 'Number of bars used to confirm equal highs and equal lows'
equalHighsLowsThresholdTooltip  = 'Sensitivity threshold in a range (0, 1) used for the detection of equal highs & lows\n\nLower values will return fewer but more pertinent results'
showFairValueGapsTooltip        = 'Display fair values gaps on the chart'
fairValueGapsThresholdTooltip   = 'Filter out non significant fair value gaps'
fairValueGapsTimeframeTooltip   = 'Fair value gaps timeframe'
fairValueGapsExtendTooltip      = 'Determine how many bars to extend the Fair Value Gap boxes on chart'
showPremiumDiscountZonesTooltip = 'Display premium, discount, and equilibrium zones on chart'

modeInput                       = input.string( HISTORICAL, 'Mode',                     group = SMART_GROUP,    tooltip = modeTooltip, options = [HISTORICAL, PRESENT])
styleInput                      = input.string( COLORED,    'Style',                    group = SMART_GROUP,    tooltip = styleTooltip,options = [COLORED, MONOCHROME])
showTrendInput                  = input(        false,      'Color Candles',            group = SMART_GROUP,    tooltip = showTrendTooltip)

showInternalsInput              = input(        true,       'Show Internal Structure',  group = INTERNAL_GROUP, tooltip = showInternalsTooltip)
showInternalBullInput           = input.string( ALL,        'Bullish Structure',        group = INTERNAL_GROUP, inline = 'ibull', options = [ALL,BOS,CHOCH])
internalBullColorInput          = input(        GREEN,      '',                         group = INTERNAL_GROUP, inline = 'ibull')
showInternalBearInput           = input.string( ALL,        'Bearish Structure' ,       group = INTERNAL_GROUP, inline = 'ibear', options = [ALL,BOS,CHOCH])
internalBearColorInput          = input(        RED,        '',                         group = INTERNAL_GROUP, inline = 'ibear')
internalFilterConfluenceInput   = input(        false,      'Confluence Filter',        group = INTERNAL_GROUP, tooltip = internalFilterConfluenceTooltip)
internalStructureSize           = input.string( TINY,       'Internal Label Size',      group = INTERNAL_GROUP, options = [TINY,SMALL,NORMAL])

showStructureInput              = input(        true,       'Show Swing Structure',     group = SWING_GROUP,    tooltip = showStructureTooltip)
showSwingBullInput              = input.string( ALL,        'Bullish Structure',        group = SWING_GROUP,    inline = 'bull',    options = [ALL,BOS,CHOCH])
swingBullColorInput             = input(        GREEN,      '',                         group = SWING_GROUP,    inline = 'bull')
showSwingBearInput              = input.string( ALL,        'Bearish Structure',        group = SWING_GROUP,    inline = 'bear',    options = [ALL,BOS,CHOCH])
swingBearColorInput             = input(        RED,        '',                         group = SWING_GROUP,    inline = 'bear')
swingStructureSize              = input.string( SMALL,      'Swing Label Size',         group = SWING_GROUP,    options = [TINY,SMALL,NORMAL])
showSwingsInput                 = input(        false,      'Show Swings Points',       group = SWING_GROUP,    tooltip = showSwingsTooltip,inline = 'swings')
swingsLengthInput               = input.int(    50,         '',                         group = SWING_GROUP,    minval = 10,                inline = 'swings')
showHighLowSwingsInput          = input(        true,       'Show Strong/Weak High/Low',group = SWING_GROUP,    tooltip = showHighLowSwingsTooltip)

showInternalOrderBlocksInput    = input(        true,       'Internal Order Blocks' ,   group = BLOCKS_GROUP,   tooltip = showInternalOrderBlocksTooltip,   inline = 'iob')
internalOrderBlocksSizeInput    = input.int(    5,          '',                         group = BLOCKS_GROUP,   minval = 1, maxval = 20,                    inline = 'iob')
showSwingOrderBlocksInput       = input(        false,      'Swing Order Blocks',       group = BLOCKS_GROUP,   tooltip = showSwingOrderBlocksTooltip,      inline = 'ob')
swingOrderBlocksSizeInput       = input.int(    5,          '',                         group = BLOCKS_GROUP,   minval = 1, maxval = 20,                    inline = 'ob') 
orderBlockFilterInput           = input.string( 'Atr',      'Order Block Filter',       group = BLOCKS_GROUP,   tooltip = orderBlockFilterTooltip,          options = [ATR, RANGE])
orderBlockMitigationInput       = input.string( HIGHLOW,    'Order Block Mitigation',   group = BLOCKS_GROUP,   tooltip = orderBlockMitigationTooltip,      options = [CLOSE,HIGHLOW])
internalBullishOrderBlockColor  = input.color(color.new(#3179f5, 80), 'Internal Bullish OB',    group = BLOCKS_GROUP)
internalBearishOrderBlockColor  = input.color(color.new(#f77c80, 80), 'Internal Bearish OB',    group = BLOCKS_GROUP)
swingBullishOrderBlockColor     = input.color(color.new(#1848cc, 80), 'Bullish OB',             group = BLOCKS_GROUP)
swingBearishOrderBlockColor     = input.color(color.new(#b22833, 80), 'Bearish OB',             group = BLOCKS_GROUP)

showEqualHighsLowsInput         = input(        true,       'Equal High/Low',           group = EQUAL_GROUP,    tooltip = showEqualHighsLowsTooltip)
equalHighsLowsLengthInput       = input.int(    3,          'Bars Confirmation',        group = EQUAL_GROUP,    tooltip = equalHighsLowsLengthTooltip,      minval = 1)
equalHighsLowsThresholdInput    = input.float(  0.1,        'Threshold',                group = EQUAL_GROUP,    tooltip = equalHighsLowsThresholdTooltip,   minval = 0, maxval = 0.5, step = 0.1)
equalHighsLowsSizeInput         = input.string( TINY,       'Label Size',               group = EQUAL_GROUP,    options = [TINY,SMALL,NORMAL])

showFairValueGapsInput          = input(        false,      'Fair Value Gaps',          group = GAPS_GROUP,     tooltip = showFairValueGapsTooltip)
fairValueGapsThresholdInput     = input(        true,       'Auto Threshold',           group = GAPS_GROUP,     tooltip = fairValueGapsThresholdTooltip)
fairValueGapsTimeframeInput     = input.timeframe('',       'Timeframe',                group = GAPS_GROUP,     tooltip = fairValueGapsTimeframeTooltip)
fairValueGapsBullColorInput     = input.color(color.new(#00ff68, 70), 'Bullish FVG' , group = GAPS_GROUP)
fairValueGapsBearColorInput     = input.color(color.new(#ff0008, 70), 'Bearish FVG' , group = GAPS_GROUP)
fairValueGapsExtendInput        = input.int(    1,          'Extend FVG',               group = GAPS_GROUP,     tooltip = fairValueGapsExtendTooltip,       minval = 0)

showDailyLevelsInput            = input(        false,      'Daily',    group = LEVELS_GROUP,   inline = 'daily')
dailyLevelsStyleInput           = input.string( SOLID,      '',         group = LEVELS_GROUP,   inline = 'daily',   options = [SOLID,DASHED,DOTTED])
dailyLevelsColorInput           = input(        BLUE,       '',         group = LEVELS_GROUP,   inline = 'daily')
showWeeklyLevelsInput           = input(        false,      'Weekly',   group = LEVELS_GROUP,   inline = 'weekly')
weeklyLevelsStyleInput          = input.string( SOLID,      '',         group = LEVELS_GROUP,   inline = 'weekly',  options = [SOLID,DASHED,DOTTED])
weeklyLevelsColorInput          = input(        BLUE,       '',         group = LEVELS_GROUP,   inline = 'weekly')
showMonthlyLevelsInput          = input(        false,      'Monthly',   group = LEVELS_GROUP,   inline = 'monthly')
monthlyLevelsStyleInput         = input.string( SOLID,      '',         group = LEVELS_GROUP,   inline = 'monthly', options = [SOLID,DASHED,DOTTED])
monthlyLevelsColorInput         = input(        BLUE,       '',         group = LEVELS_GROUP,   inline = 'monthly')

showPremiumDiscountZonesInput   = input(        false,      'Premium/Discount Zones',   group = ZONES_GROUP , tooltip = showPremiumDiscountZonesTooltip)
// MODIFIED INPUTS FOR PREMIUM/DISCOUNT ZONES
premiumDiscountMethodInput      = input.string('Fibonacci', 'P/D Method', group = ZONES_GROUP, options = ['Fibonacci', 'Percentage', 'ATR Based'])
premiumPercentageInput          = input.float(70.0, 'Premium %', group = ZONES_GROUP, minval = 50.0, maxval = 80.0, step = 5.0)
discountPercentageInput         = input.float(30.0, 'Discount %', group = ZONES_GROUP, minval = 20.0, maxval = 50.0, step = 5.0)
equilibriumWidthInput           = input.float(10.0, 'Equilibrium Width %', group = ZONES_GROUP, minval = 5.0, maxval = 20.0, step = 2.5)
lookbackPeriodInput             = input.int(100, 'Lookback Period', group = ZONES_GROUP, minval = 50, maxval = 500)
dynamicZonesInput               = input(true, 'Dynamic Zones', group = ZONES_GROUP, tooltip = 'Update zones based on recent price action')
showZoneLabelsInput             = input(true, 'Show Zone Labels', group = ZONES_GROUP)
showZoneMidlinesInput           = input(true, 'Show Zone Midlines', group = ZONES_GROUP)
showZoneTableInput              = input(false, 'Show Zone Info Table', group = ZONES_GROUP)
premiumZoneColorInput           = input.color(  RED,        'Premium Zone',             group = ZONES_GROUP)
equilibriumZoneColorInput       = input.color(  GRAY,       'Equilibrium Zone',         group = ZONES_GROUP)
discountZoneColorInput          = input.color(  GREEN,      'Discount Zone',            group = ZONES_GROUP)

//---------------------------------------------------------------------------------------------------------------------}
//DATA STRUCTURES & VARIABLES
//---------------------------------------------------------------------------------------------------------------------{
// @type                            UDT representing alerts as bool fields
// @field internalBullishBOS        internal structure custom alert
// @field internalBearishBOS        internal structure custom alert
// @field internalBullishCHoCH      internal structure custom alert
// @field internalBearishCHoCH      internal structure custom alert
// @field swingBullishBOS           swing structure custom alert
// @field swingBearishBOS           swing structure custom alert
// @field swingBullishCHoCH         swing structure custom alert
// @field swingBearishCHoCH         swing structure custom alert
// @field internalBullishOrderBlock internal order block custom alert
// @field internalBearishOrderBlock internal order block custom alert
// @field swingBullishOrderBlock    swing order block custom alert
// @field swingBearishOrderBlock    swing order block custom alert
// @field equalHighs                equal high low custom alert
// @field equalLows                 equal high low custom alert
// @field bullishFairValueGap       fair value gap custom alert
// @field bearishFairValueGap       fair value gap custom alert
// @field premiumZoneEntry          premium zone entry alert
// @field discountZoneEntry         discount zone entry alert
// @field equilibriumZoneEntry      equilibrium zone entry alert
type alerts
    bool internalBullishBOS         = false
    bool internalBearishBOS         = false
    bool internalBullishCHoCH       = false
    bool internalBearishCHoCH       = false
    bool swingBullishBOS            = false
    bool swingBearishBOS            = false
    bool swingBullishCHoCH          = false
    bool swingBearishCHoCH          = false
    bool internalBullishOrderBlock  = false
    bool internalBearishOrderBlock  = false
    bool swingBullishOrderBlock     = false
    bool swingBearishOrderBlock     = false
    bool equalHighs                 = false
    bool equalLows                  = false
    bool bullishFairValueGap        = false
    bool bearishFairValueGap        = false
    bool premiumZoneEntry           = false
    bool discountZoneEntry          = false
    bool equilibriumZoneEntry       = false

// @type                            UDT representing last swing extremes (top & bottom)
// @field top                       last top swing price
// @field bottom                    last bottom swing price
// @field barTime                   last swing bar time
// @field barIndex                  last swing bar index
// @field lastTopTime               last top swing time
// @field lastBottomTime            last bottom swing time
type trailingExtremes
    float top
    float bottom
    int barTime
    int barIndex
    int lastTopTime
    int lastBottomTime

// @type                            UDT representing Fair Value Gaps
// @field top                       top price
// @field bottom                    bottom price
// @field bias                      bias (BULLISH or BEARISH)
// @field topBox                    top box
// @field bottomBox                 bottom box
type fairValueGap
    float top
    float bottom
    int bias
    box topBox
    box bottomBox

// @type                            UDT representing trend bias
// @field bias                      BULLISH or BEARISH
type trend
    int bias    

// @type                            UDT representing Equal Highs Lows display
// @field l_ine                     displayed line
// @field l_abel                    displayed label
type equalDisplay
    line l_ine      = na
    label l_abel    = na

// @type                            UDT representing a pivot point (swing point) 
// @field currentLevel              current price level
// @field lastLevel                 last price level
// @field crossed                   true if price level is crossed
// @field barTime                   bar time
// @field barIndex                  bar index    
type pivot
    float currentLevel
    float lastLevel
    bool crossed
    int barTime     = time
    int barIndex    = bar_index

// @type                            UDT representing an order block
// @field barHigh                   bar high
// @field barLow                    bar low
// @field barTime                   bar time
// @field bias                      BULLISH or BEARISH
type orderBlock
    float barHigh
    float barLow
    int barTime    
    int bias

// ADDED: Premium/Discount zone structure
// @type                            UDT representing Premium/Discount zones
// @field premiumTop                Premium zone top
// @field premiumBottom             Premium zone bottom  
// @field equilibriumTop            Equilibrium zone top
// @field equilibriumBottom         Equilibrium zone bottom
// @field discountTop               Discount zone top
// @field discountBottom            Discount zone bottom
// @field rangeHigh                 Range high
// @field rangeLow                  Range low
type premiumDiscountZone
    float premiumTop
    float premiumBottom
    float equilibriumTop
    float equilibriumBottom
    float discountTop
    float discountBottom
    float rangeHigh
    float rangeLow

// @variable                        current swing pivot high    
var pivot swingHigh                 = pivot.new(na,na,false)
// @variable                        current swing pivot low
var pivot swingLow                  = pivot.new(na,na,false)
// @variable                        current internal pivot high
var pivot internalHigh              = pivot.new(na,na,false)
// @variable                        current internal pivot low
var pivot internalLow               = pivot.new(na,na,false)
// @variable                        current equal high pivot
var pivot equalHigh                 = pivot.new(na,na,false)
// @variable                        current equal low pivot
var pivot equalLow                  = pivot.new(na,na,false)
// @variable                        swing trend bias
var trend swingTrend                = trend.new(0)
// @variable                        internal trend bias
var trend internalTrend             = trend.new(0)
// @variable                        equal high display
var equalDisplay equalHighDisplay   = equalDisplay.new()
// @variable                        equal low display
var equalDisplay equalLowDisplay    = equalDisplay.new()
// @variable                        storage for fairValueGap UDTs
var array<fairValueGap> fairValueGaps = array.new<fairValueGap>()
// @variable                        storage for parsed highs
var array<float> parsedHighs        = array.new<float>()
// @variable                        storage for parsed lows
var array<float> parsedLows         = array.new<float>()
// @variable                        storage for raw highs
var array<float> highs              = array.new<float>()
// @variable                        storage for raw lows
var array<float> lows               = array.new<float>()
// @variable                        storage for bar time values
var array<int> times                = array.new<int>()
// @variable                        last trailing swing high and low
var trailingExtremes trailing       = trailingExtremes.new()
// @variable                                storage for orderBlock UDTs (swing order blocks)
var array<orderBlock> swingOrderBlocks      = array.new<orderBlock>()
// @variable                                storage for orderBlock UDTs (internal order blocks)
var array<orderBlock> internalOrderBlocks   = array.new<orderBlock>()
// @variable                                storage for swing order blocks boxes
var array<box> swingOrderBlocksBoxes        = array.new<box>()
// @variable                                storage for internal order blocks boxes
var array<box> internalOrderBlocksBoxes     = array.new<box>()

// ADDED: Premium/Discount zone variables
// @variable                        current premium discount zone
var premiumDiscountZone currentZone = premiumDiscountZone.new()
// @variable                        zone drawing objects
var box premiumBox = na
var box equilibriumBox = na
var box discountBox = na
var line premiumMidline = na
var line equilibriumMidline = na
var line discountMidline = na
var label premiumLabel = na
var label equilibriumLabel = na
var label discountLabel = na
var table zoneTable = na

// @variable                        color for swing bullish structures
var swingBullishColor               = styleInput == MONOCHROME ? MONO_BULLISH : swingBullColorInput
// @variable                        color for swing bearish structures
var swingBearishColor               = styleInput == MONOCHROME ? MONO_BEARISH : swingBearColorInput
// @variable                        color for bullish fair value gaps
var fairValueGapBullishColor        = styleInput == MONOCHROME ? color.new(MONO_BULLISH,70) : fairValueGapsBullColorInput
// @variable                        color for bearish fair value gaps
var fairValueGapBearishColor        = styleInput == MONOCHROME ? color.new(MONO_BEARISH,70) : fairValueGapsBearColorInput
// @variable                        color for premium zone
var premiumZoneColor                = styleInput == MONOCHROME ? MONO_BEARISH : premiumZoneColorInput
// @variable                        color for discount zone
var discountZoneColor               = styleInput == MONOCHROME ? MONO_BULLISH : discountZoneColorInput 
// @variable                        bar index on current script iteration
varip int currentBarIndex           = bar_index
// @variable                        bar index on last script iteration
varip int lastBarIndex              = bar_index
// @variable                        alerts in current bar
alerts currentAlerts                = alerts.new()
// @variable                        time at start of chart
var initialTime                     = time
// ADDED: previous zone position for alerts
var string previousZonePosition     = na

// we create the needed boxes for displaying order blocks at the first execution
if barstate.isfirst
    if showSwingOrderBlocksInput
        // Pre-allocate swing OB boxes
        for index = 1 to swingOrderBlocksSizeInput
            swingOrderBlocksBoxes.push(box.new(na, na, na, na, xloc = xloc.bar_time, extend = extend.right))
    if showInternalOrderBlocksInput
        // Pre-allocate internal OB boxes
        for index = 1 to internalOrderBlocksSizeInput
            internalOrderBlocksBoxes.push(box.new(na, na, na, na, xloc = xloc.bar_time, extend = extend.right))
    // Initialize zone table once
    if showZoneTableInput
        zoneTable := table.new(position.top_right, 2, 4, bgcolor = color.white, border_width = 1)

// Calculate zones first
[rangeHigh, rangeLow] = getRangeHighLow()
currentZone := calculatePremiumDiscountZones(premiumDiscountMethodInput, rangeHigh, rangeLow)

// Draw Fair Value Gaps
if showFairValueGapsInput
    drawFairValueGaps()

// Draw zones 
if showPremiumDiscountZonesInput
    drawPremiumDiscountZonesImproved(currentZone)

// Zone position tracking and alerts
currentPosition = getCurrentZonePosition(currentZone)
zoneLevelTouch = checkZoneLevelTouch(currentZone)

// Set alerts for zone changes
if na(previousZonePosition) == false
    if currentPosition == 'Premium' and previousZonePosition != 'Premium'
        currentAlerts.premiumZoneEntry := true
    else if currentPosition == 'Discount' and previousZonePosition != 'Discount'
        currentAlerts.discountZoneEntry := true
    else if currentPosition == 'Equilibrium' and previousZonePosition != 'Equilibrium'
        currentAlerts.equilibriumZoneEntry := true

previousZonePosition := currentPosition

// Zone information table
if showZoneTableInput and showPremiumDiscountZonesInput and barstate.islast
    zoneColor = currentPosition == 'Premium' ? color.red : currentPosition == 'Discount' ? color.green : color.gray
    table.cell(zoneTable, 0, 0, "Zone Analysis", text_color = color.black, text_size = size.normal)
    table.cell(zoneTable, 1, 0, premiumDiscountMethodInput, text_color = color.black, text_size = size.normal)
    table.cell(zoneTable, 0, 1, "Current Position", text_color = color.black, text_size = size.small)
    table.cell(zoneTable, 1, 1, currentPosition, text_color = zoneColor, text_size = size.small)
    table.cell(zoneTable, 0, 2, "Range High", text_color = color.black, text_size = size.small)
    table.cell(zoneTable, 1, 2, str.tostring(rangeHigh, '#.##'), text_color = color.black, text_size = size.small)
    table.cell(zoneTable, 0, 3, "Range Low", text_color = color.black, text_size = size.small)
    table.cell(zoneTable, 1, 3, str.tostring(rangeLow, '#.##'), text_color = color.black, text_size = size.small)

//---------------------------------------------------------------------------------------------------------------------}

if barstate.islastconfirmedhistory or barstate.islast
    if showInternalOrderBlocksInput        
        drawOrderBlocks(true)
        
    if showSwingOrderBlocksInput        
        drawOrderBlocks()

lastBarIndex    := currentBarIndex
currentBarIndex := bar_index
newBar          = currentBarIndex != lastBarIndex

if barstate.islastconfirmedhistory or (barstate.isrealtime and newBar)
    if showDailyLevelsInput and not timeframe.isdaily
        drawLevels('D',timeframe.isdaily,dailyLevelsStyleInput,dailyLevelsColorInput)

    if showWeeklyLevelsInput and not timeframe.isweekly  
        drawLevels('W',timeframe.isweekly,weeklyLevelsStyleInput,weeklyLevelsColorInput)

    if showMonthlyLevelsInput and not timeframe.ismonthly
        drawLevels('M',timeframe.ismonthly,monthlyLevelsStyleInput,monthlyLevelsColorInput)

//---------------------------------------------------------------------------------------------------------------------}
//ALERTS
//---------------------------------------------------------------------------------------------------------------------{
alertcondition(currentAlerts.internalBullishBOS,        'Internal Bullish BOS',         'Internal Bullish BOS formed')
alertcondition(currentAlerts.internalBullishCHoCH,      'Internal Bullish CHoCH',       'Internal Bullish CHoCH formed')
alertcondition(currentAlerts.internalBearishBOS,        'Internal Bearish BOS',         'Internal Bearish BOS formed')
alertcondition(currentAlerts.internalBearishCHoCH,      'Internal Bearish CHoCH',       'Internal Bearish CHoCH formed')

alertcondition(currentAlerts.swingBullishBOS,           'Bullish BOS',                  'Internal Bullish BOS formed')
alertcondition(currentAlerts.swingBullishCHoCH,         'Bullish CHoCH',                'Internal Bullish CHoCH formed')
alertcondition(currentAlerts.swingBearishBOS,           'Bearish BOS',                  'Bearish BOS formed')
alertcondition(currentAlerts.swingBearishCHoCH,         'Bearish CHoCH',                'Bearish CHoCH formed')

alertcondition(currentAlerts.internalBullishOrderBlock, 'Bullish Internal OB Breakout', 'Price broke bullish internal OB')
alertcondition(currentAlerts.internalBearishOrderBlock, 'Bearish Internal OB Breakout', 'Price broke bearish internal OB')
alertcondition(currentAlerts.swingBullishOrderBlock,    'Bullish Swing OB Breakout',    'Price broke bullish swing OB')
alertcondition(currentAlerts.swingBearishOrderBlock,    'Bearish Swing OB Breakout',    'Price broke bearish swing OB')

alertcondition(currentAlerts.equalHighs,                'Equal Highs',                  'Equal highs detected')
alertcondition(currentAlerts.equalLows,                 'Equal Lows',                   'Equal lows detected')

alertcondition(currentAlerts.bullishFairValueGap,       'Bullish FVG',                  'Bullish FVG formed')
alertcondition(currentAlerts.bearishFairValueGap,       'Bearish FVG',                  'Bearish FVG formed')

// ADDED: Premium/Discount zone alerts
alertcondition(currentAlerts.premiumZoneEntry,          'Price Entered Premium Zone',   'Price has entered the Premium zone')
alertcondition(currentAlerts.discountZoneEntry,         'Price Entered Discount Zone',  'Price has entered the Discount zone')
alertcondition(currentAlerts.equilibriumZoneEntry,      'Price Entered Equilibrium Zone', 'Price has entered the Equilibrium zone')
alertcondition(zoneLevelTouch,                          'Zone Level Touch',             'Price touched a significant zone level')

//---------------------------------------------------------------------------------------------------------------------}
// (Removed stray/malformed initialization block that caused parse errors)

// @variable                        source to use in bearish order blocks mitigation
bearishOrderBlockMitigationSource   = orderBlockMitigationInput == CLOSE ? close : high
// @variable                        source to use in bullish order blocks mitigation
bullishOrderBlockMitigationSource   = orderBlockMitigationInput == CLOSE ? close : low

//---------------------------------------------------------------------------------------------------------------------}
//CALCULATIONS
//---------------------------------------------------------------------------------------------------------------------{
// SWING STRUCTURE
calculateSwingStructure() =>
    varip float lastSwingHigh     = na
    varip float lastSwingLow      = na
    varip int lastSwingHighIndex  = na
    varip int lastSwingLowIndex   = na
    varip int lastSwingHighTime   = na
    varip int lastSwingLowTime    = na
    varip int lastSwingDirection   = 0

    isSwingHigh = ta.valuewhen(high == ta.highest(high, 5) and close[1] < open[1], 1, 0)
    isSwingLow  = ta.valuewhen(low == ta.lowest(low, 5) and close[1] > open[1], 1, 0)

    if isSwingHigh
        lastSwingHigh     := high
        lastSwingHighIndex  := bar_index
        lastSwingHighTime   := time
        lastSwingDirection   := BULLISH
    else if isSwingLow
        lastSwingLow      := low
        lastSwingLowIndex   := bar_index
        lastSwingLowTime    := time
        lastSwingDirection   := BEARISH

    [lastSwingHigh, lastSwingLow, lastSwingHighIndex, lastSwingLowIndex, lastSwingHighTime, lastSwingLowTime, lastSwingDirection]

// MODIFIED SWING STRUCTURE FOR EQUAL HIGHS/LOWS
calculateModifiedSwingStructure() =>
    varip float lastSwingHigh     = na
    varip float lastSwingLow      = na
    varip int lastSwingHighIndex  = na
    varip int lastSwingLowIndex   = na
    varip int lastSwingHighTime   = na
    varip int lastSwingLowTime    = na
    varip int lastSwingDirection   = 0

    isSwingHigh = ta.valuewhen(high == ta.highest(high, 5) and close[1] < open[1], 1, 0)
    isSwingLow  = ta.valuewhen(low == ta.lowest(low, 5) and close[1] > open[1], 1, 0)

    if isSwingHigh
        lastSwingHigh     := high
        lastSwingHighIndex  := bar_index
        lastSwingHighTime   := time
        lastSwingDirection   := BULLISH
    else if isSwingLow
        lastSwingLow      := low
        lastSwingLowIndex   := bar_index
        lastSwingLowTime    := time
        lastSwingDirection   := BEARISH

    // EQUAL HIGH/LOW LOGIC
    if lastSwingDirection == BULLISH and not na(lastSwingLow)
        for index = 0 to equalHighsLowsLengthInput - 1
            if high[index] == lastSwingLow
                label.new(bar_index[index], high[index], "Equal High", color=color.green, style=label.style_label_down, textcolor=color.white)
                line.new(bar_index[index], high[index], bar_index, high[index], color=color.green, width=1, style=line.style_dashed)
    else if lastSwingDirection == BEARISH and not na(lastSwingHigh)
        for index = 0 to equalHighsLowsLengthInput - 1
            if low[index] == lastSwingHigh
                label.new(bar_index[index], low[index], "Equal Low", color=color.red, style=label.style_label_up, textcolor=color.white)
                line.new(bar_index[index], low[index], bar_index, low[index], color=color.red, width=1, style=line.style_dashed)

    [lastSwingHigh, lastSwingLow, lastSwingHighIndex, lastSwingLowIndex, lastSwingHighTime, lastSwingLowTime, lastSwingDirection]

// INTERNAL STRUCTURE
calculateInternalStructure() =>
    varip float lastInternalHigh     = na
    varip float lastInternalLow      = na
    varip int lastInternalHighIndex  = na
    varip int lastInternalLowIndex   = na
    varip int lastInternalHighTime   = na
    varip int lastInternalLowTime    = na
    varip int lastInternalDirection   = 0

    isInternalHigh = ta.valuewhen(high == ta.highest(high, 5) and close[1] < open[1], 1, 0)
    isInternalLow  = ta.valuewhen(low == ta.lowest(low, 5) and close[1] > open[1], 1, 0)

    if isInternalHigh
        lastInternalHigh     := high
        lastInternalHighIndex  := bar_index
        lastInternalHighTime   := time
        lastInternalDirection   := BULLISH
    else if isInternalLow
        lastInternalLow      := low
        lastInternalLowIndex   := bar_index
        lastInternalLowTime    := time
        lastInternalDirection   := BEARISH

    [lastInternalHigh, lastInternalLow, lastInternalHighIndex, lastInternalLowIndex, lastInternalHighTime, lastInternalLowTime, lastInternalDirection]

// MODIFIED INTERNAL STRUCTURE FOR EQUAL HIGHS/LOWS
calculateModifiedInternalStructure() =>
    varip float lastInternalHigh     = na
    varip float lastInternalLow      = na
    varip int lastInternalHighIndex  = na
    varip int lastInternalLowIndex   = na
    varip int lastInternalHighTime   = na
    varip int lastInternalLowTime    = na
    varip int lastInternalDirection   = 0

    isInternalHigh = ta.valuewhen(high == ta.highest(high, 5) and close[1] < open[1], 1, 0)
    isInternalLow  = ta.valuewhen(low == ta.lowest(low, 5) and close[1] > open[1], 1, 0)

    if isInternalHigh
        lastInternalHigh     := high
        lastInternalHighIndex  := bar_index
        lastInternalHighTime   := time
        lastInternalDirection   := BULLISH
    else if isInternalLow
        lastInternalLow      := low
        lastInternalLowIndex   := bar_index
        lastInternalLowTime    := time
        lastInternalDirection   := BEARISH

    // EQUAL HIGH/LOW LOGIC
    if lastInternalDirection == BULLISH and not na(lastInternalLow)
        for index = 0 to equalHighsLowsLengthInput - 1
            if high[index] == lastInternalLow
                label.new(bar_index[index], high[index], "Equal High", color=color.green, style=label.style_label_down, textcolor=color.white)
                line.new(bar_index[index], high[index], bar_index, high[index], color=color.green, width=1, style=line.style_dashed)
    else if lastInternalDirection == BEARISH and not na(lastInternalHigh)
        for index = 0 to equalHighsLowsLengthInput - 1
            if low[index] == lastInternalHigh
                label.new(bar_index[index], low[index], "Equal Low", color=color.red, style=label.style_label_up, textcolor=color.white)
                line.new(bar_index[index], low[index], bar_index, low[index], color=color.red, width=1, style=line.style_dashed)

    [lastInternalHigh, lastInternalLow, lastInternalHighIndex, lastInternalLowIndex, lastInternalHighTime, lastInternalLowTime, lastInternalDirection]

// ORDER BLOCKS
calculateOrderBlocks(isSwing) =>
    varip float lastOrderBlockHigh     = na
    varip float lastOrderBlockLow      = na
    varip int lastOrderBlockHighIndex  = na
    varip int lastOrderBlockLowIndex   = na
    varip int lastOrderBlockHighTime   = na
    varip int lastOrderBlockLowTime    = na
    varip int lastOrderBlockDirection   = 0

    isOrderBlockHigh = ta.valuewhen(high == ta.highest(high, 5) and close[1] < open[1], 1, 0)
    isOrderBlockLow  = ta.valuewhen(low == ta.lowest(low, 5) and close[1] > open[1], 1, 0)

    if isOrderBlockHigh
        lastOrderBlockHigh     := high
        lastOrderBlockHighIndex  := bar_index
        lastOrderBlockHighTime   := time
        lastOrderBlockDirection   := BULLISH
    else if isOrderBlockLow
        lastOrderBlockLow      := low
        lastOrderBlockLowIndex   := bar_index
        lastOrderBlockLowTime    := time
        lastOrderBlockDirection   := BEARISH

    // FILTERING LOGIC
    if orderBlockFilterInput == ATR
        atrValue = ta.atr(14)
        lastOrderBlockHigh := lastOrderBlockHigh > atrValue ? lastOrderBlockHigh : na
        lastOrderBlockLow  := lastOrderBlockLow < atrValue ? lastOrderBlockLow : na
    else if orderBlockFilterInput == RANGE
        rangeValue = ta.highest(close, 14) - ta.lowest(close, 14)
        lastOrderBlockHigh := lastOrderBlockHigh > rangeValue ? lastOrderBlockHigh : na
        lastOrderBlockLow  := lastOrderBlockLow < rangeValue ? lastOrderBlockLow : na

    // MITIGATION LOGIC
    if lastOrderBlockDirection == BULLISH and not na(lastOrderBlockLow)
        lastOrderBlockLow := lastOrderBlockLow - (lastOrderBlockLow * 0.1)
    else if lastOrderBlockDirection == BEARISH and not na(lastOrderBlockHigh)
        lastOrderBlockHigh := lastOrderBlockHigh + (lastOrderBlockHigh * 0.1)

    [lastOrderBlockHigh, lastOrderBlockLow, lastOrderBlockHighIndex, lastOrderBlockLowIndex, lastOrderBlockHighTime, lastOrderBlockLowTime, lastOrderBlockDirection]

//---------------------------------------------------------------------------------------------------------------------}
//EXECUTION LOGIC
//---------------------------------------------------------------------------------------------------------------------{
// SWING STRUCTURE
varip float lastSwingHigh     = na
varip float lastSwingLow      = na
varip int lastSwingHighIndex  = na
varip int lastSwingLowIndex   = na
varip int lastSwingHighTime   = na
varip int lastSwingLowTime    = na
varip int lastSwingDirection   = 0

// INTERNAL STRUCTURE
varip float lastInternalHigh     = na
varip float lastInternalLow      = na
varip int lastInternalHighIndex  = na
varip int lastInternalLowIndex   = na
varip int lastInternalHighTime   = na
varip int lastInternalLowTime    = na
varip int lastInternalDirection   = 0

// ORDER BLOCKS
varip float lastOrderBlockHigh     = na
varip float lastOrderBlockLow      = na
varip int lastOrderBlockHighIndex  = na
varip int lastOrderBlockLowIndex   = na
varip int lastOrderBlockHighTime   = na
varip int lastOrderBlockLowTime    = na
varip int lastOrderBlockDirection   = 0

// Calculate swing structure
[lastSwingHigh, lastSwingLow, lastSwingHighIndex, lastSwingLowIndex, lastSwingHighTime, lastSwingLowTime, lastSwingDirection] = calculateSwingStructure()

// Calculate internal structure
[lastInternalHigh, lastInternalLow, lastInternalHighIndex, lastInternalLowIndex, lastInternalHighTime, lastInternalLowTime, lastInternalDirection] = calculateInternalStructure()

// Calculate order blocks
[lastOrderBlockHigh, lastOrderBlockLow, lastOrderBlockHighIndex, lastOrderBlockLowIndex, lastOrderBlockHighTime, lastOrderBlockLowTime, lastOrderBlockDirection] = calculateOrderBlocks(false)

//---------------------------------------------------------------------------------------------------------------------}
//DRAWING LOGIC
//---------------------------------------------------------------------------------------------------------------------{
// SWING STRUCTURE
drawSwingStructure() =>
    if lastSwingDirection == BULLISH
        line.new(lastSwingLowIndex, lastSwingLow, bar_index, lastSwingLow, color=color.green, width=2, style=line.style_solid)
    else if lastSwingDirection == BEARISH
        line.new(lastSwingHighIndex, lastSwingHigh, bar_index, lastSwingHigh, color=color.red, width=2, style=line.style_solid)

// INTERNAL STRUCTURE
drawInternalStructure() =>
    if lastInternalDirection == BULLISH
        line.new(lastInternalLowIndex, lastInternalLow, bar_index, lastInternalLow, color=color.new(color.green, 50), width=2, style=line.style_dashed)
    else if lastInternalDirection == BEARISH
        line.new(lastInternalHighIndex, lastInternalHigh, bar_index, lastInternalHigh, color=color.new(color.red, 50), width=2, style=line.style_dashed)

// ORDER BLOCKS
drawOrderBlocks(isSwing = false) =>
    if isSwing
        if lastOrderBlockDirection == BULLISH
            box.new(lastOrderBlockLowIndex, lastOrderBlockLow, bar_index, lastOrderBlockLow, bgcolor=color.new(color.green, 90), border_color=color.green, border_width=2)
        else if lastOrderBlockDirection == BEARISH
            box.new(lastOrderBlockHighIndex, lastOrderBlockHigh, bar_index, lastOrderBlockHigh, bgcolor=color.new(color.red, 90), border_color=color.red, border_width=2)
    else
        if lastOrderBlockDirection == BULLISH
            box.new(lastOrderBlockLowIndex, lastOrderBlockLow, bar_index, lastOrderBlockLow, bgcolor=color.new(color.green, 80), border_color=color.green, border_width=2)
        else if lastOrderBlockDirection == BEARISH
            box.new(lastOrderBlockHighIndex, lastOrderBlockHigh, bar_index, lastOrderBlockHigh, bgcolor=color.new(color.red, 80), border_color=color.red, border_width=2)

// DRAW SWING STRUCTURE
drawSwingStructure()

// DRAW INTERNAL STRUCTURE
drawInternalStructure()

// DRAW ORDER BLOCKS
drawOrderBlocks()

//---------------------------------------------------------------------------------------------------------------------}
// --- Helper stubs & zone helpers (added) ---
drawFairValueGaps() =>
    0

getRangeHighLow() =>
    // return recent high/low using the lookbackPeriodInput
    rh = ta.highest(high, lookbackPeriodInput)
    rl = ta.lowest(low, lookbackPeriodInput)
    [rh, rl]

calculatePremiumDiscountZones(method, rangeHigh, rangeLow) =>
    // returns premiumDiscountZone UDT
    // clamp range
    span = math.max(rangeHigh - rangeLow, 0.0)
    mid  = rangeLow + span * 0.5

    float pTop = na, pBottom = na, eTop = na, eBottom = na, dTop = na, dBottom = na

    if method == 'Fibonacci'
        // Premium: upper 61.8% to top
        pTop     := rangeHigh
        pBottom  := rangeLow + span * 0.618
        // Equilibrium: mid ± width/2 as percent of span
        halfW    = equilibriumWidthInput / 100.0 * span * 0.5
        eTop     := mid + halfW
        eBottom  := mid - halfW
        // Discount: bottom to 38.2%
        dTop     := rangeLow + span * 0.382
        dBottom  := rangeLow
    else if method == 'Percentage'
        premPct  = math.clamp(premiumPercentageInput   / 100.0, 0.0, 1.0)
        discPct  = math.clamp(discountPercentageInput  / 100.0, 0.0, 1.0)
        pTop     := rangeHigh
        pBottom  := rangeLow + span * premPct
        dTop     := rangeLow + span * discPct
        dBottom  := rangeLow
        halfW    = equilibriumWidthInput / 100.0 * span * 0.5
        eTop     := mid + halfW
        eBottom  := mid - halfW
    else
        // ATR-based banding around mid
        atrV     = ta.atr(14)
        band     = math.max(atrV, span * 0.1)
        pTop     := rangeHigh
        pBottom  := mid + band * 0.5
        dTop     := mid - band * 0.5
        dBottom  := rangeLow
        eTop     := mid + band * 0.25
        eBottom  := mid - band * 0.25

    premiumDiscountZone.new(pTop, pBottom, eTop, eBottom, dTop, dBottom, rangeHigh, rangeLow)

// Draw zones (minimal)
drawPremiumDiscountZonesImproved(z) =>
    if na(z)
        0
    else
        right = bar_index + math.max(1, fairValueGapsExtendInput)

        // Premium
        if not na(z.premiumTop) and not na(z.premiumBottom)
            box.new(bar_index, z.premiumTop, right, z.premiumBottom,
                bgcolor = color.new(premiumZoneColorInput, 90), border_color = premiumZoneColorInput)

            if showZoneMidlinesInput
                line.new(bar_index, (z.premiumTop + z.premiumBottom) / 2, right, (z.premiumTop + z.premiumBottom) / 2, color = premiumZoneColorInput)

            if showZoneLabelsInput
                label.new(bar_index, z.premiumTop, "Premium", style = label.style_label_down, color = premiumZoneColorInput, textcolor = color.white)

        // Equilibrium
        if not na(z.equilibriumTop) and not na(z.equilibriumBottom)
            box.new(bar_index, z.equilibriumTop, right, z.equilibriumBottom,
                bgcolor = color.new(equilibriumZoneColorInput, 90), border_color = equilibriumZoneColorInput)

            if showZoneMidlinesInput
                line.new(bar_index, (z.equilibriumTop + z.equilibriumBottom) / 2, right, (z.equilibriumTop + z.equilibriumBottom) / 2, color = equilibriumZoneColorInput)

            if showZoneLabelsInput
                label.new(bar_index, z.equilibriumTop, "Equilibrium", style = label.style_label_left, color = equilibriumZoneColorInput, textcolor = color.white)

        // Discount
        if not na(z.discountTop) and not na(z.discountBottom)
            box.new(bar_index, z.discountTop, right, z.discountBottom,
                bgcolor = color.new(discountZoneColorInput, 90), border_color = discountZoneColorInput)

            if showZoneMidlinesInput
                line.new(bar_index, (z.discountTop + z.discountBottom) / 2, right, (z.discountTop + z.discountBottom) / 2, color = discountZoneColorInput)

            if showZoneLabelsInput
                label.new(bar_index, z.discountTop, "Discount", style = label.style_label_up, color = discountZoneColorInput, textcolor = color.white)
        0

// Locate current zone by price
getCurrentZonePosition(z) =>
    if na(z)
        'Unknown'
    else
        c = close
        c <= z.premiumTop and c >= z.premiumBottom ? 'Premium' :
         c <= z.discountTop and c >= z.discountBottom ? 'Discount' : 'Equilibrium'

// Detect touches of zone borders
checkZoneLevelTouch(z) =>
    if na(z)
        false
    else
        (low <= z.premiumTop and high >= z.premiumTop) or
        (low <= z.premiumBottom and high >= z.premiumBottom) or
        (low <= z.discountTop and high >= z.discountTop) or
        (low <= z.discountBottom and high >= z.discountBottom)

// Duplicate zone implementation removed — using centralized helpers above
// (kept to avoid redeclaration errors)

// @variable                        source to use in bearish order blocks mitigation
bearishOrderBlockMitigationSource   = orderBlockMitigationInput == CLOSE ? close : high
// @variable                        source to use in bullish order blocks mitigation
bullishOrderBlockMitigationSource   = orderBlockMitigationInput == CLOSE ? close : low

//---------------------------------------------------------------------------------------------------------------------}
//CALCULATIONS
//---------------------------------------------------------------------------------------------------------------------{
// SWING STRUCTURE
calculateSwingStructure() =>
    varip float lastSwingHigh     = na
    varip float lastSwingLow      = na
    varip int lastSwingHighIndex  = na
    varip int lastSwingLowIndex   = na
    varip int lastSwingHighTime   = na
    varip int lastSwingLowTime    = na
    varip int lastSwingDirection   = 0

    isSwingHigh = ta.valuewhen(high == ta.highest(high, 5) and close[1] < open[1], 1, 0)
    isSwingLow  = ta.valuewhen(low == ta.lowest(low, 5) and close[1] > open[1], 1, 0)

    if isSwingHigh
        lastSwingHigh     := high
        lastSwingHighIndex  := bar_index
        lastSwingHighTime   := time
        lastSwingDirection   := BULLISH
    else if isSwingLow
        lastSwingLow      := low
        lastSwingLowIndex   := bar_index
        lastSwingLowTime    := time
        lastSwingDirection   := BEARISH

    [lastSwingHigh, lastSwingLow, lastSwingHighIndex, lastSwingLowIndex, lastSwingHighTime, lastSwingLowTime, lastSwingDirection]

// MODIFIED SWING STRUCTURE FOR EQUAL HIGHS/LOWS
calculateModifiedSwingStructure() =>
    varip float lastSwingHigh     = na
    varip float lastSwingLow      = na
    varip int lastSwingHighIndex  = na
    varip int lastSwingLowIndex   = na
    varip int lastSwingHighTime   = na
    varip int lastSwingLowTime    = na
    varip int lastSwingDirection   = 0

    isSwingHigh = ta.valuewhen(high == ta.highest(high, 5) and close[1] < open[1], 1, 0)
    isSwingLow  = ta.valuewhen(low == ta.lowest(low, 5) and close[1] > open[1], 1, 0)

    if isSwingHigh
        lastSwingHigh     := high
        lastSwingHighIndex  := bar_index
        lastSwingHighTime   := time
        lastSwingDirection   := BULLISH
    else if isSwingLow
        lastSwingLow      := low
        lastSwingLowIndex   := bar_index
        lastSwingLowTime    := time
        lastSwingDirection   := BEARISH

    // EQUAL HIGH/LOW LOGIC
    if lastSwingDirection == BULLISH and not na(lastSwingLow)
        for index = 0 to equalHighsLowsLengthInput - 1
            if high[index] == lastSwingLow
                label.new(bar_index[index], high[index], "Equal High", color=color.green, style=label.style_label_down, textcolor=color.white)
                line.new(bar_index[index], high[index], bar_index, high[index], color=color.green, width=1, style=line.style_dashed)
    else if lastSwingDirection == BEARISH and not na(lastSwingHigh)
        for index = 0 to equalHighsLowsLengthInput - 1
            if low[index] == lastSwingHigh
                label.new(bar_index[index], low[index], "Equal Low", color=color.red, style=label.style_label_up, textcolor=color.white)
                line.new(bar_index[index], low[index], bar_index, low[index], color=color.red, width=1, style=line.style_dashed)

    [lastSwingHigh, lastSwingLow, lastSwingHighIndex, lastSwingLowIndex, lastSwingHighTime, lastSwingLowTime, lastSwingDirection]

// INTERNAL STRUCTURE
calculateInternalStructure() =>
    varip float lastInternalHigh     = na
    varip float lastInternalLow      = na
    varip int lastInternalHighIndex  = na
    varip int lastInternalLowIndex   = na
    varip int lastInternalHighTime   = na
    varip int lastInternalLowTime    = na
    varip int lastInternalDirection   = 0

    isInternalHigh = ta.valuewhen(high == ta.highest(high, 5) and close[1] < open[1], 1, 0)
    isInternalLow  = ta.valuewhen(low == ta.lowest(low, 5) and close[1] > open[1], 1, 0)

    if isInternalHigh
        lastInternalHigh     := high
        lastInternalHighIndex  := bar_index
        lastInternalHighTime   := time
        lastInternalDirection   := BULLISH
    else if isInternalLow
        lastInternalLow      := low
        lastInternalLowIndex   := bar_index
        lastInternalLowTime    := time
        lastInternalDirection   := BEARISH

    [lastInternalHigh, lastInternalLow, lastInternalHighIndex, lastInternalLowIndex, lastInternalHighTime, lastInternalLowTime, lastInternalDirection]

// MODIFIED INTERNAL STRUCTURE FOR EQUAL HIGHS/LOWS
calculateModifiedInternalStructure() =>
    varip float lastInternalHigh     = na
    varip float lastInternalLow      = na
    varip int lastInternalHighIndex  = na
    varip int lastInternalLowIndex   = na
    varip int lastInternalHighTime   = na
    varip int lastInternalLowTime    = na
    varip int lastInternalDirection   = 0

    isInternalHigh = ta.valuewhen(high == ta.highest(high, 5) and close[1] < open[1], 1, 0)
    isInternalLow  = ta.valuewhen(low == ta.lowest(low, 5) and close[1] > open[1], 1, 0)

    if isInternalHigh
        lastInternalHigh     := high
        lastInternalHighIndex  := bar_index
        lastInternalHighTime   := time
        lastInternalDirection   := BULLISH
    else if isInternalLow
        lastInternalLow      := low
        lastInternalLowIndex   := bar_index
        lastInternalLowTime    := time
        lastInternalDirection   := BEARISH

    // EQUAL HIGH/LOW LOGIC
    if lastInternalDirection == BULLISH and not na(lastInternalLow)
        for index = 0 to equalHighsLowsLengthInput - 1
            if high[index] == lastInternalLow
                label.new(bar_index[index], high[index], "Equal High", color=color.green, style=label.style_label_down, textcolor=color.white)
                line.new(bar_index[index], high[index], bar_index, high[index], color=color.green, width=1, style=line.style_dashed)
    else if lastInternalDirection == BEARISH and not na(lastInternalHigh)
        for index = 0 to equalHighsLowsLengthInput - 1
            if low[index] == lastInternalHigh
                label.new(bar_index[index], low[index], "Equal Low", color=color.red, style=label.style_label_up, textcolor=color.white)
                line.new(bar_index[index], low[index], bar_index, low[index], color=color.red, width=1, style=line.style_dashed)

    [lastInternalHigh, lastInternalLow, lastInternalHighIndex, lastInternalLowIndex, lastInternalHighTime, lastInternalLowTime, lastInternalDirection]

// ORDER BLOCKS
calculateOrderBlocks(isSwing) =>
    varip float lastOrderBlockHigh     = na
    varip float lastOrderBlockLow      = na
    varip int lastOrderBlockHighIndex  = na
    varip int lastOrderBlockLowIndex   = na
    varip int lastOrderBlockHighTime   = na
    varip int lastOrderBlockLowTime    = na
    varip int lastOrderBlockDirection   = 0

    isOrderBlockHigh = ta.valuewhen(high == ta.highest(high, 5) and close[1] < open[1], 1, 0)
    isOrderBlockLow  = ta.valuewhen(low == ta.lowest(low, 5) and close[1] > open[1], 1, 0)

    if isOrderBlockHigh
        lastOrderBlockHigh     := high
        lastOrderBlockHighIndex  := bar_index
        lastOrderBlockHighTime   := time
        lastOrderBlockDirection   := BULLISH
    else if isOrderBlockLow
        lastOrderBlockLow      := low
        lastOrderBlockLowIndex   := bar_index
        lastOrderBlockLowTime    := time
        lastOrderBlockDirection   := BEARISH

    // FILTERING LOGIC
    if orderBlockFilterInput == ATR
        atrValue = ta.atr(14)
        lastOrderBlockHigh := lastOrderBlockHigh > atrValue ? lastOrderBlockHigh : na
        lastOrderBlockLow  := lastOrderBlockLow < atrValue ? lastOrderBlockLow : na
    else if orderBlockFilterInput == RANGE
        rangeValue = ta.highest(close, 14) - ta.lowest(close, 14)
        lastOrderBlockHigh := lastOrderBlockHigh > rangeValue ? lastOrderBlockHigh : na
        lastOrderBlockLow  := lastOrderBlockLow < rangeValue ? lastOrderBlockLow : na

    // MITIGATION LOGIC
    if lastOrderBlockDirection == BULLISH and not na(lastOrderBlockLow)
        lastOrderBlockLow := lastOrderBlockLow - (lastOrderBlockLow * 0.1)
    else if lastOrderBlockDirection == BEARISH and not na(lastOrderBlockHigh)
        lastOrderBlockHigh := lastOrderBlockHigh + (lastOrderBlockHigh * 0.1)

    [lastOrderBlockHigh, lastOrderBlockLow, lastOrderBlockHighIndex, lastOrderBlockLowIndex, lastOrderBlockHighTime, lastOrderBlockLowTime, lastOrderBlockDirection]

//---------------------------------------------------------------------------------------------------------------------}
//EXECUTION LOGIC
//---------------------------------------------------------------------------------------------------------------------{
// SWING STRUCTURE
varip float lastSwingHigh     = na
varip float lastSwingLow      = na
varip int lastSwingHighIndex  = na
varip int lastSwingLowIndex   = na
varip int lastSwingHighTime   = na
varip int lastSwingLowTime    = na
varip int lastSwingDirection   = 0

// INTERNAL STRUCTURE
varip float lastInternalHigh     = na
varip float lastInternalLow      = na
varip int lastInternalHighIndex  = na
varip int lastInternalLowIndex   = na
varip int lastInternalHighTime   = na
varip int lastInternalLowTime    = na
varip int lastInternalDirection   = 0

// ORDER BLOCKS
varip float lastOrderBlockHigh     = na
varip float lastOrderBlockLow      = na
varip int lastOrderBlockHighIndex  = na
varip int lastOrderBlockLowIndex   = na
varip int lastOrderBlockHighTime   = na
varip int lastOrderBlockLowTime    = na
varip int lastOrderBlockDirection   = 0

// Calculate swing structure
[lastSwingHigh, lastSwingLow, lastSwingHighIndex, lastSwingLowIndex, lastSwingHighTime, lastSwingLowTime, lastSwingDirection] = calculateSwingStructure()

// Calculate internal structure
[lastInternalHigh, lastInternalLow, lastInternalHighIndex, lastInternalLowIndex, lastInternalHighTime, lastInternalLowTime, lastInternalDirection] = calculateInternalStructure()

// Calculate order blocks
[lastOrderBlockHigh, lastOrderBlockLow, lastOrderBlockHighIndex, lastOrderBlockLowIndex, lastOrderBlockHighTime, lastOrderBlockLowTime, lastOrderBlockDirection] = calculateOrderBlocks(false)

//---------------------------------------------------------------------------------------------------------------------}
//DRAWING LOGIC
//---------------------------------------------------------------------------------------------------------------------{
// SWING STRUCTURE
drawSwingStructure() =>
    if lastSwingDirection == BULLISH
        line.new(lastSwingLowIndex, lastSwingLow, bar_index, lastSwingLow, color=color.green, width=2, style=line.style_solid)
    else if lastSwingDirection == BEARISH
        line.new(lastSwingHighIndex, lastSwingHigh, bar_index, lastSwingHigh, color=color.red, width=2, style=line.style_solid)

// INTERNAL STRUCTURE
drawInternalStructure() =>
    if lastInternalDirection == BULLISH
        line.new(lastInternalLowIndex, lastInternalLow, bar_index, lastInternalLow, color=color.new(color.green, 50), width=2, style=line.style_dashed)
    else if lastInternalDirection == BEARISH
        line.new(lastInternalHighIndex, lastInternalHigh, bar_index, lastInternalHigh, color=color.new(color.red, 50), width=2, style=line.style_dashed)

// ORDER BLOCKS
drawOrderBlocks(isSwing = false) =>
    if isSwing
        if lastOrderBlockDirection == BULLISH
            box.new(lastOrderBlockLowIndex, lastOrderBlockLow, bar_index, lastOrderBlockLow, bgcolor=color.new(color.green, 90), border_color=color.green, border_width=2)
        else if lastOrderBlockDirection == BEARISH
            box.new(lastOrderBlockHighIndex, lastOrderBlockHigh, bar_index, lastOrderBlockHigh, bgcolor=color.new(color.red, 90), border_color=color.red, border_width=2)
    else
        if lastOrderBlockDirection == BULLISH
            box.new(lastOrderBlockLowIndex, lastOrderBlockLow, bar_index, lastOrderBlockLow, bgcolor=color.new(color.green, 80), border_color=color.green, border_width=2)
        else if lastOrderBlockDirection == BEARISH
            box.new(lastOrderBlockHighIndex, lastOrderBlockHigh, bar_index, lastOrderBlockHigh, bgcolor=color.new(color.red, 80), border_color=color.red, border_width=2)

// DRAW SWING STRUCTURE
drawSwingStructure()

// DRAW INTERNAL STRUCTURE
drawInternalStructure()

// DRAW ORDER BLOCKS
drawOrderBlocks()

//---------------------------------------------------------------------------------------------------------------------}
// --- Helper stubs & zone helpers (added) ---
drawFairValueGaps() =>
    0

getRangeHighLow() =>
    // return recent high/low using the lookbackPeriodInput
    rh = ta.highest(high, lookbackPeriodInput)
    rl = ta.lowest(low, lookbackPeriodInput)
    [rh, rl]

calculatePremiumDiscountZones(method, rangeHigh, rangeLow) =>
    // returns premiumDiscountZone UDT
    // clamp range
    span = math.max(rangeHigh - rangeLow, 0.0)
    mid  = rangeLow + span * 0.5

    float pTop = na, pBottom = na, eTop = na, eBottom = na, dTop = na, dBottom = na

    if method == 'Fibonacci'
        // Premium: upper 61.8% to top
        pTop     := rangeHigh
        pBottom  := rangeLow + span * 0.618
        // Equilibrium: mid ± width/2 as percent of span
        halfW    = equilibriumWidthInput / 100.0 * span * 0.5
        eTop     := mid + halfW
        eBottom  := mid - halfW
        // Discount: bottom to 38.2%
        dTop     := rangeLow + span * 0.382
        dBottom  := rangeLow
    else if method == 'Percentage'
        premPct  = math.clamp(premiumPercentageInput   / 100.0, 0.0, 1.0)
        discPct  = math.clamp(discountPercentageInput  / 100.0, 0.0, 1.0)
        pTop     := rangeHigh
        pBottom  := rangeLow + span * premPct
        dTop     := rangeLow + span * discPct
        dBottom  := rangeLow
        halfW    = equilibriumWidthInput / 100.0 * span * 0.5
        eTop     := mid + halfW
        eBottom  := mid - halfW
    else
        // ATR-based banding around mid
        atrV     = ta.atr(14)
        band     = math.max(atrV, span * 0.1)
        pTop     := rangeHigh
        pBottom  := mid + band * 0.5
        dTop     := mid - band * 0.5
        dBottom  := rangeLow
        eTop     := mid + band * 0.25
        eBottom  := mid - band * 0.25

    premiumDiscountZone.new(pTop, pBottom, eTop, eBottom, dTop, dBottom, rangeHigh, rangeLow)

// Draw zones (minimal)
drawPremiumDiscountZonesImproved(z) =>
    if na(z)
        0
    else
        right = bar_index + math.max(1, fairValueGapsExtendInput)

        // Premium
        if not na(z.premiumTop) and not na(z.premiumBottom)
            box.new(bar_index, z.premiumTop, right, z.premiumBottom,
                bgcolor = color.new(premiumZoneColorInput, 90), border_color = premiumZoneColorInput)

            if showZoneMidlinesInput
                line.new(bar_index, (z.premiumTop + z.premiumBottom) / 2, right, (z.premiumTop + z.premiumBottom) / 2, color = premiumZoneColorInput)

            if showZoneLabelsInput
                label.new(bar_index, z.premiumTop, "Premium", style = label.style_label_down, color = premiumZoneColorInput, textcolor = color.white)

        // Equilibrium
        if not na(z.equilibriumTop) and not na(z.equilibriumBottom)
            box.new(bar_index, z.equilibriumTop, right, z.equilibriumBottom,
                bgcolor = color.new(equilibriumZoneColorInput, 90), border_color = equilibriumZoneColorInput)

            if showZoneMidlinesInput
                line.new(bar_index, (z.equilibriumTop + z.equilibriumBottom) / 2, right, (z.equilibriumTop + z.equilibriumBottom) / 2, color = equilibriumZoneColorInput)

            if showZoneLabelsInput
                label.new(bar_index, z.equilibriumTop, "Equilibrium", style = label.style_label_left, color = equilibriumZoneColorInput, textcolor = color.white)

        // Discount
        if not na(z.discountTop) and not na(z.discountBottom)
            box.new(bar_index, z.discountTop, right, z.discountBottom,
                bgcolor = color.new(discountZoneColorInput, 90), border_color = discountZoneColorInput)

            if showZoneMidlinesInput
                line.new(bar_index, (z.discountTop + z.discountBottom) / 2, right, (z.discountTop + z.discountBottom) / 2, color = discountZoneColorInput)

            if showZoneLabelsInput
                label.new(bar_index, z.discountTop, "Discount", style = label.style_label_up, color = discountZoneColorInput, textcolor = color.white)
        0

// Locate current zone by price
getCurrentZonePosition(z) =>
    if na(z)
        'Unknown'
    else
        c = close
        c <= z.premiumTop and c >= z.premiumBottom ? 'Premium' :
         c <= z.discountTop and c >= z.discountBottom ? 'Discount' : 'Equilibrium'

// Detect touches of zone borders
checkZoneLevelTouch(z) =>
    if na(z)
        false
    else
        (low <= z.premiumTop and high >= z.premiumTop) or
        (low <= z.premiumBottom and high >= z.premiumBottom) or
        (low <= z.discountTop and high >= z.discountTop) or
        (low <= z.discountBottom and high >= z.discountBottom)
//---------------------------------------------------------------------------------------------------------------------
// MISSING FUNCTION IMPLEMENTATIONS
//---------------------------------------------------------------------------------------------------------------------

// Fair Value Gap drawing function
drawFairValueGaps() =>
    if showFairValueGapsInput
        // Calculate gaps
        gap_up = low > high[2] and close[1] > high[2]
        gap_down = high < low[2] and close[1] < low[2]
        
        // Draw bullish FVG
        if gap_up
            right_bar = bar_index + fairValueGapsExtendInput
            box.new(bar_index[2], high[2], right_bar, low, 
                bgcolor=fairValueGapBullishColor, border_color=na)
        
        // Draw bearish FVG  
        if gap_down
            right_bar = bar_index + fairValueGapsExtendInput
            box.new(bar_index[2], low[2], right_bar, high,
                bgcolor=fairValueGapBearishColor, border_color=na)

// Order Blocks drawing function  
drawOrderBlocks(isInternal = false) =>
    if isInternal and showInternalOrderBlocksInput
        // Internal order blocks logic
        if close > ta.highest(high, 5)[1]
            ob_low = ta.lowest(low, 3)[1]
            ob_high = ta.highest(high, 3)[1]
            box.new(bar_index-3, ob_low, bar_index, ob_high, 
                bgcolor=internalBullishOrderBlockColor, border_color=na)
    else if showSwingOrderBlocksInput
        // Swing order blocks logic
        if close > ta.highest(high, 20)[1]
            ob_low = ta.lowest(low, 10)[1] 
            ob_high = ta.highest(high, 10)[1]
            box.new(bar_index-10, ob_low, bar_index, ob_high,
                bgcolor=swingBullishOrderBlockColor, border_color=na)

// Levels drawing function
drawLevels(tf, isCurrentTF, lineStyle, clr) =>
    if not isCurrentTF
        htf_high = request.security(syminfo.tickerid, tf, ta.highest(high, 1), lookahead=barmerge.lookahead_off)
        htf_low = request.security(syminfo.tickerid, tf, ta.lowest(low, 1), lookahead=barmerge.lookahead_off)
        
        style = lineStyle == SOLID ? line.style_solid : lineStyle == DASHED ? line.style_dashed : line.style_dotted
        
        if not na(htf_high)
            line.new(bar_index, htf_high, bar_index+50, htf_high, color=clr, style=style, width=1, extend=extend.right)
        if not na(htf_low)
            line.new(bar_index, htf_low, bar_index+50, htf_low, color=clr, style=style, width=1, extend=extend.right)

// Drawing structure functions
drawSwingStructure() =>
    if showStructureInput
        na

drawInternalStructure() =>  
    if showInternalsInput
        na
