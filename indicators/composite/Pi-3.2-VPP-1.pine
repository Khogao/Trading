// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © lenguyenphi
// © 2025 Pi 3.2 Clean + VPP Engine (v3.4 - Hybrid Power)
// @version=5
indicator("Pi 3.2 + VPP", shorttitle="PI 3.2+VPP", overlay=true, max_labels_count=500, max_boxes_count=500, max_lines_count=500)

// === VPP MASTER PROFILE (from VPP 4.1) ===
var GRP_PROFILE = "🔥 1. Master Profile"
profile_selector = input.string("LTF Sniper", "Setting Profile", options=["HTF Strategist", "LTF Sniper", "Scalper Pro", "Swing Trader", "Custom"], group=GRP_PROFILE, tooltip="Advanced profiles from VPP5")

// === VPP CORE (from VPP 4.1) ===
var GRP_VPP = "📊 2. VPP Core Settings"
vp_lookback_depth_custom = input.int(200, 'Lookback Bars', minval=50, maxval=1000, group=GRP_VPP)
intraday_mode_custom = input.bool(true, 'Intraday Mode', group=GRP_VPP)
session_focus_custom = input.bool(true, 'Focus on Current Session', group=GRP_VPP)
intraday_lookback_days_custom = input.int(4, 'Intraday Lookback (days)', minval=1, maxval=30, group=GRP_VPP)
vp_num_levels = input.int(120, 'Price Levels', minval=50, maxval=200, group=GRP_VPP)
execution_sensitivity = input.string("Medium", "Update Sensitivity", options=["Ultra","High","Medium","Low"], group=GRP_VPP)

// === VPP DISPLAY ===
var GRP_VPP_DISPLAY = "🎨 3. VPP Display"
vp_bar_width = input.int(30, "Bar Width", minval=10, maxval=60, group=GRP_VPP_DISPLAY)
vp_right_offset = input.int(20, "Right Offset", minval=5, maxval=80, group=GRP_VPP_DISPLAY)
vp_show_poc = input.bool(true, "Show POC", group=GRP_VPP_DISPLAY, inline="poc")
vp_show_va = input.bool(true, "Show Value Area", group=GRP_VPP_DISPLAY, inline="va")
vp_show_va_lines = input.bool(true, "VA Lines", group=GRP_VPP_DISPLAY, inline="va")
structure_show_nodes = input.bool(false, "Show HVN/LVN", group=GRP_VPP_DISPLAY)

// === VSA SIGNALS ===
var GRP_VSA = "🎯 4. VSA Signals"
showSpring = input.bool(true, "Spring", group=GRP_VSA, inline="sig1")
showUpthrust = input.bool(true, "Upthrust", group=GRP_VSA, inline="sig1")
showClimax = input.bool(true, "Climax", group=GRP_VSA, inline="sig2")
showStoppingVol = input.bool(true, "Stopping Vol", group=GRP_VSA, inline="sig2")
showEffortResult = input.bool(true, "Effort vs Result", group=GRP_VSA, inline="sig3")
showSOS_SOW = input.bool(true, "SOS/SOW", group=GRP_VSA, inline="sig3")
showTestBars = input.bool(true, "Test Bars", group=GRP_VSA, inline="sig4")
showNoSupplyDemand = input.bool(true, "No Supply/Demand", group=GRP_VSA, inline="sig4")

// === VSA PARAMETERS ===
var GRP_VSA_PARAMS = "⚙️ 5. VSA Parameters"
lookbackHL = input.int(12, "H/L Lookback", group=GRP_VSA_PARAMS, minval=5, maxval=50)
volLookback = input.int(20, "Volume Lookback", group=GRP_VSA_PARAMS, minval=10, maxval=50)
volHighMultiplier = input.float(1.8, "High Volume", group=GRP_VSA_PARAMS, step=0.1, minval=1.0, maxval=5.0)
volLowMultiplier = input.float(0.6, "Low Volume", group=GRP_VSA_PARAMS, step=0.1, minval=0.1, maxval=1.0)
rangeNarrow = input.float(0.7, "Narrow Range", group=GRP_VSA_PARAMS, step=0.1, minval=0.3, maxval=1.0)
rangeWide = input.float(1.3, "Wide Range", group=GRP_VSA_PARAMS, step=0.1, minval=1.0, maxval=3.0)

// === TREND CONTEXT ===
var GRP_TREND = "🌊 6. Trend Context"
showEMA = input.bool(true, "Show EMA Lines", group=GRP_TREND)
emaFast = input.int(21, "Fast EMA", group=GRP_TREND, minval=5, maxval=50)
emaSlow = input.int(50, "Slow EMA", group=GRP_TREND, minval=20, maxval=100)
ema200 = input.int(200, "Long EMA", group=GRP_TREND, minval=100, maxval=300)
showEmaCloud = input.bool(true, "EMA Cloud", group=GRP_TREND)

// === DISPLAY CONTROLS ===
var GRP_DISPLAY = "📱 7. Display"
showInfoPanel = input.bool(true, "Info Panel", group=GRP_DISPLAY)
dashboardPosition = input.string("top_right", "Panel Position", options=["top_left","top_center","top_right","middle_left","middle_center","middle_right","bottom_left","bottom_center","bottom_right"], group=GRP_DISPLAY)
showBackground = input.bool(false, "VSA Background", group=GRP_DISPLAY)

// === COLORS ===
var GRP_COLORS = "🎨 8. Colors"
colorPOC = input.color(color.new(color.red, 0), "POC", group=GRP_COLORS, inline="vp1")
colorVA = input.color(color.new(color.blue, 70), "Value Area", group=GRP_COLORS, inline="vp1")
colorVolume = input.color(color.new(color.gray, 70), "Volume", group=GRP_COLORS, inline="vp2")
colorHVN = input.color(color.new(color.orange, 70), "HVN", group=GRP_COLORS, inline="vp2")

// === HTF VPP LINES (from VPP5) ===
var GRP_HTF = "🔥 9. HTF Volume Profile"
htf_enabled = input.bool(true, "Enable HTF Lines", group=GRP_HTF)
htf_timeframe = input.timeframe("4H", "HTF Timeframe", group=GRP_HTF)
htf_show_poc = input.bool(true, "HTF POC", group=GRP_HTF, inline="htf1")
htf_show_vah = input.bool(true, "HTF VAH", group=GRP_HTF, inline="htf1")
htf_show_val = input.bool(true, "HTF VAL", group=GRP_HTF, inline="htf2")
htf_poc_color = input.color(color.new(color.red, 0), "HTF POC Color", group=GRP_HTF, inline="htf3")
htf_va_color = input.color(color.new(color.blue, 30), "HTF VA Color", group=GRP_HTF, inline="htf3")

// HTF VP Helper Functions (from VPP5)
f_htf_get_poc() =>
    // Calculate current VP POC for HTF request
    if not na(price_step) and price_step > 0
        max_vol_htf = array.max(volume_at_price) 
        if max_vol_htf > 0
            poc_idx_htf = array.indexof(volume_at_price, max_vol_htf)
            price_low + poc_idx_htf * price_step
        else
            na
    else
        na

f_htf_get_vah() =>
    if not na(price_step) and price_step > 0
        max_vol_htf = array.max(volume_at_price)
        if max_vol_htf > 0
            poc_idx_htf = array.indexof(volume_at_price, max_vol_htf)
            [va_low_htf, va_high_htf] = f_calculate_value_area_vpp(poc_idx_htf, array.sum(volume_at_price), price_low, price_step)
            va_high_htf
        else
            na
    else
        na

f_htf_get_val() =>
    if not na(price_step) and price_step > 0
        max_vol_htf = array.max(volume_at_price)
        if max_vol_htf > 0
            poc_idx_htf = array.indexof(volume_at_price, max_vol_htf)
            [va_low_htf, va_high_htf] = f_calculate_value_area_vpp(poc_idx_htf, array.sum(volume_at_price), price_low, price_step)
            va_low_htf
        else
            na
    else
        na

// HTF Security Requests (no repaint)
htf_poc = htf_enabled ? request.security(syminfo.tickerid, htf_timeframe, f_htf_get_poc()) : na
htf_vah = htf_enabled ? request.security(syminfo.tickerid, htf_timeframe, f_htf_get_vah()) : na
htf_val = htf_enabled ? request.security(syminfo.tickerid, htf_timeframe, f_htf_get_val()) : na

// HTF Lines Plotting
plot(htf_show_poc and not na(htf_poc) ? htf_poc : na, "HTF POC", htf_poc_color, 2, plot.style_line)
plot(htf_show_vah and not na(htf_vah) ? htf_vah : na, "HTF VAH", htf_va_color, 1, plot.style_line)
plot(htf_show_val and not na(htf_val) ? htf_val : na, "HTF VAL", htf_va_color, 1, plot.style_line)

// ============================================================================
// VPP ENGINE (Exact from VPP 4.1)
// ============================================================================

// Profile Logic
// FIX: split multi-declarations into one-per-line
var int vp_lookback_depth = na
var int intraday_lookback_days = na
var bool intraday_mode = na
var bool session_focus = na

if profile_selector == "HTF Strategist"
    // FIX: split chained assignments into separate lines
    vp_lookback_depth := 400
    intraday_mode := false
    session_focus := false
    intraday_lookback_days := 30
else if profile_selector == "LTF Sniper"
    // FIX: split chained assignments into separate lines
    vp_lookback_depth := 200
    intraday_mode := true
    session_focus := true
    intraday_lookback_days := 4
else if profile_selector == "Scalper Pro"
    vp_lookback_depth := 100
    intraday_mode := true
    session_focus := true
    intraday_lookback_days := 1
else if profile_selector == "Swing Trader"
    vp_lookback_depth := 600
    intraday_mode := false
    session_focus := false
    intraday_lookback_days := 10
else
    // FIX: split chained assignments into separate lines
    vp_lookback_depth := vp_lookback_depth_custom
    intraday_mode := intraday_mode_custom
    session_focus := session_focus_custom
    intraday_lookback_days := intraday_lookback_days_custom

// VPP Variables
var float[] volume_at_price = array.new_float(0)
var box[] volume_boxes = array.new_box(0)
var box[] node_boxes = array.new_box(0)
var box poc_box = na
var int last_calc_bar = 0
var float price_high = na
var float price_low = na
var float price_step = na
var float prev_poc_price = na
var line vah_line = na
var line val_line = na
var label status_label = na

// VPP Helper Functions (Exact from VPP 4.1)
f_get_timeframe_mode() =>
    string tf_str =
        if timeframe.isdaily
            '1D'
        else if timeframe.isintraday
            if timeframe.multiplier >= 240
                '4H'
            else if timeframe.multiplier >= 60
                '1H'
            else if timeframe.multiplier >= 15
                '15m'
            else if timeframe.multiplier >= 5
                '5m'
            else
                '1m'
        else
            'Other'
    tf_str

f_price_to_index(price, local_price_low, local_price_step) => 
    local_price_step > 0 ? int(math.max(0, math.min(vp_num_levels - 1, math.floor((price - local_price_low) / local_price_step)))) : 0

f_calculate_value_area_vpp(poc_idx, total_vol, local_price_low, local_price_step) =>
    va_percentage = intraday_mode ? 0.70 : 0.70
    if poc_idx < 0 or total_vol <= 0
        [na, na]
    else
        target_volume = total_vol * va_percentage
        va_volume = array.get(volume_at_price, poc_idx)
        va_upper = poc_idx
        va_lower = poc_idx
        
        while va_volume < target_volume and (va_upper < vp_num_levels - 1 or va_lower > 0)
            vol_above = va_upper < vp_num_levels - 1 ? array.get(volume_at_price, va_upper + 1) : 0.0
            vol_below = va_lower > 0 ? array.get(volume_at_price, va_lower - 1) : 0.0
            
            if vol_above >= vol_below and va_upper < vp_num_levels - 1
                va_upper += 1
                va_volume += vol_above
            else if va_lower > 0
                va_lower -= 1
                va_volume += vol_below
            else
                break
        
        [local_price_low + va_lower * local_price_step, local_price_low + va_upper * local_price_step]

f_find_and_draw_nodes(max_vol, local_price_low, local_price_step, effective_lookback) =>
    hvn_vol_threshold = max_vol * 0.80
    lvn_vol_threshold = max_vol * 0.20
    
    in_hvn_zone = false
    hvn_start_idx = -1
    
    for i = 0 to vp_num_levels - 1
        is_hvn = array.get(volume_at_price, i) >= hvn_vol_threshold
        
        if is_hvn and not in_hvn_zone
            in_hvn_zone := true
            hvn_start_idx := i
        
        if not is_hvn and in_hvn_zone
            in_hvn_zone := false
            array.push(node_boxes, box.new(bar_index - effective_lookback, local_price_low + hvn_start_idx * local_price_step, bar_index + vp_right_offset, local_price_low + i * local_price_step, border_color=na, bgcolor=colorHVN))
    
    if in_hvn_zone
        array.push(node_boxes, box.new(bar_index - effective_lookback, local_price_low + hvn_start_idx * local_price_step, bar_index + vp_right_offset, local_price_low + (vp_num_levels) * local_price_step, border_color=na, bgcolor=colorHVN))

// ============================================================================
// VSA ENGINE (Clean from Pi 3.2)
// ============================================================================

type BarInfo
    bool isUp
    bool isDown
    bool isNarrow
    bool isWide
    bool isHighVol
    bool isLowVol
    float closeLocation

f_getBarInfo() =>
    range = high - low
    avgRange = ta.sma(range, 20)
    avgVol = ta.sma(volume, volLookback)
    closePos = range > 0 ? (close - low) / range : 0.5
    
    BarInfo.new(
        close > open,
        close < open,
        range < avgRange * rangeNarrow,
        range > avgRange * rangeWide,
        volume > avgVol * volHighMultiplier,
        volume < avgVol * volLowMultiplier,
        closePos
    )

// ============================================================================
// MAIN EXECUTION
// ============================================================================

// VPP Execution (Exact from VPP 4.1)
tf_mode_vpp = f_get_timeframe_mode()
tf_minutes = timeframe.in_seconds(timeframe.period) / 60.0

base_update_freq = switch tf_mode_vpp
    '1D' => math.max(10, vp_lookback_depth / 20)
    '4H' => math.max(5, vp_lookback_depth / 30)  
    '1H' => math.max(3, vp_lookback_depth / 40)
    '15m' => math.max(2, vp_lookback_depth / 50)
    '5m' => 2
    => 1

final_update_freq = switch execution_sensitivity
    'Ultra' => 1
    'High' => 2
    'Medium' => int(math.max(3, base_update_freq))
    => int(math.max(5, base_update_freq * 2))

avg_len = int(math.min(50, bar_index + 1))
avg_vol_norm = ta.sma(volume, avg_len) / tf_minutes
cur_vol_norm = volume / tf_minutes

vol_thresh = switch execution_sensitivity
    'Ultra' => 1.3
    'High' => 1.7
    'Medium' => 2.5
    => 4.0

move_thresh = switch execution_sensitivity
    'Ultra' => 0.002
    'High' => 0.003
    'Medium' => 0.005
    => 0.01

vol_spike = cur_vol_norm > avg_vol_norm * vol_thresh and avg_vol_norm > 0
price_move = math.abs(close - nz(close[1])) / nz(close[1], 1) > move_thresh
needs_update = barstate.islast or (bar_index - last_calc_bar >= final_update_freq) or vol_spike or price_move

bars_per_day = 1440 / tf_minutes
effective_lookback = if intraday_mode
    int(math.min(vp_lookback_depth, intraday_lookback_days * bars_per_day))
else
    switch tf_mode_vpp
        '1D' => math.min(vp_lookback_depth, 40)
        '4H' => math.min(vp_lookback_depth, 120)
        '1H' => math.min(vp_lookback_depth, 240)
        '15m' => math.min(vp_lookback_depth, 500)
        => math.min(vp_lookback_depth, 300)

// Status label
if not na(status_label)
    label.delete(status_label)
if needs_update and not barstate.islast
    status_label := label.new(bar_index, high, "Calculating...", yloc=yloc.abovebar, color=color.new(color.gray, 50), textcolor=color.white, style=label.style_label_down)

// Initialize array
if array.size(volume_at_price) != vp_num_levels
    array.clear(volume_at_price)
    for i = 0 to vp_num_levels - 1
        array.push(volume_at_price, 0.0)

// VPP Main Calculation
if needs_update
    price_high_all = ta.highest(high, effective_lookback)
    price_low_all = ta.lowest(low, effective_lookback)
    price_step_all = (price_high_all - price_low_all) / vp_num_levels
    
    // Cleanup
    // FIX: no comma-separated statements
    if not na(vah_line)
        line.delete(vah_line)
    if not na(val_line)
        line.delete(val_line)
    if not na(poc_box)
        box.delete(poc_box)
        poc_box := na
    
    for box_item in volume_boxes
        box.delete(box_item)
    array.clear(volume_boxes)
    
    for node_item in node_boxes
        box.delete(node_item)
    array.clear(node_boxes)
    
    array.fill(volume_at_price, 0.0)
    price_high := price_high_all
    price_low := price_low_all
    price_step := price_step_all
    
    if price_step > 0
        // VPP Calculation Loop (Exact from VPP 4.1)
        for b = 0 to int(math.min(effective_lookback - 1, bar_index))
            if volume[b] <= 0
                continue
                
            normalized_vol = volume[b] / tf_minutes
            
            age_decay_tf = switch tf_mode_vpp
                '1D' => 0.002
                '4H' => 0.006
                '1H' => 0.012
                '15m' => 0.03
                => 0.06
            
            age_decay = intraday_mode ? 0.03 : age_decay_tf
            age_weight = 1.0 / (1.0 + age_decay * b)
            session_weight_factor = 1.0
            
            if session_focus
                if intraday_mode
                    h = hour(time[b], syminfo.timezone)
                    in_window = h >= 9 and h < 17
                    if in_window
                        session_weight_factor := 1.2
            
            weighted_volume = normalized_vol * age_weight * session_weight_factor
            body_ratio = math.abs(close[b] - open[b]) / math.max(high[b] - low[b], price_step)
            typical_price = nz(body_ratio * (open[b] + close[b]) / 2 + (1 - body_ratio) * (high[b] + low[b]) / 2, close[b])
            price_range = high[b] - low[b]
            
            if price_range <= 0
                idx = f_price_to_index(typical_price, price_low, price_step)
                array.set(volume_at_price, idx, array.get(volume_at_price, idx) + weighted_volume * tf_minutes)
            else
                start_idx = f_price_to_index(low[b], price_low, price_step)
                end_idx = f_price_to_index(high[b], price_low, price_step)
                denom = math.max(1, end_idx - start_idx + 1)
                dist_denom = math.max(price_range / 2, price_step)
                
                for j = start_idx to end_idx
                    level_price = price_low + j * price_step
                    distance_factor = math.max(0.0, 1.0 - math.abs(level_price - typical_price) / dist_denom)
                    weight = math.max(0.05, distance_factor)
                    distributed_vol = weighted_volume * weight / denom
                    array.set(volume_at_price, j, array.get(volume_at_price, j) + distributed_vol * tf_minutes)
    
    last_calc_bar := bar_index

// VSA Analysis (Clean)
bar = f_getBarInfo()
atr = ta.atr(14)

// Basic VSA conditions
lowestLow = ta.lowest(low, lookbackHL)[1]
highestHigh = ta.highest(high, lookbackHL)[1]

// VSA Signals (Simple, clean)
isSpring = showSpring and bar.isDown and low <= lowestLow and close > low + (high - low) * 0.3 and bar.isHighVol
isUpthrust = showUpthrust and bar.isUp and high >= highestHigh and close < high - (high - low) * 0.3 and bar.isHighVol

isSellingClimax = showClimax and bar.isDown and bar.isWide and bar.isHighVol
isBuyingClimax = showClimax and bar.isUp and bar.isWide and bar.isHighVol

isStoppingVolume = showStoppingVol and bar.isDown and bar.isHighVol and bar.closeLocation > 0.6
isTestBarDown = showTestBars and bar.isDown and bar.isNarrow and bar.isLowVol and bar.closeLocation > 0.6
isTestBarUp = showTestBars and bar.isUp and bar.isNarrow and bar.isLowVol

isEffortNoResult = showEffortResult and bar.isHighVol and bar.isNarrow
isSOSBar = showSOS_SOW and bar.isUp and bar.isHighVol and bar.closeLocation > 0.7
isSOWBar = showSOS_SOW and bar.isDown and bar.isHighVol and bar.closeLocation < 0.3

isNoSupply = showNoSupplyDemand and bar.isDown and bar.isNarrow and bar.isLowVol
isNoDemand = showNoSupplyDemand and bar.isUp and bar.isNarrow and bar.isLowVol

// Simple VSA Score
vsaScore = 0.0
vsaScore += isSpring ? 2.5 : 0
vsaScore += isSellingClimax ? 2.0 : 0
vsaScore += isStoppingVolume ? 1.5 : 0
vsaScore += isSOSBar ? 2.0 : 0
vsaScore += isTestBarDown or isTestBarUp ? 1.0 : 0
vsaScore += isNoSupply ? 0.5 : 0

vsaScore -= isUpthrust ? 2.5 : 0
vsaScore -= isBuyingClimax ? 2.0 : 0
vsaScore -= isSOWBar ? 2.0 : 0
vsaScore -= isNoDemand ? 0.5 : 0
vsaScore -= isEffortNoResult ? 1.0 : 0

// ============================================================================
// PLOTTING
// ============================================================================

// VPP Plotting (Exact from VPP 4.1)
if needs_update and price_step > 0
    max_vol = array.max(volume_at_price)
    if max_vol > 0
        // Use enhanced nodes instead of original
        if structure_show_nodes
            f_enhanced_nodes(max_vol, price_low, price_step, effective_lookback)
        
        poc_idx = array.indexof(volume_at_price, max_vol)
        poc_price = price_low + poc_idx * price_step
        [va_low, va_high] = f_calculate_value_area_vpp(poc_idx, array.sum(volume_at_price), price_low, price_step)
        
        x_base = bar_index + vp_right_offset
        
        // Volume Profile Bars
        for i = 0 to vp_num_levels - 1
            level_volume = array.get(volume_at_price, i)
            if level_volume > 0
                bar_length = int(math.round(level_volume / max_vol * vp_bar_width))
                if bar_length > 0
                    level_price = price_low + i * price_step
                    is_in_va = vp_show_va and not na(va_low) and level_price >= va_low and level_price <= va_high
                    is_poc = i == poc_idx and vp_show_poc
                    
                    box_color = is_poc ? colorPOC : is_in_va ? colorVA : colorVolume
                    
                    array.push(volume_boxes, box.new(x_base, level_price - price_step / 2, x_base + bar_length, level_price + price_step / 2, bgcolor=box_color, border_color=na))
        
        // POC Box
        if vp_show_poc and not na(poc_price)
            poc_box := box.new(bar_index - effective_lookback, poc_price - price_step / 4, bar_index + vp_right_offset - 5, poc_price + price_step / 4, bgcolor=colorPOC, border_color=colorPOC)
        
        // VA Lines
        if vp_show_va_lines and not na(va_high)
            vah_line := line.new(bar_index - effective_lookback, va_high, bar_index + vp_right_offset + vp_bar_width, va_high, color=colorVA, width=2, style=line.style_dashed)
            val_line := line.new(bar_index - effective_lookback, va_low, bar_index + vp_right_offset + vp_bar_width, va_low, color=colorVA, width=2, style=line.style_dashed)
        
        prev_poc_price := poc_price

// EMA Lines
plot(showEMA ? ta.ema(close, emaFast) : na, "EMA Fast", color.aqua, 1)
plot(showEMA ? ta.ema(close, emaSlow) : na, "EMA Slow", color.orange, 1)
plot(showEMA ? ta.ema(close, ema200) : na, "EMA 200", color.gray, 2)

// EMA Cloud
p_fast = plot(showEMA ? ta.ema(close, emaFast) : na, color=na)
p_slow = plot(showEMA ? ta.ema(close, emaSlow) : na, color=na)
fill(p_fast, p_slow, color=showEmaCloud and showEMA ? (ta.ema(close, emaFast) > ta.ema(close, emaSlow) ? color.new(color.green, 80) : color.new(color.red, 80)) : na)

// Background
bgcolor(showBackground and math.abs(vsaScore) > 2 ? (vsaScore > 0 ? color.new(color.green, 80) : color.new(color.red, 80)) : na)

// VSA Labels
if barstate.isconfirmed
    if isSpring
        label.new(bar_index, low - atr * 0.5, "Spring", style=label.style_none, color=na, textcolor=color.green, size=size.small)
    if isUpthrust
        label.new(bar_index, high + atr * 0.5, "Upthrust", style=label.style_none, color=na, textcolor=color.red, size=size.small)
    if isSellingClimax
        label.new(bar_index, low - atr * 0.3, "SC", style=label.style_none, color=na, textcolor=color.blue, size=size.tiny)
    if isBuyingClimax
        label.new(bar_index, high + atr * 0.3, "BC", style=label.style_none, color=na, textcolor=color.purple, size=size.tiny)
    if isStoppingVolume
        label.new(bar_index, low - atr * 0.2, "StopVol", style=label.style_none, color=na, textcolor=color.teal, size=size.tiny)
    if isSOSBar
        label.new(bar_index, high + atr * 0.2, "SOS", style=label.style_none, color=na, textcolor=color.lime, size=size.tiny)
    if isSOWBar
        label.new(bar_index, low - atr * 0.2, "SOW", style=label.style_none, color=na, textcolor=color.maroon, size=size.tiny)
    if isTestBarDown or isTestBarUp
        label.new(bar_index, isTestBarDown ? low - atr * 0.1 : high + atr * 0.1, "Test", style=label.style_none, color=na, textcolor=color.yellow, size=size.tiny)
    if isEffortNoResult
        label.new(bar_index, high + atr * 0.1, "ENR", style=label.style_none, color=na, textcolor=color.gray, size=size.tiny)
    if isNoSupply
        label.new(bar_index, low - atr * 0.1, "NS", style=label.style_none, color=na, textcolor=color.silver, size=size.tiny)
    if isNoDemand
        label.new(bar_index, high + atr * 0.1, "ND", style=label.style_none, color=na, textcolor=color.silver, size=size.tiny)

// Information Panel
var table infoTable = na

if showInfoPanel and barstate.islast
    // FIX: each switch case on its own line (no commas)
    tablePosition = switch dashboardPosition
        "top_right" => position.top_right
        "top_left" => position.top_left
        "top_center" => position.top_center
        "middle_right" => position.middle_right
        "middle_left" => position.middle_left
        "middle_center" => position.middle_center
        "bottom_right" => position.bottom_right
        "bottom_left" => position.bottom_left
        "bottom_center" => position.bottom_center
    
    if na(infoTable)
        infoTable := table.new(tablePosition, 2, 10, bgcolor=color.new(color.white, 90), border_width=1)
    
    // Current analysis
    fastEMA = ta.ema(close, emaFast)
    slowEMA = ta.ema(close, emaSlow)
    longEMA = ta.ema(close, ema200)
    
    trendFast = close > fastEMA ? "↗" : "↘"
    trendSlow = fastEMA > slowEMA ? "BULL" : "BEAR"
    trendLong = close > longEMA ? "BULL" : "BEAR"
    
    volStatus = bar.isHighVol ? "HIGH" : bar.isLowVol ? "LOW" : "NORMAL"
    rangeStatus = bar.isWide ? "WIDE" : bar.isNarrow ? "NARROW" : "NORMAL"
    
    table.cell(infoTable, 0, 0, "Pi 3.2 + VPP", text_color=color.blue, bgcolor=color.new(color.white, 70))
    table.cell(infoTable, 1, 0, timeframe.period + " • " + profile_selector, text_color=color.gray, bgcolor=color.new(color.white, 70))
    
    table.cell(infoTable, 0, 1, "Trend Fast", text_color=color.black)
    table.cell(infoTable, 1, 1, trendFast, text_color=close > fastEMA ? color.green : color.red)
    
    table.cell(infoTable, 0, 2, "Trend Med", text_color=color.black)
    table.cell(infoTable, 1, 2, trendSlow, text_color=fastEMA > slowEMA ? color.green : color.red)
    
    table.cell(infoTable, 0, 3, "Trend Long", text_color=color.black)
    table.cell(infoTable, 1, 3, trendLong, text_color=close > longEMA ? color.green : color.red)
    
    table.cell(infoTable, 0, 4, "Volume", text_color=color.black)
    table.cell(infoTable, 1, 4, volStatus, text_color=bar.isHighVol ? color.red : bar.isLowVol ? color.gray : color.blue)
    
    table.cell(infoTable, 0, 5, "Range", text_color=color.black)
    table.cell(infoTable, 1, 5, rangeStatus, text_color=bar.isWide ? color.orange : bar.isNarrow ? color.gray : color.blue)
    
    table.cell(infoTable, 0, 6, "Close Pos", text_color=color.black)
    table.cell(infoTable, 1, 6, str.tostring(bar.closeLocation, "#.##"), text_color=bar.closeLocation > 0.7 ? color.green : bar.closeLocation < 0.3 ? color.red : color.gray)
    
    table.cell(infoTable, 0, 7, "VSA Score", text_color=color.black)
    table.cell(infoTable, 1, 7, str.tostring(vsaScore, "#.#"), text_color=vsaScore > 0 ? color.green : vsaScore < 0 ? color.red : color.gray)
    
    table.cell(infoTable, 0, 8, "Mode", text_color=color.black)
    table.cell(infoTable, 1, 8, intraday_mode ? "INTRADAY" : "SWING", text_color=intraday_mode ? color.orange : color.blue)
    
    // VPP POC info if available
    if not na(price_high) and not na(price_step)
        max_vol_info = array.max(volume_at_price)
        if max_vol_info > 0
            poc_idx_info = array.indexof(volume_at_price, max_vol_info)
            poc_price_info = price_low + poc_idx_info * price_step
            table.cell(infoTable, 0, 9, "VPP POC", text_color=color.black)
            table.cell(infoTable, 1, 9, str.tostring(poc_price_info, format.mintick), text_color=colorPOC)

    // Add HTF VP info
    table.cell(infoTable, 0, 9, "HTF POC", text_color=color.black)
    table.cell(infoTable, 1, 9, not na(htf_poc) ? str.tostring(htf_poc, format.mintick) : "N/A", text_color=htf_poc_color)
    
    table.cell(infoTable, 0, 10, "HTF VA Range", text_color=color.black)
    va_range_text = not na(htf_vah) and not na(htf_val) ? str.tostring(htf_vah - htf_val, format.mintick) : "N/A"
    table.cell(infoTable, 1, 10, va_range_text, text_color=htf_va_color)

// Simple alerts
alertcondition(isSpring, "Spring", "Spring pattern detected")
alertcondition(isUpthrust, "Upthrust", "Upthrust pattern detected")
alertcondition(vsaScore > 3, "Strong Bullish VSA", "Strong bullish VSA signals")
alertcondition(vsaScore < -3, "Strong Bearish VSA", "Strong bearish VSA signals")