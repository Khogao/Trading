// This Pine Script¬Æ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// ¬© lenguyenphi

//@version=6
// TITLE: CVD+VSA Pro (Volume by Z-Score + Multi-TF CVD Dashboard)
// DESC: Fork t·ª´ Better CVD + (plotdiv-fork) v·ªõi t√≠ch h·ª£p 16 t√≠n hi·ªáu VSA c∆° b·∫£n, absorption, UI t·ªëi gi·∫£n, marker k√Ω t·ª± vi·∫øt t·∫Øt, ƒë√∫ng m√†u/v·ªã tr√≠.
// Author: Khogao, 2025 (modified for Z-score volume coloring + multi-TF dashboard)

indicator("CVD+VSA ProZero", "CVPZ", overlay = true)
import TradingView/ta/8

// === NHOM 1: CVD ENGINE ===
const string GRP_CVD = "‚öôÔ∏è CVD Engine"
anchorInput = input.timeframe("D", "Chu k·ª≥ reset CVD", group = GRP_CVD, tooltip = "Khung th·ªùi gian m√† CVD reset (t√≠nh l·∫°i). 'D' (ng√†y) ƒë∆∞·ª£c khuy·∫øn ngh·ªã cho intraday.")
useCustomTimeframeInput = input.bool(false, "D√πng khung th·ªùi gian t√πy ch·ªânh", group = GRP_CVD, tooltip = "Ghi ƒë√® l·ª±a ch·ªçn t·ª± ƒë·ªông khung th·ªùi gian th·∫•p h∆°n ƒë·ªÉ t√≠nh delta. D√πng th·∫≠n tr·ªçng.")
lowerTimeframeInput = input.timeframe("1", "Khung th·ªùi gian th·∫•p h∆°n", group = GRP_CVD)
maTypeInput = input.string("SMA", "Lo·∫°i MA", options=["SMA", "EMA", "WMA", "VWMA"], group = GRP_CVD)
maLengthInput = input.int(20, "ƒê·ªô d√†i MA", group = GRP_CVD)
bbMultInput = input.float(2.0, "BB StdDev", minval=0.001, maxval=50, group = GRP_CVD)
showBollingerBands = input.bool(true, "Hi·ªÉn th·ªã Bollinger Bands", group = GRP_CVD, tooltip="BB tr√™n CVD nh∆∞ m·ª©c qu√° mua/b√°n ƒë·ªông.")

// === NHOM 2: DIVERGENCE ENGINE ===
const string GRP_DIVERGENCE = "üìä Ph√¢n k·ª≥ (Divergence)"
// CVD+Price Divergence
showRegular = input.bool(true, "C+P: Ph√¢n k·ª≥ th∆∞·ªùng", group = GRP_DIVERGENCE)
showHidden = input.bool(true, "C+P: Ph√¢n k·ª≥ ·∫©n", group = GRP_DIVERGENCE)
// CVD+Volume Divergence
showCvdVolRegular = input.bool(true, "C+V: Ph√¢n k·ª≥ th∆∞·ªùng", group = GRP_DIVERGENCE)
showCvdVolHidden = input.bool(true, "C+V: Ph√¢n k·ª≥ ·∫©n", group = GRP_DIVERGENCE)
// Pivot Settings
lookbackLeft = input.int(5, "Pivot: Lookback tr√°i", group = GRP_DIVERGENCE)
lookbackRight = input.int(5, "Pivot: Lookback ph·∫£i", group = GRP_DIVERGENCE)
rangeLower = input.int(5, "Pivot: Range min", group = GRP_DIVERGENCE)
rangeUpper = input.int(60, "Pivot: Range max", group = GRP_DIVERGENCE)

// === NHOM 3: DISPLAY & TABLE ===
const string GRP_DISPLAY = "üé® Hi·ªÉn th·ªã"
plotStyle = input.string("Line with MA", "CVD: Ki·ªÉu v·∫Ω", options=["Line with MA", "Candles"], group = GRP_DISPLAY)
showCandleColors = input.bool(true, title="T√¥ m√†u n·∫øn khi v∆∞·ª£t BB", group = GRP_DISPLAY)
// Y Scale & Baseline
cvdYScale = input.float(1.0, "Y Scale: CVD", minval=0.1, maxval=100.0, step=0.1, group = GRP_DISPLAY)
volumeYScale = input.float(1.0, "Y Scale: Volume", minval=0.1, maxval=100.0, step=0.1, group = GRP_DISPLAY)
cvdZeroOffset = input.float(0.0, "Baseline: CVD", step=1.0, group = GRP_DISPLAY)
volumeZeroOffset = input.float(0.0, "Baseline: Volume", step=1.0, group = GRP_DISPLAY)
showCvdBaseline = input.bool(true, "Show CVD Baseline", group = GRP_DISPLAY)
showVolumeBaseline = input.bool(true, "Show Vol Baseline", group = GRP_DISPLAY)
cvdChartAlpha = input.int(20, "Alpha: CVD", minval=0, maxval=100, group = GRP_DISPLAY)
volumeChartAlpha = input.int(20, "Alpha: Volume", minval=0, maxval=100, group = GRP_DISPLAY)
// Labels & Table
bullLabelOffset = input.float(0.5, "Label Offset: Bull", minval=0.0, maxval=5.0, step=0.1, group=GRP_DISPLAY)
bearLabelOffset = input.float(0.5, "Label Offset: Bear", minval=0.0, maxval=5.0, step=0.1, group=GRP_DISPLAY)
showTable = input.bool(true, 'Multi-TF Table', group = GRP_DISPLAY)
tablePosition = input.string("top_right", "Table Position", options=['top_left','top_right'], group = GRP_DISPLAY)

// === NHOM 4: ALERTS ===
const string GRP_ALERTS = "üîî C·∫£nh b√°o (Alerts)"
// Basic Divergence Alerts
enableBasicDivAlerts = input.bool(true, "Enable Basic Divergence Alerts", group = GRP_ALERTS)
// Confluent Alerts (High Probability)
enableConfluentAlerts = input.bool(true, "Enable Confluent Alerts (C+P + C+V)", group = GRP_ALERTS, tooltip="Alert khi c·∫£ CVD+Price V√Ä CVD+Volume divergence x·∫£y ra c√πng l√∫c - x√°c su·∫•t cao!")
// Extreme Alerts
enableBBBreakAlerts = input.bool(true, "Enable BB Break Alerts", group = GRP_ALERTS)
enableVSAConfluentAlerts = input.bool(true, "Enable VSA+Divergence Confluent", group = GRP_ALERTS, tooltip="Alert khi VSA signal tr√πng v·ªõi divergence - setup m·∫°nh!")
// Triple Confluence (Ultimate Setup)
enableTripleConfluence = input.bool(true, "Enable Triple Confluence (C+P + C+V + VSA)", group = GRP_ALERTS, tooltip="Alert khi c√≥ ƒë·ªìng th·ªùi: CVD+Price div, CVD+Volume div, V√Ä VSA signal - ch·∫Øc ƒÉn nh·∫•t!")

// === NHOM 5: COLOR SETTINGS ===
const string GRP_COLORS = "üé® M√†u s·∫Øc"
bullColor = input.color(color.green, "M√†u tƒÉng (Bullish)", group = GRP_COLORS)
bearColor = input.color(color.red, "M√†u gi·∫£m (Bearish)", group = GRP_COLORS)
hiddenBullColor = input.color(color.green, "M√†u ph√¢n k·ª≥ ·∫©n tƒÉng", group = GRP_COLORS)
hiddenBearColor = input.color(color.red, "M√†u ph√¢n k·ª≥ ·∫©n gi·∫£m", group = GRP_COLORS)

// === M√†u s·∫Øc cho styling (d·ª±a tr√™n inputs) ===
BULL_COLOR = color.new(bullColor, 20)
BEAR_COLOR = color.new(bearColor, 20)
HIDDEN_BULL_COLOR = color.new(hiddenBullColor, 20)
HIDDEN_BEAR_COLOR = color.new(hiddenBearColor, 20)
const color BULL_BG_COLOR = color.new(color.green, 80)
const color BEAR_BG_COLOR = color.new(color.red, 80)

// === MA helper ===
ma(s, l, t) =>
    switch t
        "SMA" => ta.sma(s, l)
        "EMA" => ta.ema(s, l)
        "WMA" => ta.wma(s, l)
        => ta.vwma(s, l)  // default VWMA

// Lower TF resolver (works both in main scope and inside request.security)
f_lowerTf() =>
    if useCustomTimeframeInput
        lowerTimeframeInput
    else
        switch
            timeframe.isseconds => "1S"
            timeframe.isintraday => "1" 
            timeframe.isdaily => "5"
            => "60"

// Return CVD "close" from requestVolumeDelta
f_cvdClose() =>
    [_o, _h, _l, _c] = ta.requestVolumeDelta(f_lowerTf(), anchorInput)
    _c 

// === CVD CALCULATION ENGINE ===
[openVolume, maxVolume, minVolume, lastVolume] = ta.requestVolumeDelta(f_lowerTf(), anchorInput)
cvdSource = f_cvdClose()

var float cumVol = 0.0
cumVol += nz(volume)
if barstate.islast and cumVol == 0
    runtime.error("This symbol has no volume data, CVD cannot be calculated.")

// === DIVERGENCE ENGINE ===
plVal = ta.pivotlow(cvdSource, lookbackLeft, lookbackRight)
phVal = ta.pivothigh(cvdSource, lookbackLeft, lookbackRight)
plFound = not na(plVal)
phFound = not na(phVal)
plSince = ta.barssince(plFound)
phSince = ta.barssince(phFound)
inRangePL_now = plSince[1] >= rangeLower and plSince[1] <= rangeUpper
inRangePH_now = phSince[1] >= rangeLower and phSince[1] <= rangeUpper

priceLL = low[lookbackRight] < ta.valuewhen(plFound, low[lookbackRight], 1)
cvdHL   = plVal > ta.valuewhen(plFound, plVal, 1) and inRangePL_now
bullCond = showRegular and priceLL and cvdHL and plFound

priceHH = high[lookbackRight] > ta.valuewhen(phFound, high[lookbackRight], 1)
cvdLH   = phVal < ta.valuewhen(phFound, phVal, 1) and inRangePH_now
bearCond = showRegular and priceHH and cvdLH and phFound

priceHL = low[lookbackRight] > ta.valuewhen(plFound, low[lookbackRight], 1)
cvdLL   = plVal < ta.valuewhen(plFound, plVal, 1) and inRangePL_now
hiddenBullCond = showHidden and priceHL and cvdLL and plFound

priceLH = high[lookbackRight] < ta.valuewhen(phFound, high[lookbackRight], 1)
cvdHH   = phVal > ta.valuewhen(phFound, phVal, 1) and inRangePH_now
hiddenBearCond = showHidden and priceLH and cvdHH and phFound

// === CVD + VOLUME DIVERGENCE ENGINE ===
// So s√°nh CVD pivots v·ªõi volume T·∫†I c√°c CVD pivot bars (kh√¥ng c·∫ßn volume pivots)
prev_plVal = ta.valuewhen(plFound, plVal, 1)
prev_phVal = ta.valuewhen(phFound, phVal, 1)
// Volume t·∫°i CVD pivot bar hi·ªán t·∫°i vs tr∆∞·ªõc ƒë√≥
prev_vol_at_cvd_low = ta.valuewhen(plFound, volume[lookbackRight], 1)
prev_vol_at_cvd_high = ta.valuewhen(phFound, volume[lookbackRight], 1)

// Regular CVD+Volume Divergence (t∆∞∆°ng t·ª± nh∆∞ CVD+Price regular)
cvdVolBullRegular = showCvdVolRegular and plFound and inRangePL_now and plVal > prev_plVal and volume[lookbackRight] < prev_vol_at_cvd_low
cvdVolBearRegular = showCvdVolRegular and phFound and inRangePH_now and phVal < prev_phVal and volume[lookbackRight] > prev_vol_at_cvd_high

// Hidden CVD+Volume Divergence (ng∆∞·ª£c v·ªõi regular)
cvdVolBullHidden = showCvdVolHidden and plFound and inRangePL_now and plVal < prev_plVal and volume[lookbackRight] < prev_vol_at_cvd_low
cvdVolBearHidden = showCvdVolHidden and phFound and inRangePH_now and phVal > prev_phVal and volume[lookbackRight] > prev_vol_at_cvd_high

// Combined flags for backward compatibility
cvdVolBull = cvdVolBullRegular or cvdVolBullHidden
cvdVolBear = cvdVolBearRegular or cvdVolBearHidden

// CVD+Volume divergence lines s·∫Ω ƒë∆∞·ª£c v·∫Ω b·∫±ng plot() tr√™n Volume chart (xem ph·∫ßn Volume Z-Score)

// CVD+Volume labels s·∫Ω ƒë∆∞·ª£c v·∫Ω b·∫±ng plotshape() tr√™n Volume chart (xem ph·∫ßn Volume Z-Score)



// === PLOTTING ===
isLinePlot   = plotStyle == "Line with MA"
isCandlePlot = plotStyle == "Candles"
cvdMA = ma(cvdSource, maLengthInput, maTypeInput)
cvdLineColor = cvdSource > cvdSource[1] ? color.blue : color.orange
// plotted (visual) series are offset by cvdZeroOffset so you can move the visual zero line
// apply alpha to CVD visuals AND cvdYScale to stretch Y axis
pCVD = plot((cvdSource * cvdYScale) + cvdZeroOffset, "CVD", color=color.new(cvdLineColor, cvdChartAlpha), linewidth=2, display=isLinePlot ? display.all : display.none)
pMA  = plot((cvdMA * cvdYScale) + cvdZeroOffset, "CVD MA", color=color.new(color.gray, cvdChartAlpha), linewidth=1, display=isLinePlot ? display.all : display.none)
fill(pCVD, pMA, color=isLinePlot ? (cvdSource > cvdMA ? color.new(color.blue, cvdChartAlpha) : color.new(color.orange, cvdChartAlpha)) : na)
// CVD candle color (alpha-aware)
cCol = lastVolume >= openVolume ? color.new(color.teal, cvdChartAlpha) : color.new(color.red, cvdChartAlpha)
// shift CVD candle visuals to be anchored at cvdZeroOffset (baseline), apply Y scale
plotcandle((openVolume * cvdYScale) + cvdZeroOffset, (maxVolume * cvdYScale) + cvdZeroOffset, (minVolume * cvdYScale) + cvdZeroOffset, (lastVolume * cvdYScale) + cvdZeroOffset, "CVD Candles", color=cCol, bordercolor=cCol, wickcolor=cCol, display=isCandlePlot ? display.all : display.none)
cvdMA_bb = ta.sma(cvdSource, maLengthInput)
bbUpper = cvdMA_bb + ta.stdev(cvdSource, maLengthInput) * bbMultInput
bbLower = cvdMA_bb - ta.stdev(cvdSource, maLengthInput) * bbMultInput
plot((bbUpper * cvdYScale) + cvdZeroOffset, "BB Tr√™n", color=color.new(color.gray, cvdChartAlpha), style=plot.style_line, display=showBollingerBands ? display.all : display.none)
plot((bbLower * cvdYScale) + cvdZeroOffset, "BB D∆∞·ªõi", color=color.new(color.gray, cvdChartAlpha), style=plot.style_line, display=showBollingerBands ? display.all : display.none)

// === DIVERGENCE PLOTTING (Better RSI style - pivot dots + plot lines) ===
// Array l∆∞u id label divergence ƒë·ªÉ x√≥a label c≈© khi v∆∞·ª£t qu√° 100
var label[] divLabels = array.new<label>()
divLabelLimit = 100
// companion array to track label x positions and avoid duplicates at same pivot
var int[] divLabelXs = array.new_int()

// === H√ÄM HELPER: T·∫†O LABEL PH√ÇN K·ª≤ (gi·∫£m code l·∫∑p) ===
f_createDivLabel(int x, float y, string labelText, bool isBearish, color bgColor, label[] labelArray, int[] labelXArray, int maxLabels) =>
    labelStyle = isBearish ? label.style_label_down : label.style_label_up
    newLabel = label.new(x=x, y=y, text=labelText, style=labelStyle, color=bgColor, textcolor=color.white, size=size.tiny)
    array.unshift(labelArray, newLabel)
    array.unshift(labelXArray, x)
    if array.size(labelArray) > maxLabels
        label.delete(array.get(labelArray, -1))
        array.pop(labelArray)
        array.pop(labelXArray)
    newLabel

// === DIVERGENCE LINES (CVD+Price) tr√™n price chart ===
// T√≠nh ATR cho offset labels
atr_for_labels = ta.atr(14)

// V·∫Ω ƒë∆∞·ªùng n·ªëi divergence tr√™n price chart theo Better RSI style
// G·ªôp regular + hidden v√†o 2 plots (bull/bear) ƒë·ªÉ ti·∫øt ki·ªám plot count
bullDivColor = bullCond ? BULL_COLOR : hiddenBullCond ? HIDDEN_BULL_COLOR : color.new(color.white, 100)
bearDivColor = bearCond ? BEAR_COLOR : hiddenBearCond ? HIDDEN_BEAR_COLOR : color.new(color.white, 100)
plot(plFound ? low[lookbackRight] : na, offset=-lookbackRight, title="Bull Divergence Lines", linewidth=2, color=bullDivColor)
plot(phFound ? high[lookbackRight] : na, offset=-lookbackRight, title="Bear Divergence Lines", linewidth=2, color=bearDivColor)

// Plotshape cho CVD+Price divergence labels (4 plotshape v·ªõi const text)
plotshape(bullCond ? low[lookbackRight] - (atr_for_labels * bullLabelOffset) : na, offset=-lookbackRight, title="Bull Label", text="Bull", style=shape.labelup, location=location.absolute, color=BULL_COLOR, textcolor=color.white, size=size.tiny)
plotshape(bearCond ? high[lookbackRight] + (atr_for_labels * bearLabelOffset) : na, offset=-lookbackRight, title="Bear Label", text="Bear", style=shape.labeldown, location=location.absolute, color=BEAR_COLOR, textcolor=color.white, size=size.tiny)
plotshape(hiddenBullCond ? low[lookbackRight] - (atr_for_labels * bullLabelOffset) : na, offset=-lookbackRight, title="H.Bull Label", text="H.Bull", style=shape.labelup, location=location.absolute, color=HIDDEN_BULL_COLOR, textcolor=color.white, size=size.tiny)
plotshape(hiddenBearCond ? high[lookbackRight] + (atr_for_labels * bearLabelOffset) : na, offset=-lookbackRight, title="H.Bear Label", text="H.Bear", style=shape.labeldown, location=location.absolute, color=HIDDEN_BEAR_COLOR, textcolor=color.white, size=size.tiny)
bgcolor(bullCond or hiddenBullCond ? BULL_BG_COLOR : na, title="Bullish Divergence BG Alert")
bgcolor(bearCond or hiddenBearCond ? BEAR_BG_COLOR : na, title="Bearish Divergence BG Alert")
cvd_is_overbought = cvdSource > bbUpper
cvd_is_oversold = cvdSource < bbLower
barcolor(showCandleColors and cvd_is_overbought ? color.new(color.red, 75) : na, title="CVD Overbought")
barcolor(showCandleColors and cvd_is_oversold ? color.new(color.green, 75) : na, title="CVD Oversold")

// === MULTI-TF CVD TABLE (5m, 15m, 1h, 4h) ===
cvd_5m  = request.security(syminfo.tickerid, "5",  f_cvdClose())
ma_5m   = request.security(syminfo.tickerid, "5",  ta.sma(f_cvdClose(), maLengthInput))
cvd_15m = request.security(syminfo.tickerid, "15", f_cvdClose())
ma_15m  = request.security(syminfo.tickerid, "15", ta.sma(f_cvdClose(), maLengthInput))
cvd_1h  = request.security(syminfo.tickerid, "60", f_cvdClose())
ma_1h   = request.security(syminfo.tickerid, "60", ta.sma(f_cvdClose(), maLengthInput))
cvd_4h  = request.security(syminfo.tickerid, "240", f_cvdClose())
ma_4h   = request.security(syminfo.tickerid, "240", ta.sma(f_cvdClose(), maLengthInput))

cell_col_5m  = cvd_5m  > ma_5m  ? color.new(color.green, 70) : color.new(color.red, 70)
cell_col_15m = cvd_15m > ma_15m ? color.new(color.green, 70) : color.new(color.red, 70)
cell_col_1h  = cvd_1h  > ma_1h  ? color.new(color.green, 70) : color.new(color.red, 70)
cell_col_4h  = cvd_4h  > ma_4h  ? color.new(color.green, 70) : color.new(color.red, 70)

if showTable and barstate.islast
    table_pos = tablePosition == "top_right" ? position.top_right : position.top_left
    var table cvdTable = table.new(position=table_pos, columns=2, rows=5, bgcolor=color.new(color.gray, 80), border_width=1, frame_color=color.new(color.gray, 60))
    table.cell(cvdTable, 0, 0, "TF", text_size=size.tiny, bgcolor=color.new(color.gray, 60), text_color=color.white)
    table.cell(cvdTable, 1, 0, "CVD", text_size=size.tiny, bgcolor=color.new(color.gray, 60), text_color=color.white)
    table.cell(cvdTable, 0, 1, "5m", text_size=size.tiny)
    table.cell(cvdTable, 1, 1, str.tostring(cvd_5m, format.mintick), bgcolor=cell_col_5m, text_color=color.white, text_size=size.tiny)
    table.cell(cvdTable, 0, 2, "15m", text_size=size.tiny)
    table.cell(cvdTable, 1, 2, str.tostring(cvd_15m, format.mintick), bgcolor=cell_col_15m, text_color=color.white, text_size=size.tiny)
    table.cell(cvdTable, 0, 3, "1H", text_size=size.tiny)
    table.cell(cvdTable, 1, 3, str.tostring(cvd_1h, format.mintick), bgcolor=cell_col_1h, text_color=color.white, text_size=size.tiny)
    table.cell(cvdTable, 0, 4, "4H", text_size=size.tiny)
    table.cell(cvdTable, 1, 4, str.tostring(cvd_4h, format.mintick), bgcolor=cell_col_4h, text_color=color.white, text_size=size.tiny)

// alerts are declared later after VSA logic to ensure volume guards are available

// === HELPER: Check if integer array contains value (d√πng cho VSA labels) ===
f_array_has_int(_arr, _val) =>
    _n = array.size(_arr)
    if _n == 0
        false
    else
        found = false
        for _i = 0 to _n - 1
            if array.get(_arr, _i) == _val
                found := true
        found

// === NHOM 6: VSA SIGNALS (Top 10 cho Crypto) ===
const string GRP_VSA = "üí° VSA Signals"
showVSASignals = input.bool(true, "Hi·ªÉn th·ªã t√≠n hi·ªáu VSA", group=GRP_VSA, tooltip="10 t√≠n hi·ªáu VSA quan tr·ªçng nh·∫•t cho BTC/Crypto trading")
showSC = input.bool(true, "Selling Climax (SC) - ƒê·ªânh b√°n th√°o", group=GRP_VSA)
showBC = input.bool(true, "Buying Climax (BC) - ƒê·ªânh mua v√†o", group=GRP_VSA)
showND = input.bool(true, "No Demand (ND) - Kh√¥ng c√≥ c·∫ßu", group=GRP_VSA)
showNS = input.bool(true, "No Supply (NS) - Kh√¥ng c√≥ cung", group=GRP_VSA)
showUT = input.bool(true, "Upthrust (UT) - ƒê·∫©y gi√° gi·∫£", group=GRP_VSA)
showSP = input.bool(true, "Spring (SP) - L√≤ xo b·∫≠t l√™n", group=GRP_VSA)
showSV = input.bool(true, "Stopping Volume (SV) - Volume d·ª´ng xu h∆∞·ªõng", group=GRP_VSA)
showWK = input.bool(true, "Weakness (WK) - Y·∫øu", group=GRP_VSA)
showST = input.bool(true, "Strength (ST) - M·∫°nh", group=GRP_VSA)
showSO = input.bool(true, "Shakeout (SO) - R≈© b·ªè", group=GRP_VSA)
showVSALegend = input.bool(true, "Hi·ªÉn th·ªã ch√∫ gi·∫£i VSA (legend)", group=GRP_VSA)
legendPosition = input.string("bottom_right", "V·ªã tr√≠ legend", options=["top_left","top_right","bottom_left","bottom_right"], group=GRP_VSA)
vsaVolumeLength = input.int(20, "ƒê·ªô d√†i MA Volume cho VSA", minval=5, maxval=100, group=GRP_VSA)
vsaSensitivity = input.float(1.5, "ƒê·ªô nh·∫°y VSA", minval=1.0, maxval=3.0, step=0.1, group=GRP_VSA)
vsaClassifierMethod = input.string("zscore", "Volume classifier method", options=["ratio", "zscore"], group=GRP_VSA)
vsa_zscore_sensitivity_ltf = input.float(2.5, "VSA Z-score Sensitivity (LTF 1-15m)", minval=0.5, maxval=6.0, step=0.1, group=GRP_VSA, tooltip="Start higher on LTF to reduce noise")
vsa_zscore_sensitivity_htf = input.float(1.6, "VSA Z-score Sensitivity (HTF 1H+)", minval=0.5, maxval=6.0, step=0.1, group=GRP_VSA, tooltip="Lower on HTF where signals are cleaner")

// compute effective sensitivity depending on chart timeframe
mult_num = timeframe.multiplier
isLTF = timeframe.isintraday and mult_num <= 15
isHTF = timeframe.isdaily or timeframe.isweekly or (timeframe.isintraday and mult_num >= 60)
vsa_zscore_sensitivity = isLTF ? vsa_zscore_sensitivity_ltf : (isHTF ? vsa_zscore_sensitivity_htf : vsa_zscore_sensitivity_htf)
// Optional confirmation and label throttling
vsaRequireCvdConfirm = input.bool(false, "Require CVD confirmation (bull -> CVD>MA, bear -> CVD<MA)", group=GRP_VSA)
vsaLabelLimit = input.int(200, "Max VSA Labels", minval=10, maxval=2000, group=GRP_VSA)

// === VSA LOGIC ===
// compute moving average and basic spreads
volumeMA_vsa2 = ta.sma(volume, vsaVolumeLength)
atr_vsa = ta.atr(14)
spread_vsa = high - low
wideSpread_vsa = spread_vsa > atr_vsa * 1.2
narrowSpread_vsa = spread_vsa < atr_vsa * 0.5

// safety helpers for ratio and z-score classification
f_safe_ratio(num, den, defVal) => den == 0 ? defVal : num / den
f_zscore(series, length) =>
    _ma = ta.sma(series, length)
    _sd = ta.stdev(series, length)
    _sd == 0 ? 0.0 : (series - _ma) / _sd

// compute both ratio and z-score candidates
vol_z = f_zscore(volume, vsaVolumeLength)
volRatio = f_safe_ratio(volume, volumeMA_vsa2, 1.0)

isHigh_ratio = volRatio >= vsaSensitivity
isVeryHigh_ratio = volRatio >= (vsaSensitivity * 1.5)
isUltraHigh_ratio = volRatio >= (vsaSensitivity * 2.0)

isHigh_zscore = vol_z >= vsa_zscore_sensitivity
isVeryHigh_zscore = vol_z >= (vsa_zscore_sensitivity + 1.0)
isUltraHigh_zscore = vol_z >= (vsa_zscore_sensitivity + 2.0)

// final flags chosen by method (keeps ratio as default for compatibility)
isHigh_final = vsaClassifierMethod == "zscore" ? isHigh_zscore : isHigh_ratio
isVeryHigh_final = vsaClassifierMethod == "zscore" ? isVeryHigh_zscore : isVeryHigh_ratio
isUltraHigh_final = vsaClassifierMethod == "zscore" ? isUltraHigh_zscore : isUltraHigh_ratio

// low-volume remains ratio-based
lowVolume_vsa = volume < volumeMA_vsa2 * 0.7

// expose VSA booleans for signals
highVolume_vsa = isHigh_final
veryHighVolume_vsa = isVeryHigh_final
ultraHighVolume_vsa = isUltraHigh_final

// reliable volume guard: ensure there is meaningful historical volume
volumeMax_vsa = ta.highest(volume, vsaVolumeLength)
hasReliableVolume = not na(volume) and volumeMax_vsa > 0
// small epsilon to avoid divide-by-zero when high==low
_range_eps = 1e-8
normClosePos = (close - low) / math.max(high - low, _range_eps)

// === 10 T√çN HI·ªÜU VSA QUAN TR·ªåNG NH·∫§T CHO BTC/CRYPTO ===
// T√≠n hi·ªáu Bearish (gi·∫£m)
sellingClimax = showSC and veryHighVolume_vsa and close < open and normClosePos < 0.3  // SC: ƒê·ªânh b√°n th√°o
noDemand = showND and lowVolume_vsa and close > open and normClosePos < 0.6 and close[1] < close[2]  // ND: Kh√¥ng c√≥ c·∫ßu
upthrust = showUT and highVolume_vsa and high > high[1] and close < close[1] and normClosePos < 0.5  // UT: ƒê·∫©y gi√° gi·∫£
weakness = showWK and highVolume_vsa and wideSpread_vsa and close < open and normClosePos < 0.5  // WK: Y·∫øu

// T√≠n hi·ªáu Bullish (tƒÉng)
buyingClimax = showBC and veryHighVolume_vsa and close > open and normClosePos > 0.7  // BC: ƒê·ªânh mua v√†o
noSupply = showNS and lowVolume_vsa and close < open and normClosePos > 0.4 and close[1] > close[2]  // NS: Kh√¥ng c√≥ cung
spring = showSP and lowVolume_vsa and low < low[1] and close > low and normClosePos > 0.5  // SP: L√≤ xo b·∫≠t l√™n
stoppingVolume = showSV and ultraHighVolume_vsa and narrowSpread_vsa and ((close > open and close[1] < open[1]) or (close < open and close[1] > open[1]))  // SV: Volume d·ª´ng xu h∆∞·ªõng
strength = showST and highVolume_vsa and wideSpread_vsa and close > open and normClosePos > 0.5  // ST: M·∫°nh
shakeout = showSO and highVolume_vsa and low < low[1] and close > close[1] and normClosePos > 0.6  // SO: R≈© b·ªè


// Gom t√≠n hi·ªáu VSA tr√™n 1 candle th√†nh 1 marker duy nh·∫•t

// Gom t√≠n hi·ªáu VSA tr√™n 1 candle th√†nh 1 marker duy nh·∫•t (d√πng label.new ƒë·ªÉ text ƒë·ªông)
var string[] vsaNames = array.new_string()
var string vsaText = ""
var label[] vsaLabels = array.new<label>()
// companion array to track label x positions for de-duplication
var int[] vsaLabelXs = array.new_int()
// compute simple CVD confirmation flags (uses cvdMA from above)
cvdConfirmBull = cvdSource > cvdMA
cvdConfirmBear = cvdSource < cvdMA
if showVSASignals
    vsaText := ""
    array.clear(vsaNames)
    // ƒê·∫øm s·ªë t√≠n hi·ªáu tƒÉng/gi·∫£m
    bullCount = 0
    bearCount = 0
    
    // === T√çN HI·ªÜU BEARISH (ch·ªâ th√™m n·∫øu kh√¥ng y√™u c·∫ßu x√°c nh·∫≠n CVD ho·∫∑c CVD x√°c nh·∫≠n) ===
    if sellingClimax and (not vsaRequireCvdConfirm or cvdConfirmBear)
        array.push(vsaNames, "SC")
        bearCount += 1
    if noDemand and (not vsaRequireCvdConfirm or cvdConfirmBear)
        array.push(vsaNames, "ND")
        bearCount += 1
    if upthrust and (not vsaRequireCvdConfirm or cvdConfirmBear)
        array.push(vsaNames, "UT")
        bearCount += 1
    if weakness and (not vsaRequireCvdConfirm or cvdConfirmBear)
        array.push(vsaNames, "WK")
        bearCount += 1
    
    // === T√çN HI·ªÜU BULLISH (ch·ªâ th√™m n·∫øu kh√¥ng y√™u c·∫ßu x√°c nh·∫≠n CVD ho·∫∑c CVD x√°c nh·∫≠n) ===
    if buyingClimax and (not vsaRequireCvdConfirm or cvdConfirmBull)
        array.push(vsaNames, "BC")
        bullCount += 1
    if noSupply and (not vsaRequireCvdConfirm or cvdConfirmBull)
        array.push(vsaNames, "NS")
        bullCount += 1
    if spring and (not vsaRequireCvdConfirm or cvdConfirmBull)
        array.push(vsaNames, "SP")
        bullCount += 1
    if stoppingVolume and (not vsaRequireCvdConfirm or cvdConfirmBull)
        array.push(vsaNames, "SV")
        bullCount += 1
    if strength and (not vsaRequireCvdConfirm or cvdConfirmBull)
        array.push(vsaNames, "ST")
        bullCount += 1
    if shakeout and (not vsaRequireCvdConfirm or cvdConfirmBull)
        array.push(vsaNames, "SO")
        bullCount += 1
    // T·∫°o text d·∫°ng A+B+C n·∫øu c√≥ t√≠n hi·ªáu
    if array.size(vsaNames) > 0
        for i = 0 to array.size(vsaNames) - 1
            vsaText := vsaText == "" ? array.get(vsaNames, i) : vsaText + "+" + array.get(vsaNames, i)
        // Ch·ªâ plot n·∫øu c√≥ √≠t nh·∫•t 1 t√≠n hi·ªáu v√† ·ªü bar confirmed
        if vsaText != "" and barstate.isconfirmed
            // Determine overall type by difference in counts
            diff = bullCount - bearCount
            vsaType = math.sign(diff)
            // Ch·ªçn m√†u: bull (xanh), bear (ƒë·ªè), neutral (xanh d∆∞∆°ng)
            vsaColor = vsaType == 1 ? color.green : vsaType == -1 ? color.red : color.blue
            // VSA labels tr√™n price chart: bull=d∆∞·ªõi low, bear=tr√™n high
            vsaY = vsaType == 1 ? low - (atr_for_labels * bullLabelOffset) : vsaType == -1 ? high + (atr_for_labels * bearLabelOffset) : low - (atr_for_labels * bullLabelOffset)
            vsaStyle = vsaType == 1 ? label.style_label_up : vsaType == -1 ? label.style_label_down : label.style_label_down
            // avoid duplicate labels at the same bar
            if array.size(vsaLabelXs) == 0
                lb = label.new(x=bar_index, y=vsaY, text=vsaText, style=vsaStyle, color=vsaColor, textcolor=color.white, size=size.tiny)
                // manage lifecycle: keep labels bounded
                array.unshift(vsaLabels, lb)
                array.unshift(vsaLabelXs, bar_index)
                if array.size(vsaLabels) > vsaLabelLimit
                    label.delete(array.get(vsaLabels, -1))
                    array.pop(vsaLabels)
                    array.pop(vsaLabelXs)
            else
                if not f_array_has_int(vsaLabelXs, bar_index)
                    lb = label.new(x=bar_index, y=vsaY, text=vsaText, style=vsaStyle, color=vsaColor, textcolor=color.white, size=size.tiny)
                    // manage lifecycle: keep labels bounded
                    array.unshift(vsaLabels, lb)
                    array.unshift(vsaLabelXs, bar_index)
                    if array.size(vsaLabels) > vsaLabelLimit
                        label.delete(array.get(vsaLabels, -1))
                        array.pop(vsaLabels)
                        array.pop(vsaLabelXs)

// === VSA LEGEND TABLE (10 T√çN HI·ªÜU QUAN TR·ªåNG NH·∫§T) ===
if showVSALegend and barstate.islast
    // √Ånh x·∫° legendPosition string sang position enum
    legend_pos = legendPosition == "bottom_right" ? position.bottom_right : legendPosition == "bottom_left" ? position.bottom_left : legendPosition == "top_right" ? position.top_right : position.top_left
    var table vsaLegend = table.new(position=legend_pos, columns=2, rows=10, bgcolor=color.new(color.gray, 90), border_width=1, frame_color=color.new(color.gray, 60))
    // T√≠n hi·ªáu Bearish (m√†u ƒë·ªè)
    table.cell(vsaLegend, 0, 0, "SC", text_size=size.tiny, text_color=color.red, bgcolor=color.new(color.red, 90))
    table.cell(vsaLegend, 1, 0, "Selling Climax - ƒê·ªânh b√°n th√°o", text_size=size.tiny)
    table.cell(vsaLegend, 0, 1, "ND", text_size=size.tiny, text_color=color.red, bgcolor=color.new(color.red, 90))
    table.cell(vsaLegend, 1, 1, "No Demand - Kh√¥ng c√≥ c·∫ßu", text_size=size.tiny)
    table.cell(vsaLegend, 0, 2, "UT", text_size=size.tiny, text_color=color.red, bgcolor=color.new(color.red, 90))
    table.cell(vsaLegend, 1, 2, "Upthrust - ƒê·∫©y gi√° gi·∫£", text_size=size.tiny)
    table.cell(vsaLegend, 0, 3, "WK", text_size=size.tiny, text_color=color.red, bgcolor=color.new(color.red, 90))
    table.cell(vsaLegend, 1, 3, "Weakness - Y·∫øu", text_size=size.tiny)
    // T√≠n hi·ªáu Bullish (m√†u xanh)
    table.cell(vsaLegend, 0, 4, "BC", text_size=size.tiny, text_color=color.green, bgcolor=color.new(color.green, 90))
    table.cell(vsaLegend, 1, 4, "Buying Climax - ƒê·ªânh mua v√†o", text_size=size.tiny)
    table.cell(vsaLegend, 0, 5, "NS", text_size=size.tiny, text_color=color.green, bgcolor=color.new(color.green, 90))
    table.cell(vsaLegend, 1, 5, "No Supply - Kh√¥ng c√≥ cung", text_size=size.tiny)
    table.cell(vsaLegend, 0, 6, "SP", text_size=size.tiny, text_color=color.green, bgcolor=color.new(color.green, 90))
    table.cell(vsaLegend, 1, 6, "Spring - L√≤ xo b·∫≠t l√™n", text_size=size.tiny)
    table.cell(vsaLegend, 0, 7, "SV", text_size=size.tiny, text_color=color.green, bgcolor=color.new(color.green, 90))
    table.cell(vsaLegend, 1, 7, "Stopping Volume - Volume d·ª´ng xu h∆∞·ªõng", text_size=size.tiny)
    table.cell(vsaLegend, 0, 8, "ST", text_size=size.tiny, text_color=color.green, bgcolor=color.new(color.green, 90))
    table.cell(vsaLegend, 1, 8, "Strength - M·∫°nh", text_size=size.tiny)
    table.cell(vsaLegend, 0, 9, "SO", text_size=size.tiny, text_color=color.blue, bgcolor=color.new(color.blue, 90))
    table.cell(vsaLegend, 1, 9, "Shakeout - R≈© b·ªè", text_size=size.tiny)

// classify regular vs hidden CVD+Volume divergence flags (now explicitly separated)
regCvdVolBull = cvdVolBullRegular
regCvdVolBear = cvdVolBearRegular
hiddenCvdVolBull = cvdVolBullHidden
hiddenCvdVolBear = cvdVolBearHidden

// === NHOM 7: VOLUME Z-SCORE ===
const string GRP_VOL_ZSCORE = "üìä Volume Z-Score"
showVolume = input.bool(true, "Hi·ªÉn th·ªã Volume Chart", group=GRP_VOL_ZSCORE)
lengthVolumeMA_z = input.int(20, title="ƒê·ªô d√†i MA Volume", minval=1, group=GRP_VOL_ZSCORE)
// Ng∆∞·ª°ng Z-score
ultraHighZ = input.float(2.5, "Z Ultra High", minval=1.0, maxval=5.0, step=0.1, group=GRP_VOL_ZSCORE)
veryHighZ = input.float(1.8, "Z Very High", minval=0.5, maxval=4.0, step=0.1, group=GRP_VOL_ZSCORE)
highZ = input.float(1.0, "Z High", minval=0.0, maxval=3.0, step=0.1, group=GRP_VOL_ZSCORE)
normalLowZ = input.float(-0.5, "Z Normal Low", minval=-2.0, maxval=1.0, step=0.1, group=GRP_VOL_ZSCORE)
lowZ = input.float(-1.5, "Z Low", minval=-3.0, maxval=0.0, step=0.1, group=GRP_VOL_ZSCORE)

// Create persistent horizontal lines (hline) at CVD and Volume baselines
plot(showCvdBaseline ? cvdZeroOffset : na, title="CVD Baseline", color=color.gray, style=plot.style_line, linewidth=1)
plot(showVolumeBaseline ? volumeZeroOffset : na, title="Volume Baseline", color=color.new(color.gray, 60), style=plot.style_line, linewidth=1)

// H√†m t√≠nh Z-score cho volume
f_zscore_vol(src, len) =>
    ma = ta.sma(src, len)
    sd = ta.stdev(src, len)
    sd != 0 ? (src - ma) / sd : 0

volZ = f_zscore_vol(volume, lengthVolumeMA_z)

// Ph√¢n lo·∫°i volume theo Z-score
isUltraHigh_z = volZ >= ultraHighZ
isVeryHigh_z = volZ >= veryHighZ and volZ < ultraHighZ
isHigh_z = volZ >= highZ and volZ < veryHighZ
isNormal_z = volZ >= normalLowZ and volZ < highZ
isLow_z = volZ >= lowZ and volZ < normalLowZ
isVeryLow_z = volZ < lowZ

// Ch·ªçn m√†u theo Z-score
volColorZ = isUltraHigh_z ? color.new(color.purple, volumeChartAlpha) : isVeryHigh_z  ? color.new(color.red, volumeChartAlpha) : isHigh_z      ? color.new(color.orange, volumeChartAlpha) : isNormal_z    ? color.new(color.green, volumeChartAlpha) : isLow_z       ? color.new(color.blue, volumeChartAlpha) : color.new(color.gray, volumeChartAlpha)

// V·∫Ω c·ªôt volume (visual only): draw bars anchored at baseline (volumeZeroOffset), apply Y scale
plotcandle(volumeZeroOffset, (volume * volumeYScale) + volumeZeroOffset, volumeZeroOffset, (volume * volumeYScale) + volumeZeroOffset, title="Volume (Z-Score)", color=volColorZ, bordercolor=volColorZ, wickcolor=volColorZ, display=showVolume ? display.all : display.none)

// === CVD+VOLUME DIVERGENCE tr√™n Volume chart (t∆∞∆°ng t·ª± CVD+Price tr√™n Price chart) ===
// V·∫Ω t·∫°i volume values c·ªßa CVD pivots (kh√¥ng ph·∫£i volume pivots), apply Y scale
cvdVolBullColor = cvdVolBull ? (bullCond or hiddenBullCond ? color.blue : color.new(color.blue, 60)) : color.new(color.white, 100)
cvdVolBearColor = cvdVolBear ? (bearCond or hiddenBearCond ? color.orange : color.new(color.orange, 60)) : color.new(color.white, 100)
plot(plFound ? ((volume[lookbackRight] * volumeYScale) + volumeZeroOffset) : na, offset=-lookbackRight, title="CVD+Vol Bull Lines", linewidth=2, color=cvdVolBullColor)
plot(phFound ? ((volume[lookbackRight] * volumeYScale) + volumeZeroOffset) : na, offset=-lookbackRight, title="CVD+Vol Bear Lines", linewidth=2, color=cvdVolBearColor)

// T√≠nh offset cho labels tr√™n volume chart (d√πng % c·ªßa scaled volume range)
vol_range = (ta.highest(volume, 20) - ta.lowest(volume, 20)) * volumeYScale
vol_label_offset = vol_range * 0.05  // 5% c·ªßa scaled volume range

// Labels VBull/VBear tr√™n Volume chart t·∫°i volume c·ªßa CVD pivots, apply Y scale
isRegularCvdVol = bullCond or hiddenBullCond or bearCond or hiddenBearCond
plotshape(cvdVolBull and isRegularCvdVol ? ((volume[lookbackRight] * volumeYScale) + volumeZeroOffset - vol_label_offset) : na, offset=-lookbackRight, title="VBull Label", text="VBull", style=shape.labelup, location=location.absolute, color=color.blue, textcolor=color.white, size=size.tiny)
plotshape(cvdVolBear and isRegularCvdVol ? ((volume[lookbackRight] * volumeYScale) + volumeZeroOffset + vol_label_offset) : na, offset=-lookbackRight, title="VBear Label", text="VBear", style=shape.labeldown, location=location.absolute, color=color.orange, textcolor=color.white, size=size.tiny)
plotshape(cvdVolBull and not isRegularCvdVol ? ((volume[lookbackRight] * volumeYScale) + volumeZeroOffset - vol_label_offset) : na, offset=-lookbackRight, title="H.VBull Label", text="H.VBull", style=shape.labelup, location=location.absolute, color=color.new(color.blue, 60), textcolor=color.white, size=size.tiny)
plotshape(cvdVolBear and not isRegularCvdVol ? ((volume[lookbackRight] * volumeYScale) + volumeZeroOffset + vol_label_offset) : na, offset=-lookbackRight, title="H.VBear Label", text="H.VBear", style=shape.labeldown, location=location.absolute, color=color.new(color.orange, 60), textcolor=color.white, size=size.tiny)

// === ADVANCED ALERT SYSTEM ===
// Compute VSA signal flags for confluence detection
hasVSABullish = buyingClimax or noSupply or spring or stoppingVolume or strength or shakeout
hasVSABearish = sellingClimax or noDemand or upthrust or weakness

// === 1. BASIC DIVERGENCE ALERTS ===
alertcondition(enableBasicDivAlerts and bullCond, 'C+P: Regular Bull', 'CVPZ: CVD+Price Regular Bullish Divergence üü¢')
alertcondition(enableBasicDivAlerts and bearCond, 'C+P: Regular Bear', 'CVPZ: CVD+Price Regular Bearish Divergence üî¥')
alertcondition(enableBasicDivAlerts and hiddenBullCond, 'C+P: Hidden Bull', 'CVPZ: CVD+Price Hidden Bullish Divergence üü¶')
alertcondition(enableBasicDivAlerts and hiddenBearCond, 'C+P: Hidden Bear', 'CVPZ: CVD+Price Hidden Bearish Divergence üü•')

alertcondition(enableBasicDivAlerts and cvdVolBullRegular and hasReliableVolume, 'C+V: Regular Bull', 'CVPZ: CVD+Volume Regular Bullish Divergence üîµ')
alertcondition(enableBasicDivAlerts and cvdVolBearRegular and hasReliableVolume, 'C+V: Regular Bear', 'CVPZ: CVD+Volume Regular Bearish Divergence üî¥')
alertcondition(enableBasicDivAlerts and cvdVolBullHidden and hasReliableVolume, 'C+V: Hidden Bull', 'CVPZ: CVD+Volume Hidden Bullish Divergence üü¶')
alertcondition(enableBasicDivAlerts and cvdVolBearHidden and hasReliableVolume, 'C+V: Hidden Bear', 'CVPZ: CVD+Volume Hidden Bearish Divergence üü•')

// === 2. CONFLUENT ALERTS (Double Confluence: C+P + C+V) ===
// Regular Confluent (c·∫£ 2 ƒë·ªÅu regular)
confluentBullRegular = (bullCond and cvdVolBullRegular and hasReliableVolume)
confluentBearRegular = (bearCond and cvdVolBearRegular and hasReliableVolume)
alertcondition(enableConfluentAlerts and confluentBullRegular, '‚≠ê CONFLUENT: Bull (C+P + C+V)', 'CVPZ: üéØ DOUBLE CONFLUENCE BULLISH üü¢üü¢\nCVD+Price AND CVD+Volume Regular Divergence!\nHigh Probability Setup!')
alertcondition(enableConfluentAlerts and confluentBearRegular, '‚≠ê CONFLUENT: Bear (C+P + C+V)', 'CVPZ: üéØ DOUBLE CONFLUENCE BEARISH üî¥üî¥\nCVD+Price AND CVD+Volume Regular Divergence!\nHigh Probability Setup!')

// Mixed Confluent (1 regular + 1 hidden)
confluentBullMixed = ((bullCond and cvdVolBullHidden) or (hiddenBullCond and cvdVolBullRegular)) and hasReliableVolume
confluentBearMixed = ((bearCond and cvdVolBearHidden) or (hiddenBearCond and cvdVolBearRegular)) and hasReliableVolume
alertcondition(enableConfluentAlerts and confluentBullMixed, '‚≠ê CONFLUENT: Bull Mixed', 'CVPZ: üéØ MIXED CONFLUENCE BULLISH üü¢üü¶\nCVD+Price + CVD+Volume Divergence (mixed)!')
alertcondition(enableConfluentAlerts and confluentBearMixed, '‚≠ê CONFLUENT: Bear Mixed', 'CVPZ: üéØ MIXED CONFLUENCE BEARISH üî¥üü•\nCVD+Price + CVD+Volume Divergence (mixed)!')

// === 3. BB BREAK ALERTS (Extreme Zones) ===
alertcondition(enableBBBreakAlerts and cvd_is_overbought, 'BB: Overbought', 'CVPZ: ‚ö†Ô∏è CVD Overbought (Above BB) - Potential Reversal Zone')
alertcondition(enableBBBreakAlerts and cvd_is_oversold, 'BB: Oversold', 'CVPZ: ‚ö†Ô∏è CVD Oversold (Below BB) - Potential Reversal Zone')

// === 4. VSA CONFLUENT ALERTS (Divergence + VSA) ===
vsaDivBull = (bullCond or cvdVolBullRegular) and hasVSABullish and hasReliableVolume
vsaDivBear = (bearCond or cvdVolBearRegular) and hasVSABearish and hasReliableVolume
alertcondition(enableVSAConfluentAlerts and vsaDivBull, '‚≠ê VSA+DIV: Bull', 'CVPZ: üí™ VSA CONFLUENCE BULLISH\nDivergence + VSA Bullish Signal\nStrong Setup!')
alertcondition(enableVSAConfluentAlerts and vsaDivBear, '‚≠ê VSA+DIV: Bear', 'CVPZ: üí™ VSA CONFLUENCE BEARISH\nDivergence + VSA Bearish Signal\nStrong Setup!')

// === 5. TRIPLE CONFLUENCE (Ultimate Setup: C+P + C+V + VSA) ===
tripleConfluenceBull = confluentBullRegular and hasVSABullish
tripleConfluenceBear = confluentBearRegular and hasVSABearish
alertcondition(enableTripleConfluence and tripleConfluenceBull, 'üåü TRIPLE CONFLUENCE: BULL', 'CVPZ: üöÄüöÄüöÄ ULTIMATE BULLISH SETUP üöÄüöÄüöÄ\n‚úÖ CVD+Price Regular Divergence\n‚úÖ CVD+Volume Regular Divergence\n‚úÖ VSA Bullish Signal\nCH·∫ÆC ƒÇN NH·∫§T!')
alertcondition(enableTripleConfluence and tripleConfluenceBear, 'üåü TRIPLE CONFLUENCE: BEAR', 'CVPZ: üí•üí•üí• ULTIMATE BEARISH SETUP üí•üí•üí•\n‚úÖ CVD+Price Regular Divergence\n‚úÖ CVD+Volume Regular Divergence\n‚úÖ VSA Bearish Signal\nCH·∫ÆC ƒÇN NH·∫§T!')

// === 6. EXTREME COMBO ALERTS (BB Break + Divergence) ===
bbDivBull = cvd_is_oversold and (bullCond or cvdVolBullRegular) and hasReliableVolume
bbDivBear = cvd_is_overbought and (bearCond or cvdVolBearRegular) and hasReliableVolume
alertcondition(enableBBBreakAlerts and bbDivBull, 'üî• EXTREME: Bull (BB + Div)', 'CVPZ: üî• EXTREME BULLISH SETUP\nCVD Oversold (BB) + Divergence\nReversal Zone!')
alertcondition(enableBBBreakAlerts and bbDivBear, 'üî• EXTREME: Bear (BB + Div)', 'CVPZ: üî• EXTREME BEARISH SETUP\nCVD Overbought (BB) + Divergence\nReversal Zone!')