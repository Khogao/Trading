// This Pine Script¬Æ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// ¬© lenguyenphi

//@version=6
// ============================================================================
// TITLE: CVD+ (Hybrid CVD Engine + Advanced Features)
// AUTHOR: Khogao + AI Assistant (100% our code, 2025)
// INSPIRATION: Greg's philosophy + HiveScale OP's institutional insights
// ============================================================================
// DESC: Advanced CVD indicator with hybrid engine (cumulative + velocity + 
// session-relative), Multi-TF alignment, VPIN integration, and professional
// divergence detection using DGT Z-Score + Luc_Trader methodologies.
// 
// EVOLUTION: CVPZero ‚Üí CVD+ (hybrid CVD system upgrade)
// 
// AUTHORSHIP NOTE:
// - Greg: Trading philosophy (patience, risk management, simplification)
// - HiveScale OP: Order flow concepts (Reddit AMA institutional perspective)
// - We built: 100% code, research, implementation, and testing
// ============================================================================

indicator("CVD+ Enhanced", "CVD+", overlay = true)
import TradingView/ta/8 as tav5

// === NHOM 1: CVD ENGINE ===
const string GRP_CVD = "‚öôÔ∏è CVD Engine"
anchorInput = input.timeframe("D", "Chu k·ª≥ reset CVD", group = GRP_CVD, tooltip = "Khung th·ªùi gian m√† CVD reset (t√≠nh l·∫°i). 'D' (ng√†y) ƒë∆∞·ª£c khuy·∫øn ngh·ªã cho intraday.")
useCustomTimeframeInput = input.bool(false, "D√πng khung th·ªùi gian t√πy ch·ªânh", group = GRP_CVD, tooltip = "Ghi ƒë√® l·ª±a ch·ªçn t·ª± ƒë·ªông khung th·ªùi gian th·∫•p h∆°n ƒë·ªÉ t√≠nh delta. D√πng th·∫≠n tr·ªçng.")
lowerTimeframeInput = input.timeframe("1", "Khung th·ªùi gian th·∫•p h∆°n", group = GRP_CVD)
maTypeInput = input.string("SMA", "Lo·∫°i MA", options=["SMA", "EMA", "WMA", "VWMA"], group = GRP_CVD)
maLengthInput = input.int(20, "ƒê·ªô d√†i MA", group = GRP_CVD)
bbMultInput = input.float(2.0, "BB StdDev", minval=0.001, maxval=50, group = GRP_CVD)
showBollingerBands = input.bool(true, "Hi·ªÉn th·ªã Bollinger Bands", group = GRP_CVD, tooltip="BB tr√™n CVD nh∆∞ m·ª©c qu√° mua/b√°n ƒë·ªông.")

// === NHOM 1B: üî¨ HYBRID CVD SYSTEM (RESEARCH ENHANCEMENT) ===
const string GRP_HYBRID_CVD = "üî¨ Hybrid CVD System"
enable_hybrid_cvd = input.bool(true, "Enable Hybrid CVD (3 Variants)", group = GRP_HYBRID_CVD, tooltip="S·ª≠ d·ª•ng 3 CVD variants: Cumulative (divergence), Velocity (momentum), Session (intraday context)")
show_cvd_velocity = input.bool(true, "Show CVD Velocity", group = GRP_HYBRID_CVD, tooltip="CVD velocity (t·ªëc ƒë·ªô thay ƒë·ªïi) - auto-normalized, kh√¥ng c√≥ drift")
velocity_lookback = input.int(20, "Velocity Lookback", minval=5, maxval=100, group = GRP_HYBRID_CVD)
show_cvd_acceleration = input.bool(false, "Show CVD Acceleration", group = GRP_HYBRID_CVD, tooltip="ƒê·∫°o h√†m b·∫≠c 2 c·ªßa CVD - ph√°t hi·ªán momentum shifts s·ªõm")
show_session_cvd = input.bool(true, "Show Session-Relative CVD", group = GRP_HYBRID_CVD, tooltip="CVD relative to session start - gi·ªØ intraday context")
cvd_velocity_color = input.color(color.new(color.purple, 0), "Velocity Color", group = GRP_HYBRID_CVD, inline="hcvd")
session_cvd_color = input.color(color.new(color.aqua, 0), "Session CVD Color", group = GRP_HYBRID_CVD, inline="hcvd")

// === NHOM 1C: üéØ MULTI-TF CVD ALIGNMENT (RESEARCH ENHANCEMENT) ===
const string GRP_MTF_CVD = "üéØ Multi-TF CVD Alignment"
enable_mtf_alignment = input.bool(true, "Enable Multi-TF Alignment", group = GRP_MTF_CVD, tooltip="Ki·ªÉm tra CVD alignment tr√™n 3 timeframes (5m, 15m, 1H)")
show_alignment_bar = input.bool(true, "Show Alignment Background", group = GRP_MTF_CVD, tooltip="T√¥ m√†u n·ªÅn khi c·∫£ 3 TF CVD ƒë·ªìng √Ω")
tf1_cvd = input.timeframe("5", "TF1 (Short)", group = GRP_MTF_CVD)
tf2_cvd = input.timeframe("15", "TF2 (Medium)", group = GRP_MTF_CVD)
tf3_cvd = input.timeframe("60", "TF3 (Long)", group = GRP_MTF_CVD)
alignment_bull_color = input.color(color.new(color.green, 90), "Aligned Bull BG", group = GRP_MTF_CVD)
alignment_bear_color = input.color(color.new(color.red, 90), "Aligned Bear BG", group = GRP_MTF_CVD)

// === NHOM 2: DIVERGENCE ENGINE ===
const string GRP_DIVERGENCE = "üìä Ph√¢n k·ª≥ (Divergence)"
// CVD+Price Divergence
showRegular = input.bool(true, "C+P: Ph√¢n k·ª≥ th∆∞·ªùng", group = GRP_DIVERGENCE)
showHidden = input.bool(true, "C+P: Ph√¢n k·ª≥ ·∫©n", group = GRP_DIVERGENCE)
// CVD+Volume Divergence
showCvdVolRegular = input.bool(true, "C+V: Ph√¢n k·ª≥ th∆∞·ªùng", group = GRP_DIVERGENCE)
showCvdVolHidden = input.bool(true, "C+V: Ph√¢n k·ª≥ ·∫©n", group = GRP_DIVERGENCE)
// Z-Score Normalization (DGT Method)
useZScorePivots = input.bool(true, "üéì Z-Score Normalized Pivots", group = GRP_DIVERGENCE, tooltip="Professional approach from DGT. Normalizes CVD for statistically significant pivots.")
zScoreLength = input.int(20, "Z-Score Length", group = GRP_DIVERGENCE)
// Pivot Settings
lookbackLeft = input.int(5, "Pivot: Lookback tr√°i", group = GRP_DIVERGENCE)
lookbackRight = input.int(5, "Pivot: Lookback ph·∫£i", group = GRP_DIVERGENCE)
rangeLower = input.int(5, "Pivot: Range min", group = GRP_DIVERGENCE)
rangeUpper = input.int(60, "Pivot: Range max", group = GRP_DIVERGENCE)

// === NHOM 2.5: VOLUME FILTER (Optional) ===
const string GRP_VOL_FILTER = "üìà Volume Filter (T√πy ch·ªçn)"
enableVolumeFilter = input.bool(false, "Enable Volume Confirmation", group = GRP_VOL_FILTER, tooltip="Filter divergences by volume behavior.")
volumeMA_Length = input.int(20, "Volume MA Length", group = GRP_VOL_FILTER)
volumeThreshold = input.float(1.2, "Volume Threshold", minval=0.5, maxval=3.0, step=0.1, group = GRP_VOL_FILTER)
enablePivotStrengthFilter = input.bool(false, "Enable Pivot Strength Filter", group = GRP_VOL_FILTER)
pivotStrengthThreshold = input.float(0.5, "Pivot Strength (ATR)", minval=0.1, maxval=2.0, step=0.1, group = GRP_VOL_FILTER)

// === NHOM 3: DISPLAY & TABLE ===
const string GRP_DISPLAY = "üé® Hi·ªÉn th·ªã"
plotStyle = input.string("Line with MA", "CVD: Ki·ªÉu v·∫Ω", options=["Line with MA", "Candles"], group = GRP_DISPLAY)
showCandleColors = input.bool(true, title="T√¥ m√†u n·∫øn khi v∆∞·ª£t BB", group = GRP_DISPLAY)
divChartDisplay = input.string("Split: C+P on Price / C+V on Volume", "V·ªã tr√≠ hi·ªÉn th·ªã Divergence", options=["All on Price Chart", "Split: C+P on Price / C+V on Volume", "All on CVD Chart"], group = GRP_DISPLAY, tooltip="Ch·ªçn n∆°i hi·ªÉn th·ªã ƒë∆∞·ªùng divergence:\n‚Ä¢ All on Price: T·∫•t c·∫£ C+P v√† C+V tr√™n Price chart\n‚Ä¢ Split: C+P tr√™n Price, C+V tr√™n Volume (m·∫∑c ƒë·ªãnh)\n‚Ä¢ All on CVD: T·∫•t c·∫£ C+P v√† C+V tr√™n CVD chart")
showCvdPriceDivLines = input.bool(true, "Hi·ªÉn th·ªã ƒë∆∞·ªùng C+P tr√™n CVD", group = GRP_DISPLAY, tooltip="Hi·ªÉn th·ªã ƒë∆∞·ªùng n·ªëi CVD+Price divergence tr√™n CVD chart")
showCvdVolDivLines = input.bool(true, "Hi·ªÉn th·ªã ƒë∆∞·ªùng C+V tr√™n CVD", group = GRP_DISPLAY, tooltip="Hi·ªÉn th·ªã ƒë∆∞·ªùng n·ªëi CVD+Volume divergence tr√™n CVD chart")
// Y Scale & Alpha
cvdYScale = input.float(1.0, "Y Scale: CVD", minval=0.1, maxval=100.0, step=0.1, group = GRP_DISPLAY)
volumeYScale = input.float(1.0, "Y Scale: Volume", minval=0.1, maxval=100.0, step=0.1, group = GRP_DISPLAY)
cvdChartAlpha = input.int(20, "Alpha: CVD", minval=0, maxval=100, group = GRP_DISPLAY)
volumeChartAlpha = input.int(20, "Alpha: Volume", minval=0, maxval=100, group = GRP_DISPLAY)
// Labels & Table
bullLabelOffset = input.float(0.5, "Label Offset: Bull", minval=0.0, maxval=5.0, step=0.1, group=GRP_DISPLAY)
bearLabelOffset = input.float(0.5, "Label Offset: Bear", minval=0.0, maxval=5.0, step=0.1, group=GRP_DISPLAY)
showTable = input.bool(true, 'Multi-TF Table', group = GRP_DISPLAY)
tablePosition = input.string("top_right", "Table Position", options=['top_left','top_right','bottom_left','bottom_right'], group = GRP_DISPLAY)

// === NHOM 4: ALERTS ===
const string GRP_ALERTS = "üîî C·∫£nh b√°o (Alerts)"
// Basic Divergence Alerts
enableBasicDivAlerts = input.bool(true, "Enable Basic Divergence Alerts", group = GRP_ALERTS)
// Confluent Alerts (High Probability)
enableConfluentAlerts = input.bool(true, "Enable Confluent Alerts (C+P + C+V)", group = GRP_ALERTS, tooltip="Alert khi c·∫£ CVD+Price V√Ä CVD+Volume divergence x·∫£y ra c√πng l√∫c - x√°c su·∫•t cao!")
// Extreme Alerts
enableBBBreakAlerts = input.bool(true, "Enable BB Break Alerts", group = GRP_ALERTS)
enableVSAConfluentAlerts = input.bool(true, "Enable VSA+Divergence Confluent", group = GRP_ALERTS, tooltip="Alert khi VSA signal tr√πng v·ªõi divergence - setup m·∫°nh!")
// Triple Confluence (Ultimate Setup)
enableTripleConfluence = input.bool(true, "Enable Triple Confluence (C+P + C+V + VSA)", group = GRP_ALERTS, tooltip="Alert khi c√≥ ƒë·ªìng th·ªùi: CVD+Price div, CVD+Volume div, V√Ä VSA signal - ch·∫Øc ƒÉn nh·∫•t!")

// === NHOM 5: COLOR SETTINGS ===
const string GRP_COLORS = "üé® M√†u s·∫Øc"
// Baseline Settings
cvdZeroOffset = input.float(0.0, "Baseline: CVD", step=1.0, group = GRP_COLORS)
volumeZeroOffset = input.float(0.0, "Baseline: Volume", step=1.0, group = GRP_COLORS)
showCvdBaseline = input.bool(true, "Show CVD Baseline", group = GRP_COLORS)
showVolumeBaseline = input.bool(true, "Show Vol Baseline", group = GRP_COLORS)
// CVD+Price Divergence Colors
bullColor = input.color(color.green, "C+P Bull Regular", group = GRP_COLORS, inline="cp_bull")
hiddenBullColor = input.color(color.new(color.green, 40), "C+P Bull Hidden", group = GRP_COLORS, inline="cp_bull")
bearColor = input.color(color.red, "C+P Bear Regular", group = GRP_COLORS, inline="cp_bear")
hiddenBearColor = input.color(color.new(color.red, 40), "C+P Bear Hidden", group = GRP_COLORS, inline="cp_bear")
// CVD+Volume Divergence Colors
cvdVolBullRegularColor = input.color(color.teal, "C+V Bull Regular", group = GRP_COLORS, inline="cv_bull")
cvdVolBullHiddenColor = input.color(color.new(color.teal, 60), "C+V Bull Hidden", group = GRP_COLORS, inline="cv_bull")
cvdVolBearRegularColor = input.color(color.maroon, "C+V Bear Regular", group = GRP_COLORS, inline="cv_bear")
cvdVolBearHiddenColor = input.color(color.new(color.maroon, 60), "C+V Bear Hidden", group = GRP_COLORS, inline="cv_bear")
// CVD Candle Colors
cvdBullCandleColor = input.color(color.teal, "M√†u n·∫øn CVD tƒÉng", group = GRP_COLORS)
cvdBearCandleColor = input.color(color.red, "M√†u n·∫øn CVD gi·∫£m", group = GRP_COLORS)

// === M√†u s·∫Øc cho styling (d·ª±a tr√™n inputs) ===
// CVD+Price colors
BULL_COLOR = bullColor
BEAR_COLOR = bearColor
HIDDEN_BULL_COLOR = hiddenBullColor
HIDDEN_BEAR_COLOR = hiddenBearColor
// CVD+Volume colors
CVDVOL_BULL_REGULAR_COLOR = cvdVolBullRegularColor
CVDVOL_BULL_HIDDEN_COLOR = cvdVolBullHiddenColor
CVDVOL_BEAR_REGULAR_COLOR = cvdVolBearRegularColor
CVDVOL_BEAR_HIDDEN_COLOR = cvdVolBearHiddenColor
// Background colors
const color BULL_BG_COLOR = color.new(color.green, 80)
const color BEAR_BG_COLOR = color.new(color.red, 80)

// === MA helper ===
ma(s, l, t) =>
    switch t
        "SMA" => ta.sma(s, l)
        "EMA" => ta.ema(s, l)
        "WMA" => ta.wma(s, l)
        => ta.vwma(s, l)  // default VWMA

// Lower TF resolver (works both in main scope and inside request.security)
f_lowerTf() =>
    if useCustomTimeframeInput
        lowerTimeframeInput
    else
        switch
            timeframe.isseconds => "1S"
            timeframe.isintraday => "1" 
            timeframe.isdaily => "5"
            => "60"

// Return CVD "close" from requestVolumeDelta
f_cvdClose() =>
    [_o, _h, _l, _c] = tav5.requestVolumeDelta(f_lowerTf(), anchorInput)
    _c 

// === CVD CALCULATION ENGINE ===
[openVolume, maxVolume, minVolume, lastVolume] = tav5.requestVolumeDelta(f_lowerTf(), anchorInput)
cvdSource = f_cvdClose()

var float cumVol = 0.0
cumVol += nz(volume)
if barstate.islast and cumVol == 0
    runtime.error("This symbol has no volume data, CVD cannot be calculated.")

// === üî¨ HYBRID CVD SYSTEM (RESEARCH ENHANCEMENT) ===
// Three CVD variants for different purposes:
// 1. Raw Cumulative CVD (no reset) - for divergence detection
// 2. CVD Velocity (rate of change) - for momentum signals, auto-normalized
// 3. Session-Relative CVD - for intraday context

// 1. Raw Cumulative CVD (never resets)
var float raw_cumulative_cvd = 0.0
float delta_volume = lastVolume - nz(lastVolume[1], lastVolume)
raw_cumulative_cvd += delta_volume

// 2. CVD Velocity (auto-normalized, no drift)
float cvd_velocity = enable_hybrid_cvd ? (raw_cumulative_cvd - raw_cumulative_cvd[velocity_lookback]) / velocity_lookback : na
float cvd_acceleration = enable_hybrid_cvd and show_cvd_acceleration ? ta.change(cvd_velocity) : na

// 3. Session-Relative CVD (preserve intraday context)
var float session_start_cvd = 0.0
bool new_session = ta.change(time(anchorInput)) != 0
if new_session
    session_start_cvd := raw_cumulative_cvd
float session_relative_cvd = enable_hybrid_cvd ? raw_cumulative_cvd - session_start_cvd : na

// === üéØ MULTI-TF CVD ALIGNMENT (RESEARCH ENHANCEMENT) ===
// Check CVD direction on 3 timeframes
f_cvd_direction(cvd_series, lookback) =>
    cvd_series > cvd_series[lookback] ? 1 : cvd_series < cvd_series[lookback] ? -1 : 0

// Get CVD direction from higher timeframes
[tf1_cvd_val] = request.security(syminfo.tickerid, tf1_cvd, [f_cvdClose()], lookahead=barmerge.lookahead_off)
[tf2_cvd_val] = request.security(syminfo.tickerid, tf2_cvd, [f_cvdClose()], lookahead=barmerge.lookahead_off)
[tf3_cvd_val] = request.security(syminfo.tickerid, tf3_cvd, [f_cvdClose()], lookahead=barmerge.lookahead_off)

int tf1_direction = enable_mtf_alignment ? f_cvd_direction(tf1_cvd_val, 1) : 0
int tf2_direction = enable_mtf_alignment ? f_cvd_direction(tf2_cvd_val, 1) : 0
int tf3_direction = enable_mtf_alignment ? f_cvd_direction(tf3_cvd_val, 1) : 0

// Alignment detection
bool cvd_aligned_bull = enable_mtf_alignment and tf1_direction == 1 and tf2_direction == 1 and tf3_direction == 1
bool cvd_aligned_bear = enable_mtf_alignment and tf1_direction == -1 and tf2_direction == -1 and tf3_direction == -1
bool cvd_aligned = cvd_aligned_bull or cvd_aligned_bear

// Background color for alignment
bgcolor(show_alignment_bar and cvd_aligned_bull ? alignment_bull_color : show_alignment_bar and cvd_aligned_bear ? alignment_bear_color : na, title="MTF Alignment")

// === Z-SCORE NORMALIZATION (DGT Method) ===
cvd_zscore_ma = ta.sma(cvdSource, zScoreLength)
cvd_zscore_stdev = ta.stdev(cvdSource, zScoreLength)
cvd_zscore = cvd_zscore_stdev > 0 ? (cvdSource - cvd_zscore_ma) / cvd_zscore_stdev : 0
pivotSource = useZScorePivots ? cvd_zscore : cvdSource

// === VOLUME FILTER CALCULATIONS ===
volumeMA = ta.sma(volume, volumeMA_Length)
atr_for_pivot_strength = ta.atr(14)
volume_at_current_pivot = volume[lookbackRight]
isVolumeExhaustion = volume_at_current_pivot < (volumeMA / volumeThreshold)
isVolumeTrap = volume_at_current_pivot > (volumeMA * volumeThreshold)
isVolumeHealthy = volume_at_current_pivot < (volumeMA / volumeThreshold)

// === DIVERGENCE ENGINE ===
plVal = ta.pivotlow(pivotSource, lookbackLeft, lookbackRight)
phVal = ta.pivothigh(pivotSource, lookbackLeft, lookbackRight)
plFound = not na(plVal)
phFound = not na(phVal)
plSince = ta.barssince(plFound)
phSince = ta.barssince(phFound)
inRangePL_now = plSince[1] >= rangeLower and plSince[1] <= rangeUpper
inRangePH_now = phSince[1] >= rangeLower and phSince[1] <= rangeUpper

priceLL = low[lookbackRight] < ta.valuewhen(plFound, low[lookbackRight], 1)
cvdHL   = plVal > ta.valuewhen(plFound, plVal, 1) and inRangePL_now
volumeFilter_RegularBull = not enableVolumeFilter or isVolumeExhaustion
prev_plVal_for_strength = ta.valuewhen(plFound, plVal, 1)
pivotStrength_Bull = math.abs(plVal - prev_plVal_for_strength) / atr_for_pivot_strength
pivotStrengthFilter_Bull = not enablePivotStrengthFilter or (pivotStrength_Bull > pivotStrengthThreshold)
bullCond = showRegular and priceLL and cvdHL and plFound and volumeFilter_RegularBull and pivotStrengthFilter_Bull

priceHH = high[lookbackRight] > ta.valuewhen(phFound, high[lookbackRight], 1)
cvdLH   = phVal < ta.valuewhen(phFound, phVal, 1) and inRangePH_now
volumeFilter_RegularBear = not enableVolumeFilter or isVolumeExhaustion
prev_phVal_for_strength = ta.valuewhen(phFound, phVal, 1)
pivotStrength_Bear = math.abs(phVal - prev_phVal_for_strength) / atr_for_pivot_strength
pivotStrengthFilter_Bear = not enablePivotStrengthFilter or (pivotStrength_Bear > pivotStrengthThreshold)
bearCond = showRegular and priceHH and cvdLH and phFound and volumeFilter_RegularBear and pivotStrengthFilter_Bear

priceHL = low[lookbackRight] > ta.valuewhen(plFound, low[lookbackRight], 1)
cvdLL   = plVal < ta.valuewhen(plFound, plVal, 1) and inRangePL_now
volumeFilter_HiddenBull = not enableVolumeFilter or isVolumeHealthy
pivotStrengthFilter_HiddenBull = not enablePivotStrengthFilter or (pivotStrength_Bull > pivotStrengthThreshold)
hiddenBullCond = showHidden and priceHL and cvdLL and plFound and volumeFilter_HiddenBull and pivotStrengthFilter_HiddenBull

priceLH = high[lookbackRight] < ta.valuewhen(phFound, high[lookbackRight], 1)
cvdHH   = phVal > ta.valuewhen(phFound, phVal, 1) and inRangePH_now
volumeFilter_HiddenBear = not enableVolumeFilter or isVolumeTrap
pivotStrengthFilter_HiddenBear = not enablePivotStrengthFilter or (pivotStrength_Bear > pivotStrengthThreshold)
hiddenBearCond = showHidden and priceLH and cvdHH and phFound and volumeFilter_HiddenBear and pivotStrengthFilter_HiddenBear

// === CVD + VOLUME DIVERGENCE ENGINE ===
// So s√°nh CVD pivots v·ªõi volume T·∫†I c√°c CVD pivot bars (kh√¥ng c·∫ßn volume pivots)
prev_plVal = ta.valuewhen(plFound, plVal, 1)
prev_phVal = ta.valuewhen(phFound, phVal, 1)
// Volume t·∫°i CVD pivot bar hi·ªán t·∫°i vs tr∆∞·ªõc ƒë√≥
prev_vol_at_cvd_low = ta.valuewhen(plFound, volume[lookbackRight], 1)
// Pre-calculate values for line drawing (must be outside if blocks)
prev_price_low = ta.valuewhen(plFound, low[lookbackRight], 1)
prev_price_high = ta.valuewhen(phFound, high[lookbackRight], 1)
prev_vol_at_cvd_high = ta.valuewhen(phFound, volume[lookbackRight], 1)
// Store bar_index of previous pivots for line.new() x-coordinates
prev_plBar = ta.valuewhen(plFound, bar_index - lookbackRight, 1)
prev_phBar = ta.valuewhen(phFound, bar_index - lookbackRight, 1)

// Regular CVD+Volume Divergence
// Bull: CVD Higher Low + Volume LOWER = Exhaustion c·ªßa sellers (y·∫øu d·∫ßn)
cvdVolBullRegular = showCvdVolRegular and plFound and inRangePL_now and plVal > prev_plVal and volume[lookbackRight] < prev_vol_at_cvd_low and pivotStrengthFilter_Bull
// Bear: CVD Lower High + Volume LOWER = Exhaustion c·ªßa buyers (y·∫øu d·∫ßn)
cvdVolBearRegular = showCvdVolRegular and phFound and inRangePH_now and phVal < prev_phVal and volume[lookbackRight] < prev_vol_at_cvd_high and pivotStrengthFilter_Bear

// Hidden CVD+Volume Divergence
// Bull: CVD Lower Low + Volume LOWER = Continuation (√≠t ng∆∞·ªùi b√°n theo)
cvdVolBullHidden = showCvdVolHidden and plFound and inRangePL_now and plVal < prev_plVal and volume[lookbackRight] < prev_vol_at_cvd_low and pivotStrengthFilter_HiddenBull
// Bear: CVD Higher High + Volume HIGHER = Continuation (nhi·ªÅu ng∆∞·ªùi mua theo)
cvdVolBearHidden = showCvdVolHidden and phFound and inRangePH_now and phVal > prev_phVal and volume[lookbackRight] > prev_vol_at_cvd_high and pivotStrengthFilter_HiddenBear

// Combined flags for backward compatibility
cvdVolBull = cvdVolBullRegular or cvdVolBullHidden
cvdVolBear = cvdVolBearRegular or cvdVolBearHidden

// CVD+Volume divergence lines s·∫Ω ƒë∆∞·ª£c v·∫Ω b·∫±ng plot() tr√™n Volume chart (xem ph·∫ßn Volume Z-Score)

// CVD+Volume labels s·∫Ω ƒë∆∞·ª£c v·∫Ω b·∫±ng plotshape() tr√™n Volume chart (xem ph·∫ßn Volume Z-Score)



// === PLOTTING ===
isLinePlot   = plotStyle == "Line with MA"
isCandlePlot = plotStyle == "Candles"
cvdMA = ma(cvdSource, maLengthInput, maTypeInput)
cvdLineColor = cvdSource > cvdSource[1] ? color.blue : color.orange
// plotted (visual) series are offset by cvdZeroOffset so you can move the visual zero line
// apply alpha to CVD visuals AND cvdYScale to stretch Y axis
pCVD = plot((cvdSource * cvdYScale) + cvdZeroOffset, "CVD", color=color.new(cvdLineColor, cvdChartAlpha), linewidth=2, display=isLinePlot ? display.all : display.none)
pMA  = plot((cvdMA * cvdYScale) + cvdZeroOffset, "CVD MA", color=color.new(color.gray, cvdChartAlpha), linewidth=1, display=isLinePlot ? display.all : display.none)
fill(pCVD, pMA, color=isLinePlot ? (cvdSource > cvdMA ? color.new(color.blue, cvdChartAlpha) : color.new(color.orange, cvdChartAlpha)) : na)
// CVD candle color (alpha-aware, uses user-selected colors)
cCol = lastVolume >= openVolume ? color.new(cvdBullCandleColor, cvdChartAlpha) : color.new(cvdBearCandleColor, cvdChartAlpha)
// shift CVD candle visuals to be anchored at cvdZeroOffset (baseline), apply Y scale
plotcandle((openVolume * cvdYScale) + cvdZeroOffset, (maxVolume * cvdYScale) + cvdZeroOffset, (minVolume * cvdYScale) + cvdZeroOffset, (lastVolume * cvdYScale) + cvdZeroOffset, "CVD Candles", color=cCol, bordercolor=cCol, wickcolor=cCol, display=isCandlePlot ? display.all : display.none)
cvdMA_bb = ta.sma(cvdSource, maLengthInput)
bbUpper = cvdMA_bb + ta.stdev(cvdSource, maLengthInput) * bbMultInput
bbLower = cvdMA_bb - ta.stdev(cvdSource, maLengthInput) * bbMultInput
plot((bbUpper * cvdYScale) + cvdZeroOffset, "BB Tr√™n", color=color.new(color.gray, cvdChartAlpha), style=plot.style_line, display=showBollingerBands ? display.all : display.none)
plot((bbLower * cvdYScale) + cvdZeroOffset, "BB D∆∞·ªõi", color=color.new(color.gray, cvdChartAlpha), style=plot.style_line, display=showBollingerBands ? display.all : display.none)

// === üî¨ HYBRID CVD PLOTS (RESEARCH ENHANCEMENT) ===
// Plot CVD Velocity (auto-normalized, no drift)
plot(show_cvd_velocity and not na(cvd_velocity) ? (cvd_velocity * cvdYScale * 0.01) + cvdZeroOffset : na, "CVD Velocity", color=color.new(cvd_velocity_color, cvdChartAlpha), linewidth=2, style=plot.style_line)

// Plot CVD Acceleration (second derivative)
plot(show_cvd_acceleration and not na(cvd_acceleration) ? (cvd_acceleration * cvdYScale * 0.001) + cvdZeroOffset : na, "CVD Acceleration", color=color.new(color.fuchsia, cvdChartAlpha), linewidth=1, style=plot.style_histogram)

// Plot Session-Relative CVD (preserve intraday context)
plot(show_session_cvd and not na(session_relative_cvd) ? (session_relative_cvd * cvdYScale * 0.5) + cvdZeroOffset : na, "Session CVD", color=color.new(session_cvd_color, cvdChartAlpha), linewidth=2, style=plot.style_stepline)

// CVD Baseline for all hybrid variants
plot(showCvdBaseline ? cvdZeroOffset : na, title="CVD Baseline", color=color.new(color.gray, 60), style=plot.style_line, linewidth=1)

// === DIVERGENCE PLOTTING (Better RSI style - pivot dots + line.new() for connections) ===
// Array l∆∞u id label divergence ƒë·ªÉ x√≥a label c≈© khi v∆∞·ª£t qu√° 100
var label[] divLabels = array.new<label>()
divLabelLimit = 100
// companion array to track label x positions and avoid duplicates at same pivot
var int[] divLabelXs = array.new_int()
// separate arrays to manage CVD+Volume labels on the Volume pane (they are not price divergences)
var label[] volDivLabels = array.new<label>()
var int[] volDivLabelXs = array.new_int()
// Line arrays for divergence connections (line.new does NOT count toward 64-plot limit!)
var line[] divLines = array.new<line>()
var line[] cvdDivLines = array.new<line>()
var line[] volDivLines = array.new<line>()
maxDivLines = 500

// === H√ÄM HELPER: T·∫†O LABEL PH√ÇN K·ª≤ (gi·∫£m code l·∫∑p) ===
f_createDivLabel(int x, float y, string labelText, bool isBearish, color bgColor, label[] labelArray, int[] labelXArray, int maxLabels) =>
    labelStyle = isBearish ? label.style_label_down : label.style_label_up
    newLabel = label.new(x=x, y=y, text=labelText, style=labelStyle, color=bgColor, textcolor=color.white, size=size.tiny)
    array.unshift(labelArray, newLabel)
    array.unshift(labelXArray, x)
    if array.size(labelArray) > maxLabels
        label.delete(array.get(labelArray, -1))
        array.pop(labelArray)
        array.pop(labelXArray)
    newLabel

// === HELPER: Check if integer array contains value (d√πng cho VSA/div labels) ===
f_array_has_int(_arr, _val) =>
    _n = array.size(_arr)
    if _n == 0
        false
    else
        found = false
        for _i = 0 to _n - 1
            if array.get(_arr, _i) == _val
                found := true
        found

// === DIVERGENCE LINES (CVD+Price) tr√™n price chart ===
// T√≠nh ATR cho offset labels
atr_for_labels = ta.atr(14)

// V·∫Ω ƒë∆∞·ªùng n·ªëi divergence tr√™n price chart b·∫±ng line.new() (kh√¥ng t·ªën plot slots!)
bullDivColor = bullCond ? BULL_COLOR : hiddenBullCond ? HIDDEN_BULL_COLOR : color.new(color.white, 100)
bearDivColor = bearCond ? BEAR_COLOR : hiddenBearCond ? HIDDEN_BEAR_COLOR : color.new(color.white, 100)

// Draw bull divergence lines on price chart using line.new
if plFound and (bullCond or hiddenBullCond) and not na(prev_plBar)
    newLine = line.new(x1=int(prev_plBar), y1=prev_price_low, x2=bar_index - lookbackRight, y2=low[lookbackRight], color=bullDivColor, width=2)
    array.unshift(divLines, newLine)
    if array.size(divLines) > maxDivLines
        line.delete(array.pop(divLines))

// Draw bear divergence lines on price chart using line.new
if phFound and (bearCond or hiddenBearCond) and not na(prev_phBar)
    newLine = line.new(x1=int(prev_phBar), y1=prev_price_high, x2=bar_index - lookbackRight, y2=high[lookbackRight], color=bearDivColor, width=2)
    array.unshift(divLines, newLine)
    if array.size(divLines) > maxDivLines
        line.delete(array.pop(divLines))

// === C+V DIVERGENCE LINES ON PRICE CHART (Option 1: All on Price) ===
// V·∫Ω ƒë∆∞·ªùng C+V tr√™n Price chart s·ª≠ d·ª•ng gi√° tr·ªã price t·∫°i CVD pivot bars
cvdVolBullPriceColor = cvdVolBull ? (cvdVolBullRegular ? CVDVOL_BULL_REGULAR_COLOR : CVDVOL_BULL_HIDDEN_COLOR) : color.new(color.white, 100)
cvdVolBearPriceColor = cvdVolBear ? (cvdVolBearRegular ? CVDVOL_BEAR_REGULAR_COLOR : CVDVOL_BEAR_HIDDEN_COLOR) : color.new(color.white, 100)

if divChartDisplay == "All on Price Chart" and plFound and cvdVolBull and not na(prev_plBar)
    newLine = line.new(x1=int(prev_plBar), y1=prev_price_low, x2=bar_index - lookbackRight, y2=low[lookbackRight], color=cvdVolBullPriceColor, width=2, style=line.style_dashed)
    array.unshift(divLines, newLine)
    if array.size(divLines) > maxDivLines
        line.delete(array.pop(divLines))

if divChartDisplay == "All on Price Chart" and phFound and cvdVolBear and not na(prev_phBar)
    newLine = line.new(x1=int(prev_phBar), y1=prev_price_high, x2=bar_index - lookbackRight, y2=high[lookbackRight], color=cvdVolBearPriceColor, width=2, style=line.style_dashed)
    array.unshift(divLines, newLine)
    if array.size(divLines) > maxDivLines
        line.delete(array.pop(divLines))

// === CVD DIVERGENCE LINES (CVD+Price on CVD chart) ===
// V·∫Ω ƒë∆∞·ªùng n·ªëi CVD+Price divergence tr√™n CVD chart b·∫±ng line.new (scaled)
if showCvdPriceDivLines and plFound and (bullCond or hiddenBullCond) and not na(prev_plBar)
    y1_scaled = (prev_plVal * cvdYScale) + cvdZeroOffset
    y2_scaled = (plVal * cvdYScale) + cvdZeroOffset
    newLine = line.new(x1=int(prev_plBar), y1=y1_scaled, x2=bar_index - lookbackRight, y2=y2_scaled, color=bullDivColor, width=2)
    array.unshift(cvdDivLines, newLine)
    if array.size(cvdDivLines) > maxDivLines
        line.delete(array.pop(cvdDivLines))

if showCvdPriceDivLines and phFound and (bearCond or hiddenBearCond) and not na(prev_phBar)
    y1_scaled = (prev_phVal * cvdYScale) + cvdZeroOffset
    y2_scaled = (phVal * cvdYScale) + cvdZeroOffset
    newLine = line.new(x1=int(prev_phBar), y1=y1_scaled, x2=bar_index - lookbackRight, y2=y2_scaled, color=bearDivColor, width=2)
    array.unshift(cvdDivLines, newLine)
    if array.size(cvdDivLines) > maxDivLines
        line.delete(array.pop(cvdDivLines))

// === CVD DIVERGENCE LINES (CVD+Volume on CVD chart) ===
// V·∫Ω ƒë∆∞·ªùng n·ªëi CVD+Volume divergence tr√™n CVD chart khi c√≥ C+V divergence b·∫±ng line.new
// Hi·ªÉn th·ªã khi: "All on CVD Chart" HO·∫∂C "All on Price Chart" (v·∫´n v·∫Ω tr√™n CVD chart n·∫øu user enable showCvdVolDivLines)
cvdVolBullLineColor = cvdVolBull ? (cvdVolBullRegular ? CVDVOL_BULL_REGULAR_COLOR : CVDVOL_BULL_HIDDEN_COLOR) : color.new(color.white, 100)
cvdVolBearLineColor = cvdVolBear ? (cvdVolBearRegular ? CVDVOL_BEAR_REGULAR_COLOR : CVDVOL_BEAR_HIDDEN_COLOR) : color.new(color.white, 100)

if showCvdVolDivLines and (divChartDisplay == "All on CVD Chart" or divChartDisplay == "All on Price Chart") and plFound and cvdVolBull and not na(prev_plBar)
    y1_scaled = (prev_plVal * cvdYScale) + cvdZeroOffset
    y2_scaled = (plVal * cvdYScale) + cvdZeroOffset
    newLine = line.new(x1=int(prev_plBar), y1=y1_scaled, x2=bar_index - lookbackRight, y2=y2_scaled, color=cvdVolBullLineColor, width=1, style=line.style_dotted)
    array.unshift(cvdDivLines, newLine)
    if array.size(cvdDivLines) > maxDivLines
        line.delete(array.pop(cvdDivLines))

if showCvdVolDivLines and (divChartDisplay == "All on CVD Chart" or divChartDisplay == "All on Price Chart") and phFound and cvdVolBear and not na(prev_phBar)
    y1_scaled = (prev_phVal * cvdYScale) + cvdZeroOffset
    y2_scaled = (phVal * cvdYScale) + cvdZeroOffset
    newLine = line.new(x1=int(prev_phBar), y1=y1_scaled, x2=bar_index - lookbackRight, y2=y2_scaled, color=cvdVolBearLineColor, width=1, style=line.style_dotted)
    array.unshift(cvdDivLines, newLine)
    if array.size(cvdDivLines) > maxDivLines
        line.delete(array.pop(cvdDivLines))

// === PRE-CALCULATE CONFLUENCE LEVELS FOR MARKERS ===
// Level 2-4: ‚ö†Ô∏è Warning (65-70% win rate, needs caution)
// Level 5+: ‚≠ê Star (75%+ win rate, high conviction)
// Note: VSA-based confluence will be calculated later after VSA signals are defined

// Level 2: Double Confluence (C+P + C+V)
isDoubleConfluenceBull = (bullCond and cvdVolBullRegular)
isDoubleConfluenceBear = (bearCond and cvdVolBearRegular)

// Level 6: BB + Divergence Extremes - Inline calculation using bbLower/bbUpper directly
isBBDivBull = (cvdSource < bbLower) and (bullCond or cvdVolBullRegular)
isBBDivBear = (cvdSource > bbUpper) and (bearCond or cvdVolBearRegular)

// Aggregate markers for labels
hasLevel2to4_Bull_ForLabel = isDoubleConfluenceBull  // Level 4 (VSA+Div) will be added later after VSA defined
hasLevel2to4_Bear_ForLabel = isDoubleConfluenceBear
hasLevel5Plus_Bull_ForLabel = isBBDivBull  // Level 5 (Triple) and 7 (VSA‚ÜíDiv) added later via plotshape
hasLevel5Plus_Bear_ForLabel = isBBDivBear

// Use label.new for CVD+Price divergence labels to reduce plotcount (labels aren't counted as plots)
// Create labels at the pivot bar position (bar_index - lookbackRight) with lifecycle managed by f_createDivLabel
// Add ‚≠ê for Level 5+ (75%+ win rate) or ‚ö†Ô∏è for Level 2-4 (65-70% win rate)
priceLabelX = bar_index - lookbackRight
if bullCond
    if not f_array_has_int(divLabelXs, priceLabelX)
        labelText = hasLevel5Plus_Bull_ForLabel ? "‚≠êBull" : hasLevel2to4_Bull_ForLabel ? "‚ö†Ô∏èBull" : "Bull"
        f_createDivLabel(priceLabelX, low[lookbackRight] - (atr_for_labels * bullLabelOffset), labelText, false, BULL_COLOR, divLabels, divLabelXs, divLabelLimit)
if bearCond
    if not f_array_has_int(divLabelXs, priceLabelX)
        labelText = hasLevel5Plus_Bear_ForLabel ? "‚≠êBear" : hasLevel2to4_Bear_ForLabel ? "‚ö†Ô∏èBear" : "Bear"
        f_createDivLabel(priceLabelX, high[lookbackRight] + (atr_for_labels * bearLabelOffset), labelText, true, BEAR_COLOR, divLabels, divLabelXs, divLabelLimit)
if hiddenBullCond
    if not f_array_has_int(divLabelXs, priceLabelX)
        labelText = hasLevel5Plus_Bull_ForLabel ? "‚≠êH.Bull" : hasLevel2to4_Bull_ForLabel ? "‚ö†Ô∏èH.Bull" : "H.Bull"
        f_createDivLabel(priceLabelX, low[lookbackRight] - (atr_for_labels * bullLabelOffset), labelText, false, HIDDEN_BULL_COLOR, divLabels, divLabelXs, divLabelLimit)
if hiddenBearCond
    if not f_array_has_int(divLabelXs, priceLabelX)
        labelText = hasLevel5Plus_Bear_ForLabel ? "‚≠êH.Bear" : hasLevel2to4_Bear_ForLabel ? "‚ö†Ô∏èH.Bear" : "H.Bear"
        f_createDivLabel(priceLabelX, high[lookbackRight] + (atr_for_labels * bearLabelOffset), labelText, true, HIDDEN_BEAR_COLOR, divLabels, divLabelXs, divLabelLimit)
bgcolor(bullCond or hiddenBullCond ? BULL_BG_COLOR : na, title="Bullish Divergence BG Alert")
bgcolor(bearCond or hiddenBearCond ? BEAR_BG_COLOR : na, title="Bearish Divergence BG Alert")
cvd_is_overbought = cvdSource > bbUpper
cvd_is_oversold = cvdSource < bbLower
barcolor(showCandleColors and cvd_is_overbought ? color.new(color.red, 75) : na, title="CVD Overbought")
barcolor(showCandleColors and cvd_is_oversold ? color.new(color.green, 75) : na, title="CVD Oversold")

// === MULTI-TF CVD TABLE (5m, 15m, 1h, 4h) ===
cvd_5m  = request.security(syminfo.tickerid, "5",  f_cvdClose())
ma_5m   = request.security(syminfo.tickerid, "5",  ta.sma(f_cvdClose(), maLengthInput))
cvd_15m = request.security(syminfo.tickerid, "15", f_cvdClose())
ma_15m  = request.security(syminfo.tickerid, "15", ta.sma(f_cvdClose(), maLengthInput))
cvd_1h  = request.security(syminfo.tickerid, "60", f_cvdClose())
ma_1h   = request.security(syminfo.tickerid, "60", ta.sma(f_cvdClose(), maLengthInput))
cvd_4h  = request.security(syminfo.tickerid, "240", f_cvdClose())
ma_4h   = request.security(syminfo.tickerid, "240", ta.sma(f_cvdClose(), maLengthInput))

cell_col_5m  = cvd_5m  > ma_5m  ? color.new(color.green, 70) : color.new(color.red, 70)
cell_col_15m = cvd_15m > ma_15m ? color.new(color.green, 70) : color.new(color.red, 70)
cell_col_1h  = cvd_1h  > ma_1h  ? color.new(color.green, 70) : color.new(color.red, 70)
cell_col_4h  = cvd_4h  > ma_4h  ? color.new(color.green, 70) : color.new(color.red, 70)

if showTable and barstate.islast
    table_pos = tablePosition == "top_right" ? position.top_right : tablePosition == "top_left" ? position.top_left : tablePosition == "bottom_left" ? position.bottom_left : position.bottom_right
    var table cvdTable = table.new(position=table_pos, columns=2, rows=5, bgcolor=color.new(color.gray, 80), border_width=2, frame_color=color.new(color.gray, 50))
    table.cell(cvdTable, 0, 0, "TF", text_size=size.small, bgcolor=color.new(color.gray, 60), text_color=color.white)
    table.cell(cvdTable, 1, 0, "CVD", text_size=size.small, bgcolor=color.new(color.gray, 60), text_color=color.white)
    table.cell(cvdTable, 0, 1, "5m", text_size=size.small)
    table.cell(cvdTable, 1, 1, str.tostring(cvd_5m, format.mintick), bgcolor=cell_col_5m, text_color=color.white, text_size=size.small)
    table.cell(cvdTable, 0, 2, "15m", text_size=size.small)
    table.cell(cvdTable, 1, 2, str.tostring(cvd_15m, format.mintick), bgcolor=cell_col_15m, text_color=color.white, text_size=size.small)
    table.cell(cvdTable, 0, 3, "1H", text_size=size.small)
    table.cell(cvdTable, 1, 3, str.tostring(cvd_1h, format.mintick), bgcolor=cell_col_1h, text_color=color.white, text_size=size.small)
    table.cell(cvdTable, 0, 4, "4H", text_size=size.small)
    table.cell(cvdTable, 1, 4, str.tostring(cvd_4h, format.mintick), bgcolor=cell_col_4h, text_color=color.white, text_size=size.small)

// alerts are declared later after VSA logic to ensure volume guards are available



// === NHOM 6: VSA SIGNALS (Top 10 cho Crypto) ===
const string GRP_VSA = "üí° VSA Signals"
showVSASignals = input.bool(true, "Hi·ªÉn th·ªã t√≠n hi·ªáu VSA", group=GRP_VSA, tooltip="10 t√≠n hi·ªáu VSA quan tr·ªçng nh·∫•t cho BTC/Crypto trading")
showSC = input.bool(true, "Selling Climax (SC) - ƒê·ªânh b√°n th√°o", group=GRP_VSA)
showBC = input.bool(true, "Buying Climax (BC) - ƒê·ªânh mua v√†o", group=GRP_VSA)
showND = input.bool(true, "No Demand (ND) - Kh√¥ng c√≥ c·∫ßu", group=GRP_VSA)
showNS = input.bool(true, "No Supply (NS) - Kh√¥ng c√≥ cung", group=GRP_VSA)
showUT = input.bool(true, "Upthrust (UT) - ƒê·∫©y gi√° gi·∫£", group=GRP_VSA)
showSP = input.bool(true, "Spring (SP) - L√≤ xo b·∫≠t l√™n", group=GRP_VSA)
showSV = input.bool(true, "Stopping Volume (SV) - Volume d·ª´ng xu h∆∞·ªõng", group=GRP_VSA)
showWK = input.bool(true, "Weakness (WK) - Y·∫øu", group=GRP_VSA)
showST = input.bool(true, "Strength (ST) - M·∫°nh", group=GRP_VSA)
showSO = input.bool(true, "Shakeout (SO) - R≈© b·ªè", group=GRP_VSA)
showVSALegend = input.bool(true, "Hi·ªÉn th·ªã ch√∫ gi·∫£i VSA (legend)", group=GRP_VSA)
legendPosition = input.string("bottom_right", "V·ªã tr√≠ legend", options=["top_left","top_right","bottom_left","bottom_right"], group=GRP_VSA)
vsaVolumeLength = input.int(20, "ƒê·ªô d√†i MA Volume cho VSA", minval=5, maxval=100, group=GRP_VSA)
vsaSensitivity = input.float(1.5, "ƒê·ªô nh·∫°y VSA", minval=1.0, maxval=3.0, step=0.1, group=GRP_VSA)
vsaClassifierMethod = input.string("zscore", "Volume classifier method", options=["ratio", "zscore"], group=GRP_VSA)
vsa_zscore_sensitivity_ltf = input.float(2.5, "VSA Z-score Sensitivity (LTF 1-15m)", minval=0.5, maxval=6.0, step=0.1, group=GRP_VSA, tooltip="Start higher on LTF to reduce noise")
vsa_zscore_sensitivity_htf = input.float(1.6, "VSA Z-score Sensitivity (HTF 1H+)", minval=0.5, maxval=6.0, step=0.1, group=GRP_VSA, tooltip="Lower on HTF where signals are cleaner")

// compute effective sensitivity depending on chart timeframe
mult_num = timeframe.multiplier
isLTF = timeframe.isintraday and mult_num <= 15
isHTF = timeframe.isdaily or timeframe.isweekly or (timeframe.isintraday and mult_num >= 60)
vsa_zscore_sensitivity = isLTF ? vsa_zscore_sensitivity_ltf : (isHTF ? vsa_zscore_sensitivity_htf : vsa_zscore_sensitivity_htf)
// Optional confirmation and label throttling
vsaRequireCvdConfirm = input.bool(false, "Y√™u c·∫ßu x√°c nh·∫≠n CVD (tƒÉng‚ÜíCVD>MA, gi·∫£m‚ÜíCVD<MA)", group=GRP_VSA, tooltip="L·ªçc t√≠n hi·ªáu VSA: ch·ªâ hi·ªán khi CVD confirm h∆∞·ªõng (tƒÉng c·∫ßn CVD>MA, gi·∫£m c·∫ßn CVD<MA). Gi·∫£m false signal, tƒÉng win rate.")
vsaLabelLimit = input.int(200, "Max VSA Labels", minval=10, maxval=2000, group=GRP_VSA)

// === NHOM 6B: VSA-DIVERGENCE REVERSAL PATTERN (High Probability Setup) ===
const string GRP_VSA_DIV = "üéØ VSA-Divergence Reversal"
enableVsaDivPattern = input.bool(true, "Enable VSA‚ÜíDiv Reversal Detection", group=GRP_VSA_DIV, tooltip="Pattern: N·∫øn 1 c√≥ VSA/CVD marker m√†u X ‚Üí N·∫øn 2 c√≥ Divergence m√†u ng∆∞·ª£c l·∫°i = High probability reversal (Wyckoff Distribution/Accumulation)")
showVsaDivMarker = input.bool(true, "Show Diamond Marker", group=GRP_VSA_DIV, tooltip="Hi·ªÉn th·ªã marker kim c∆∞∆°ng ƒë·∫∑c bi·ªát khi pattern x·∫£y ra")
vsaDivAlertEnabled = input.bool(true, "Enable VSA‚ÜíDiv Alert", group=GRP_VSA_DIV)
vsaDivMinTF = input.int(15, "Min Timeframe (minutes)", minval=1, maxval=1440, group=GRP_VSA_DIV, tooltip="Ch·ªâ √°p d·ª•ng pattern cho TF >= gi√° tr·ªã n√†y (15m recommended cho 4H chart)")

// === VSA LOGIC ===
// compute moving average and basic spreads
volumeMA_vsa2 = ta.sma(volume, vsaVolumeLength)
atr_vsa = ta.atr(14)
spread_vsa = high - low
wideSpread_vsa = spread_vsa > atr_vsa * 1.2
narrowSpread_vsa = spread_vsa < atr_vsa * 0.5

// safety helpers for ratio and z-score classification
f_safe_ratio(num, den, defVal) => den == 0 ? defVal : num / den
f_zscore(series, length) =>
    _ma = ta.sma(series, length)
    _sd = ta.stdev(series, length)
    _sd == 0 ? 0.0 : (series - _ma) / _sd

// compute both ratio and z-score candidates
vol_z = f_zscore(volume, vsaVolumeLength)
volRatio = f_safe_ratio(volume, volumeMA_vsa2, 1.0)

isHigh_ratio = volRatio >= vsaSensitivity
isVeryHigh_ratio = volRatio >= (vsaSensitivity * 1.5)
isUltraHigh_ratio = volRatio >= (vsaSensitivity * 2.0)

isHigh_zscore = vol_z >= vsa_zscore_sensitivity
isVeryHigh_zscore = vol_z >= (vsa_zscore_sensitivity + 1.0)
isUltraHigh_zscore = vol_z >= (vsa_zscore_sensitivity + 2.0)

// final flags chosen by method (keeps ratio as default for compatibility)
isHigh_final = vsaClassifierMethod == "zscore" ? isHigh_zscore : isHigh_ratio
isVeryHigh_final = vsaClassifierMethod == "zscore" ? isVeryHigh_zscore : isVeryHigh_ratio
isUltraHigh_final = vsaClassifierMethod == "zscore" ? isUltraHigh_zscore : isUltraHigh_ratio

// low-volume remains ratio-based
lowVolume_vsa = volume < volumeMA_vsa2 * 0.7

// expose VSA booleans for signals
highVolume_vsa = isHigh_final
veryHighVolume_vsa = isVeryHigh_final
ultraHighVolume_vsa = isUltraHigh_final

// reliable volume guard: ensure there is meaningful historical volume
volumeMax_vsa = ta.highest(volume, vsaVolumeLength)
hasReliableVolume = not na(volume) and volumeMax_vsa > 0
// small epsilon to avoid divide-by-zero when high==low
_range_eps = 1e-8
normClosePos = (close - low) / math.max(high - low, _range_eps)

// === 10 T√çN HI·ªÜU VSA QUAN TR·ªåNG NH·∫§T CHO BTC/CRYPTO ===
// T√≠n hi·ªáu Bearish (gi·∫£m)
sellingClimax = showSC and veryHighVolume_vsa and close < open and normClosePos < 0.3  // SC: ƒê·ªânh b√°n th√°o
noDemand = showND and lowVolume_vsa and close > open and normClosePos < 0.6 and close[1] < close[2]  // ND: Kh√¥ng c√≥ c·∫ßu
upthrust = showUT and highVolume_vsa and high > high[1] and close < close[1] and normClosePos < 0.5  // UT: ƒê·∫©y gi√° gi·∫£
weakness = showWK and highVolume_vsa and wideSpread_vsa and close < open and normClosePos < 0.5  // WK: Y·∫øu

// T√≠n hi·ªáu Bullish (tƒÉng)
buyingClimax = showBC and veryHighVolume_vsa and close > open and normClosePos > 0.7  // BC: ƒê·ªânh mua v√†o
noSupply = showNS and lowVolume_vsa and close < open and normClosePos > 0.4 and close[1] > close[2]  // NS: Kh√¥ng c√≥ cung
spring = showSP and lowVolume_vsa and low < low[1] and close > low and normClosePos > 0.5  // SP: L√≤ xo b·∫≠t l√™n
stoppingVolume = showSV and ultraHighVolume_vsa and narrowSpread_vsa and ((close > open and close[1] < open[1]) or (close < open and close[1] > open[1]))  // SV: Volume d·ª´ng xu h∆∞·ªõng
strength = showST and highVolume_vsa and wideSpread_vsa and close > open and normClosePos > 0.5  // ST: M·∫°nh
shakeout = showSO and highVolume_vsa and low < low[1] and close > close[1] and normClosePos > 0.6  // SO: R≈© b·ªè


// Gom t√≠n hi·ªáu VSA tr√™n 1 candle th√†nh 1 marker duy nh·∫•t

// Gom t√≠n hi·ªáu VSA tr√™n 1 candle th√†nh 1 marker duy nh·∫•t (d√πng label.new ƒë·ªÉ text ƒë·ªông)
var string[] vsaNames = array.new_string()
var string vsaText = ""
var label[] vsaLabels = array.new<label>()
// companion array to track label x positions for de-duplication
var int[] vsaLabelXs = array.new_int()
// compute simple CVD confirmation flags (uses cvdMA from above)
cvdConfirmBull = cvdSource > cvdMA
cvdConfirmBear = cvdSource < cvdMA
if showVSASignals
    vsaText := ""
    array.clear(vsaNames)
    // ƒê·∫øm s·ªë t√≠n hi·ªáu tƒÉng/gi·∫£m
    bullCount = 0
    bearCount = 0
    
    // === T√çN HI·ªÜU BEARISH (ch·ªâ th√™m n·∫øu kh√¥ng y√™u c·∫ßu x√°c nh·∫≠n CVD ho·∫∑c CVD x√°c nh·∫≠n) ===
    if sellingClimax and (not vsaRequireCvdConfirm or cvdConfirmBear)
        array.push(vsaNames, "SC")
        bearCount += 1
    if noDemand and (not vsaRequireCvdConfirm or cvdConfirmBear)
        array.push(vsaNames, "ND")
        bearCount += 1
    if upthrust and (not vsaRequireCvdConfirm or cvdConfirmBear)
        array.push(vsaNames, "UT")
        bearCount += 1
    if weakness and (not vsaRequireCvdConfirm or cvdConfirmBear)
        array.push(vsaNames, "WK")
        bearCount += 1
    
    // === T√çN HI·ªÜU BULLISH (ch·ªâ th√™m n·∫øu kh√¥ng y√™u c·∫ßu x√°c nh·∫≠n CVD ho·∫∑c CVD x√°c nh·∫≠n) ===
    if buyingClimax and (not vsaRequireCvdConfirm or cvdConfirmBull)
        array.push(vsaNames, "BC")
        bullCount += 1
    if noSupply and (not vsaRequireCvdConfirm or cvdConfirmBull)
        array.push(vsaNames, "NS")
        bullCount += 1
    if spring and (not vsaRequireCvdConfirm or cvdConfirmBull)
        array.push(vsaNames, "SP")
        bullCount += 1
    if stoppingVolume and (not vsaRequireCvdConfirm or cvdConfirmBull)
        array.push(vsaNames, "SV")
        bullCount += 1
    if strength and (not vsaRequireCvdConfirm or cvdConfirmBull)
        array.push(vsaNames, "ST")
        bullCount += 1
    if shakeout and (not vsaRequireCvdConfirm or cvdConfirmBull)
        array.push(vsaNames, "SO")
        bullCount += 1
    // T·∫°o text d·∫°ng A+B+C n·∫øu c√≥ t√≠n hi·ªáu
    if array.size(vsaNames) > 0
        for i = 0 to array.size(vsaNames) - 1
            vsaText := vsaText == "" ? array.get(vsaNames, i) : vsaText + "+" + array.get(vsaNames, i)
        // Ch·ªâ plot n·∫øu c√≥ √≠t nh·∫•t 1 t√≠n hi·ªáu v√† ·ªü bar confirmed
        if vsaText != "" and barstate.isconfirmed
            // Determine overall type by difference in counts
            diff = bullCount - bearCount
            vsaType = math.sign(diff)
            // Ch·ªçn m√†u: bull (xanh), bear (ƒë·ªè), neutral (xanh d∆∞∆°ng)
            vsaColor = vsaType == 1 ? color.green : vsaType == -1 ? color.red : color.blue
            // VSA labels tr√™n price chart: bull=d∆∞·ªõi low, bear=tr√™n high
            vsaY = vsaType == 1 ? low - (atr_for_labels * bullLabelOffset) : vsaType == -1 ? high + (atr_for_labels * bearLabelOffset) : low - (atr_for_labels * bullLabelOffset)
            vsaStyle = vsaType == 1 ? label.style_label_up : vsaType == -1 ? label.style_label_down : label.style_label_down
            // avoid duplicate labels at the same bar
            if array.size(vsaLabelXs) == 0
                lb = label.new(x=bar_index, y=vsaY, text=vsaText, style=vsaStyle, color=vsaColor, textcolor=color.white, size=size.tiny)
                // manage lifecycle: keep labels bounded
                array.unshift(vsaLabels, lb)
                array.unshift(vsaLabelXs, bar_index)
                if array.size(vsaLabels) > vsaLabelLimit
                    label.delete(array.get(vsaLabels, -1))
                    array.pop(vsaLabels)
                    array.pop(vsaLabelXs)
            else
                if not f_array_has_int(vsaLabelXs, bar_index)
                    lb = label.new(x=bar_index, y=vsaY, text=vsaText, style=vsaStyle, color=vsaColor, textcolor=color.white, size=size.tiny)
                    // manage lifecycle: keep labels bounded
                    array.unshift(vsaLabels, lb)
                    array.unshift(vsaLabelXs, bar_index)
                    if array.size(vsaLabels) > vsaLabelLimit
                        label.delete(array.get(vsaLabels, -1))
                        array.pop(vsaLabels)
                        array.pop(vsaLabelXs)

// === VSA-DIVERGENCE REVERSAL PATTERN DETECTION ===
// Pattern: N·∫øn 1 c√≥ VSA/CVD marker ‚Üí N·∫øn 2 c√≥ Divergence ng∆∞·ª£c h∆∞·ªõng = High-prob reversal
// Wyckoff logic: Smart money distribution (fake bull VSA ‚Üí bear div) or accumulation (fake bear VSA ‚Üí bull div)

// IMPORTANT: Declare hasVSABullish/hasVSABearish BEFORE using them
// Compute VSA signal flags for confluence detection (moved here to fix forward reference)
hasVSABullish = buyingClimax or noSupply or spring or stoppingVolume or strength or shakeout
hasVSABearish = sellingClimax or noDemand or upthrust or weakness

// Check if current TF meets minimum requirement (convert to minutes)
currentTFMinutes = timeframe.in_seconds() / 60
meetsMinTF = currentTFMinutes >= vsaDivMinTF

// Store previous bar's VSA bullish/bearish state
var bool prevBarHadVSABull = false
var bool prevBarHadVSABear = false

// Detect VSA-Divergence Reversal Pattern (only if TF >= minimum)
var label[] vsaDivPatternLabels = array.new<label>()
var int[] vsaDivPatternXs = array.new_int()

if enableVsaDivPattern and meetsMinTF
    // Pattern 1: Previous bar had bullish VSA/CVD ‚Üí Current bar has bearish divergence = BEARISH REVERSAL
    // (Distribution: smart money offloading into retail FOMO)
    vsaDivBearishReversal = prevBarHadVSABull and (bearCond or hiddenBearCond or cvdVolBearRegular or cvdVolBearHidden)
    
    // Pattern 2: Previous bar had bearish VSA/CVD ‚Üí Current bar has bullish divergence = BULLISH REVERSAL  
    // (Accumulation: smart money accumulating after shakeout)
    vsaDivBullishReversal = prevBarHadVSABear and (bullCond or hiddenBullCond or cvdVolBullRegular or cvdVolBullHidden)
    
    // Create diamond marker for pattern
    if showVsaDivMarker and barstate.isconfirmed
        if vsaDivBearishReversal and not f_array_has_int(vsaDivPatternXs, bar_index)
            patternLabel = label.new(x=bar_index, y=high + (atr_for_labels * bearLabelOffset * 1.5), 
                 text="‚¨• VSA‚ÜíDIV", style=label.style_label_down, 
                 color=color.new(color.fuchsia, 0), textcolor=color.white, size=size.small, 
                 tooltip="HIGH-PROB BEARISH REVERSAL\nPrev: VSA Bull ‚Üí Now: Divergence Bear\nWyckoff Distribution Pattern")
            array.unshift(vsaDivPatternLabels, patternLabel)
            array.unshift(vsaDivPatternXs, bar_index)
            if array.size(vsaDivPatternLabels) > 50
                label.delete(array.pop(vsaDivPatternLabels))
                array.pop(vsaDivPatternXs)
        
        if vsaDivBullishReversal and not f_array_has_int(vsaDivPatternXs, bar_index)
            patternLabel = label.new(x=bar_index, y=low - (atr_for_labels * bullLabelOffset * 1.5), 
                 text="‚¨• VSA‚ÜíDIV", style=label.style_label_up, 
                 color=color.new(color.aqua, 0), textcolor=color.white, size=size.small, 
                 tooltip="HIGH-PROB BULLISH REVERSAL\nPrev: VSA Bear ‚Üí Now: Divergence Bull\nWyckoff Accumulation Pattern")
            array.unshift(vsaDivPatternLabels, patternLabel)
            array.unshift(vsaDivPatternXs, bar_index)
            if array.size(vsaDivPatternLabels) > 50
                label.delete(array.pop(vsaDivPatternLabels))
                array.pop(vsaDivPatternXs)

// Update previous bar VSA state for next bar
prevBarHadVSABull := hasVSABullish or (cvdSource > cvdMA and (bullCond or cvdVolBullRegular))
prevBarHadVSABear := hasVSABearish or (cvdSource < cvdMA and (bearCond or cvdVolBearRegular))

// === VSA LEGEND TABLE (10 T√çN HI·ªÜU QUAN TR·ªåNG NH·∫§T) ===
if showVSALegend and barstate.islast
    // √Ånh x·∫° legendPosition string sang position enum
    legend_pos = legendPosition == "bottom_right" ? position.bottom_right : legendPosition == "bottom_left" ? position.bottom_left : legendPosition == "top_right" ? position.top_right : position.top_left
    var table vsaLegend = table.new(position=legend_pos, columns=2, rows=10, bgcolor=color.new(color.gray, 90), border_width=1, frame_color=color.new(color.gray, 60))
    // T√≠n hi·ªáu Bearish (m√†u ƒë·ªè)
    table.cell(vsaLegend, 0, 0, "SC", text_size=size.tiny, text_color=color.red, bgcolor=color.new(color.red, 90))
    table.cell(vsaLegend, 1, 0, "Selling Climax - ƒê·ªânh b√°n th√°o", text_size=size.tiny)
    table.cell(vsaLegend, 0, 1, "ND", text_size=size.tiny, text_color=color.red, bgcolor=color.new(color.red, 90))
    table.cell(vsaLegend, 1, 1, "No Demand - Kh√¥ng c√≥ c·∫ßu", text_size=size.tiny)
    table.cell(vsaLegend, 0, 2, "UT", text_size=size.tiny, text_color=color.red, bgcolor=color.new(color.red, 90))
    table.cell(vsaLegend, 1, 2, "Upthrust - ƒê·∫©y gi√° gi·∫£", text_size=size.tiny)
    table.cell(vsaLegend, 0, 3, "WK", text_size=size.tiny, text_color=color.red, bgcolor=color.new(color.red, 90))
    table.cell(vsaLegend, 1, 3, "Weakness - Y·∫øu", text_size=size.tiny)
    // T√≠n hi·ªáu Bullish (m√†u xanh)
    table.cell(vsaLegend, 0, 4, "BC", text_size=size.tiny, text_color=color.green, bgcolor=color.new(color.green, 90))
    table.cell(vsaLegend, 1, 4, "Buying Climax - ƒê·ªânh mua v√†o", text_size=size.tiny)
    table.cell(vsaLegend, 0, 5, "NS", text_size=size.tiny, text_color=color.green, bgcolor=color.new(color.green, 90))
    table.cell(vsaLegend, 1, 5, "No Supply - Kh√¥ng c√≥ cung", text_size=size.tiny)
    table.cell(vsaLegend, 0, 6, "SP", text_size=size.tiny, text_color=color.green, bgcolor=color.new(color.green, 90))
    table.cell(vsaLegend, 1, 6, "Spring - L√≤ xo b·∫≠t l√™n", text_size=size.tiny)
    table.cell(vsaLegend, 0, 7, "SV", text_size=size.tiny, text_color=color.green, bgcolor=color.new(color.green, 90))
    table.cell(vsaLegend, 1, 7, "Stopping Volume - Volume d·ª´ng xu h∆∞·ªõng", text_size=size.tiny)
    table.cell(vsaLegend, 0, 8, "ST", text_size=size.tiny, text_color=color.green, bgcolor=color.new(color.green, 90))
    table.cell(vsaLegend, 1, 8, "Strength - M·∫°nh", text_size=size.tiny)
    table.cell(vsaLegend, 0, 9, "SO", text_size=size.tiny, text_color=color.blue, bgcolor=color.new(color.blue, 90))
    table.cell(vsaLegend, 1, 9, "Shakeout - R≈© b·ªè", text_size=size.tiny)

// classify regular vs hidden CVD+Volume divergence flags (now explicitly separated)
regCvdVolBull = cvdVolBullRegular
regCvdVolBear = cvdVolBearRegular
hiddenCvdVolBull = cvdVolBullHidden
hiddenCvdVolBear = cvdVolBearHidden

// === NHOM 7: VOLUME Z-SCORE ===
const string GRP_VOL_ZSCORE = "üìä Volume Z-Score"
showVolume = input.bool(true, "Hi·ªÉn th·ªã Volume Chart", group=GRP_VOL_ZSCORE)
lengthVolumeMA_z = input.int(20, title="ƒê·ªô d√†i MA Volume", minval=1, group=GRP_VOL_ZSCORE)
// Ng∆∞·ª°ng Z-score
ultraHighZ = input.float(2.5, "Z Ultra High", minval=1.0, maxval=5.0, step=0.1, group=GRP_VOL_ZSCORE)
veryHighZ = input.float(1.8, "Z Very High", minval=0.5, maxval=4.0, step=0.1, group=GRP_VOL_ZSCORE)
highZ = input.float(1.0, "Z High", minval=0.0, maxval=3.0, step=0.1, group=GRP_VOL_ZSCORE)
normalLowZ = input.float(-0.5, "Z Normal Low", minval=-2.0, maxval=1.0, step=0.1, group=GRP_VOL_ZSCORE)
lowZ = input.float(-1.5, "Z Low", minval=-3.0, maxval=0.0, step=0.1, group=GRP_VOL_ZSCORE)

// Create persistent horizontal lines (hline) at CVD and Volume baselines
hline(cvdZeroOffset, title="CVD Baseline", color=color.gray, linestyle=hline.style_solid, linewidth=1, display=showCvdBaseline ? display.all : display.none)
hline(volumeZeroOffset, title="Volume Baseline", color=color.new(color.gray, 60), linestyle=hline.style_solid, linewidth=1, display=showVolumeBaseline ? display.all : display.none)

// H√†m t√≠nh Z-score cho volume
f_zscore_vol(src, len) =>
    ma = ta.sma(src, len)
    sd = ta.stdev(src, len)
    sd != 0 ? (src - ma) / sd : 0

volZ = f_zscore_vol(volume, lengthVolumeMA_z)

// Ph√¢n lo·∫°i volume theo Z-score
isUltraHigh_z = volZ >= ultraHighZ
isVeryHigh_z = volZ >= veryHighZ and volZ < ultraHighZ
isHigh_z = volZ >= highZ and volZ < veryHighZ
isNormal_z = volZ >= normalLowZ and volZ < highZ
isLow_z = volZ >= lowZ and volZ < normalLowZ
isVeryLow_z = volZ < lowZ

// Ch·ªçn m√†u theo Z-score
volColorZ = isUltraHigh_z ? color.new(color.purple, volumeChartAlpha) : isVeryHigh_z  ? color.new(color.red, volumeChartAlpha) : isHigh_z      ? color.new(color.orange, volumeChartAlpha) : isNormal_z    ? color.new(color.green, volumeChartAlpha) : isLow_z       ? color.new(color.blue, volumeChartAlpha) : color.new(color.gray, volumeChartAlpha)

// V·∫Ω c·ªôt volume (visual only): draw bars anchored at baseline (volumeZeroOffset), apply Y scale
plotcandle(volumeZeroOffset, (volume * volumeYScale) + volumeZeroOffset, volumeZeroOffset, (volume * volumeYScale) + volumeZeroOffset, title="Volume (Z-Score)", color=volColorZ, bordercolor=volColorZ, wickcolor=volColorZ, display=showVolume ? display.all : display.none)

// === CVD+VOLUME DIVERGENCE tr√™n Volume chart (t∆∞∆°ng t·ª± CVD+Price tr√™n Price chart) ===
// V·∫Ω t·∫°i volume values c·ªßa CVD pivots b·∫±ng line.new (kh√¥ng ph·∫£i volume pivots), apply Y scale (ch·ªâ khi divChartDisplay = "Split")
cvdVolBullVolColor = cvdVolBull ? (cvdVolBullRegular ? CVDVOL_BULL_REGULAR_COLOR : CVDVOL_BULL_HIDDEN_COLOR) : color.new(color.white, 100)
cvdVolBearVolColor = cvdVolBear ? (cvdVolBearRegular ? CVDVOL_BEAR_REGULAR_COLOR : CVDVOL_BEAR_HIDDEN_COLOR) : color.new(color.white, 100)

if divChartDisplay == "Split: C+P on Price / C+V on Volume" and plFound and cvdVolBull and not na(prev_plBar)
    y1_vol = (prev_vol_at_cvd_low * volumeYScale) + volumeZeroOffset
    y2_vol = (volume[lookbackRight] * volumeYScale) + volumeZeroOffset
    newLine = line.new(x1=int(prev_plBar), y1=y1_vol, x2=bar_index - lookbackRight, y2=y2_vol, color=cvdVolBullVolColor, width=2)
    array.unshift(volDivLines, newLine)
    if array.size(volDivLines) > maxDivLines
        line.delete(array.pop(volDivLines))

if divChartDisplay == "Split: C+P on Price / C+V on Volume" and phFound and cvdVolBear and not na(prev_phBar)
    y1_vol = (prev_vol_at_cvd_high * volumeYScale) + volumeZeroOffset
    y2_vol = (volume[lookbackRight] * volumeYScale) + volumeZeroOffset
    newLine = line.new(x1=int(prev_phBar), y1=y1_vol, x2=bar_index - lookbackRight, y2=y2_vol, color=cvdVolBearVolColor, width=2)
    array.unshift(volDivLines, newLine)
    if array.size(volDivLines) > maxDivLines
        line.delete(array.pop(volDivLines))

// T√≠nh offset cho labels tr√™n volume chart (d√πng % c·ªßa scaled volume range)
vol_range = (ta.highest(volume, 20) - ta.lowest(volume, 20)) * volumeYScale
vol_label_offset = vol_range * 0.05  // 5% c·ªßa scaled volume range

// === C+V LABELS: Support all 3 display options ===
volLabelX = bar_index - lookbackRight

// Option 1: C+V labels on Price chart (use divLabels array, price Y-coordinates)
if divChartDisplay == "All on Price Chart"
    if cvdVolBullRegular
        if not f_array_has_int(divLabelXs, volLabelX)
            labelText = hasLevel5Plus_Bull_ForLabel ? "‚≠êVBull" : hasLevel2to4_Bull_ForLabel ? "‚ö†Ô∏èVBull" : "VBull"
            f_createDivLabel(volLabelX, low[lookbackRight] - (atr_for_labels * bullLabelOffset), labelText, false, CVDVOL_BULL_REGULAR_COLOR, divLabels, divLabelXs, divLabelLimit)
    if cvdVolBearRegular
        if not f_array_has_int(divLabelXs, volLabelX)
            labelText = hasLevel5Plus_Bear_ForLabel ? "‚≠êVBear" : hasLevel2to4_Bear_ForLabel ? "‚ö†Ô∏èVBear" : "VBear"
            f_createDivLabel(volLabelX, high[lookbackRight] + (atr_for_labels * bearLabelOffset), labelText, true, CVDVOL_BEAR_REGULAR_COLOR, divLabels, divLabelXs, divLabelLimit)
    if cvdVolBullHidden
        if not f_array_has_int(divLabelXs, volLabelX)
            labelText = hasLevel5Plus_Bull_ForLabel ? "‚≠êH.VBull" : hasLevel2to4_Bull_ForLabel ? "‚ö†Ô∏èH.VBull" : "H.VBull"
            f_createDivLabel(volLabelX, low[lookbackRight] - (atr_for_labels * bullLabelOffset), labelText, false, CVDVOL_BULL_HIDDEN_COLOR, divLabels, divLabelXs, divLabelLimit)
    if cvdVolBearHidden
        if not f_array_has_int(divLabelXs, volLabelX)
            labelText = hasLevel5Plus_Bear_ForLabel ? "‚≠êH.VBear" : hasLevel2to4_Bear_ForLabel ? "‚ö†Ô∏èH.VBear" : "H.VBear"
            f_createDivLabel(volLabelX, high[lookbackRight] + (atr_for_labels * bearLabelOffset), labelText, true, CVDVOL_BEAR_HIDDEN_COLOR, divLabels, divLabelXs, divLabelLimit)

// Option 2: C+V labels on Volume chart (default, use volDivLabels array)
if divChartDisplay == "Split: C+P on Price / C+V on Volume"
    if cvdVolBullRegular
        if not f_array_has_int(volDivLabelXs, volLabelX)
            labelText = hasLevel5Plus_Bull_ForLabel ? "‚≠êVBull" : hasLevel2to4_Bull_ForLabel ? "‚ö†Ô∏èVBull" : "VBull"
            f_createDivLabel(volLabelX, (volume[lookbackRight] * volumeYScale) + volumeZeroOffset - vol_label_offset, labelText, false, CVDVOL_BULL_REGULAR_COLOR, volDivLabels, volDivLabelXs, divLabelLimit)
    if cvdVolBearRegular
        if not f_array_has_int(volDivLabelXs, volLabelX)
            labelText = hasLevel5Plus_Bear_ForLabel ? "‚≠êVBear" : hasLevel2to4_Bear_ForLabel ? "‚ö†Ô∏èVBear" : "VBear"
            f_createDivLabel(volLabelX, (volume[lookbackRight] * volumeYScale) + volumeZeroOffset + vol_label_offset, labelText, true, CVDVOL_BEAR_REGULAR_COLOR, volDivLabels, volDivLabelXs, divLabelLimit)
    if cvdVolBullHidden
        if not f_array_has_int(volDivLabelXs, volLabelX)
            labelText = hasLevel5Plus_Bull_ForLabel ? "‚≠êH.VBull" : hasLevel2to4_Bull_ForLabel ? "‚ö†Ô∏èH.VBull" : "H.VBull"
            f_createDivLabel(volLabelX, (volume[lookbackRight] * volumeYScale) + volumeZeroOffset - vol_label_offset, labelText, false, CVDVOL_BULL_HIDDEN_COLOR, volDivLabels, volDivLabelXs, divLabelLimit)
    if cvdVolBearHidden
        if not f_array_has_int(volDivLabelXs, volLabelX)
            labelText = hasLevel5Plus_Bear_ForLabel ? "‚≠êH.VBear" : hasLevel2to4_Bear_ForLabel ? "‚ö†Ô∏èH.VBear" : "H.VBear"
            f_createDivLabel(volLabelX, (volume[lookbackRight] * volumeYScale) + volumeZeroOffset + vol_label_offset, labelText, true, CVDVOL_BEAR_HIDDEN_COLOR, volDivLabels, volDivLabelXs, divLabelLimit)

// Option 3: C+V labels on CVD chart (use divLabels array, CVD scaled Y-coordinates)
if divChartDisplay == "All on CVD Chart"
    cvd_label_offset = (ta.highest(cvdSource, 20) - ta.lowest(cvdSource, 20)) * cvdYScale * 0.05
    if cvdVolBull and cvdVolBullRegular
        if not f_array_has_int(divLabelXs, volLabelX)
            labelText = hasLevel5Plus_Bull_ForLabel ? "‚≠êVBull" : hasLevel2to4_Bull_ForLabel ? "‚ö†Ô∏èVBull" : "VBull"
            f_createDivLabel(volLabelX, (plVal * cvdYScale) + cvdZeroOffset - cvd_label_offset, labelText, false, CVDVOL_BULL_REGULAR_COLOR, divLabels, divLabelXs, divLabelLimit)
    if cvdVolBear and cvdVolBearRegular
        if not f_array_has_int(divLabelXs, volLabelX)
            labelText = hasLevel5Plus_Bear_ForLabel ? "‚≠êVBear" : hasLevel2to4_Bear_ForLabel ? "‚ö†Ô∏èVBear" : "VBear"
            f_createDivLabel(volLabelX, (phVal * cvdYScale) + cvdZeroOffset + cvd_label_offset, labelText, true, CVDVOL_BEAR_REGULAR_COLOR, divLabels, divLabelXs, divLabelLimit)
    if cvdVolBull and cvdVolBullHidden
        if not f_array_has_int(divLabelXs, volLabelX)
            labelText = hasLevel5Plus_Bull_ForLabel ? "‚≠êH.VBull" : hasLevel2to4_Bull_ForLabel ? "‚ö†Ô∏èH.VBull" : "H.VBull"
            f_createDivLabel(volLabelX, (plVal * cvdYScale) + cvdZeroOffset - cvd_label_offset, labelText, false, CVDVOL_BULL_HIDDEN_COLOR, divLabels, divLabelXs, divLabelLimit)
    if cvdVolBear and cvdVolBearHidden
        if not f_array_has_int(divLabelXs, volLabelX)
            labelText = hasLevel5Plus_Bear_ForLabel ? "‚≠êH.VBear" : hasLevel2to4_Bear_ForLabel ? "‚ö†Ô∏èH.VBear" : "H.VBear"
            f_createDivLabel(volLabelX, (phVal * cvdYScale) + cvdZeroOffset + cvd_label_offset, labelText, true, CVDVOL_BEAR_HIDDEN_COLOR, divLabels, divLabelXs, divLabelLimit)

// === ADVANCED ALERT SYSTEM ===
// Note: hasVSABullish/hasVSABearish ƒë√£ ƒë∆∞·ª£c khai b√°o ·ªü tr√™n (trong VSA-Div Pattern section)

// === 1. C∆† B·∫¢N - PH√ÇN K·ª≤ ƒê∆†N (Basic Divergence Alerts) ===
// M·ª•c ƒë√≠ch: C·∫£nh b√°o khi c√≥ ph√¢n k·ª≥ gi·ªØa CVD+Price HO·∫∂C CVD+Volume
// ƒê·ªô tin c·∫≠y: TRUNG B√åNH (50-60% win rate)
// Khi n√†o d√πng: Trade discretionary, c·∫ßn confirm th√™m b·∫±ng price action
// [C·∫§P 1A] CVD+Gi√° Ph√¢n K·ª≥ Th∆∞·ªùng (m·∫°nh h∆°n Hidden)
alertcondition(enableBasicDivAlerts and bullCond, 'C+P: Th∆∞·ªùng TƒÉng', 'CVPZ: üü¢ Ph√¢n K·ª≥ CVD+Gi√° TƒÇNG\nüìä Gi√° xu·ªëng th·∫•p m·ªõi, CVD cao h∆°n\n‚ö†Ô∏è C·∫ßn: Confirm b·∫±ng n·∫øn ƒë·∫£o chi·ªÅu\nüìà Win rate ~55%')
alertcondition(enableBasicDivAlerts and bearCond, 'C+P: Th∆∞·ªùng Gi·∫£m', 'CVPZ: üî¥ Ph√¢n K·ª≥ CVD+Gi√° GI·∫¢M\nüìä Gi√° l√™n cao m·ªõi, CVD th·∫•p h∆°n\n‚ö†Ô∏è C·∫ßn: Confirm b·∫±ng n·∫øn ƒë·∫£o chi·ªÅu\nüìâ Win rate ~55%')

// [C·∫§P 1B] CVD+Gi√° Ph√¢n K·ª≥ ·∫®n (y·∫øu h∆°n Regular, d√πng cho continuation)
alertcondition(enableBasicDivAlerts and hiddenBullCond, 'C+P: ·∫®n TƒÉng', 'CVPZ: üü¶ Ph√¢n K·ª≥ ·∫®n TƒÇNG\nüìä Trend continuation signal\n‚ö†Ô∏è Trade c·∫©n th·∫≠n, win rate ~50%')
alertcondition(enableBasicDivAlerts and hiddenBearCond, 'C+P: ·∫®n Gi·∫£m', 'CVPZ: üü• Ph√¢n K·ª≥ ·∫®n GI·∫¢M\nüìä Trend continuation signal\n‚ö†Ô∏è Trade c·∫©n th·∫≠n, win rate ~50%')

// [C·∫§P 1C] CVD+Volume Ph√¢n K·ª≥ (√≠t ph·ªï bi·∫øn h∆°n nh∆∞ng m·∫°nh khi x·∫£y ra)
alertcondition(enableBasicDivAlerts and cvdVolBullRegular and hasReliableVolume, 'C+V: Th∆∞·ªùng TƒÉng', 'CVPZ: üîµ Ph√¢n K·ª≥ CVD+Volume TƒÇNG\nüìä CVD tƒÉng nh∆∞ng Volume gi·∫£m = Sellers exhausted\nüí° Setup t·ªët khi k·∫øt h·ª£p C+P')
alertcondition(enableBasicDivAlerts and cvdVolBearRegular and hasReliableVolume, 'C+V: Th∆∞·ªùng Gi·∫£m', 'CVPZ: üî¥ Ph√¢n K·ª≥ CVD+Volume GI·∫¢M\nüìä CVD gi·∫£m nh∆∞ng Volume tƒÉng = Buyers exhausted\nüí° Setup t·ªët khi k·∫øt h·ª£p C+P')
alertcondition(enableBasicDivAlerts and cvdVolBullHidden and hasReliableVolume, 'C+V: ·∫®n TƒÉng', 'CVPZ: üü¶ C+V Hidden Bull\nüìä √çt d√πng, trade c·∫©n th·∫≠n')
alertcondition(enableBasicDivAlerts and cvdVolBearHidden and hasReliableVolume, 'C+V: ·∫®n Gi·∫£m', 'CVPZ: üü• C+V Hidden Bear\nüìä √çt d√πng, trade c·∫©n th·∫≠n')

// === 2. TRUNG C·∫§P - H·ªòI T·ª§ K√âP (Double Confluence: C+P + C+V) ===
// M·ª•c ƒë√≠ch: C·∫£nh b√°o khi C·∫¢ 2 lo·∫°i ph√¢n k·ª≥ x·∫£y ra C√ôNG L√öC (r·∫•t hi·∫øm!)
// ƒê·ªô tin c·∫≠y: CAO (65-75% win rate)
// Khi n√†o d√πng: Setup ch√≠nh cho swing trade, c√≥ th·ªÉ v√†o l·ªánh ngay

// [C·∫§P 2A] H·ªôi T·ª• K√©p Ho√†n H·∫£o (c·∫£ 2 ƒë·ªÅu Regular = m·∫°nh nh·∫•t)
confluentBullRegular = (bullCond and cvdVolBullRegular and hasReliableVolume)
confluentBearRegular = (bearCond and cvdVolBearRegular and hasReliableVolume)
alertcondition(enableConfluentAlerts and confluentBullRegular, '‚≠ê H·ªòI T·ª§ K√âP: TƒÇNG', 'CVPZ: üéØüéØ H·ªòI T·ª§ K√âP TƒÇNG üü¢üü¢\n‚úÖ Ph√¢n k·ª≥ CVD+Gi√° (Regular)\n‚úÖ Ph√¢n k·ª≥ CVD+Volume (Regular)\nüìà X√ÅC SU·∫§T CAO ~70%\nüí∞ Entry: Long khi break n·∫øn hi·ªán t·∫°i\nüõë Stop: D∆∞·ªõi ƒë√°y g·∫ßn nh·∫•t\nüéØ Target: Resistance g·∫ßn nh·∫•t')
alertcondition(enableConfluentAlerts and confluentBearRegular, '‚≠ê H·ªòI T·ª§ K√âP: GI·∫¢M', 'CVPZ: üéØüéØ H·ªòI T·ª§ K√âP GI·∫¢M üî¥üî¥\n‚úÖ Ph√¢n k·ª≥ CVD+Gi√° (Regular)\n‚úÖ Ph√¢n k·ª≥ CVD+Volume (Regular)\nüìâ X√ÅC SU·∫§T CAO ~70%\nüí∞ Entry: Short khi break n·∫øn hi·ªán t·∫°i\nüõë Stop: Tr√™n ƒë·ªânh g·∫ßn nh·∫•t\nüéØ Target: Support g·∫ßn nh·∫•t')

// [C·∫§P 2B] H·ªôi T·ª• K√©p Pha Tr·ªôn (1 Regular + 1 Hidden = y·∫øu h∆°n)
confluentBullMixed = ((bullCond and cvdVolBullHidden) or (hiddenBullCond and cvdVolBullRegular)) and hasReliableVolume
confluentBearMixed = ((bearCond and cvdVolBearHidden) or (hiddenBearCond and cvdVolBullRegular)) and hasReliableVolume
alertcondition(enableConfluentAlerts and confluentBullMixed, '‚≠ê H·ªôi T·ª• Pha Tr·ªôn: TƒÉng', 'CVPZ: üéØ H·ªôi T·ª• Pha Tr·ªôn TƒÇNG üü¢üü¶\nüìä 1 Regular + 1 Hidden\n‚ö†Ô∏è Win rate ~60%, c·∫ßn confirm th√™m')
alertcondition(enableConfluentAlerts and confluentBearMixed, '‚≠ê H·ªôi T·ª• Pha Tr·ªôn: Gi·∫£m', 'CVPZ: üéØ H·ªôi T·ª• Pha Tr·ªôn GI·∫¢M üî¥üü•\nüìä 1 Regular + 1 Hidden\n‚ö†Ô∏è Win rate ~60%, c·∫ßn confirm th√™m')

// === 3. C·∫¢M T√çN - V√ôNG C·ª∞C ƒêOAN (BB Break Alerts) ===
// M·ª•c ƒë√≠ch: C·∫£nh b√°o khi CVD v√†o v√πng qu√° mua/qu√° b√°n (Bollinger Band)
// ƒê·ªô tin c·∫≠y: TH·∫§P ƒë·∫øn TRUNG B√åNH (45-55% n·∫øu trade ng∆∞·ª£c xu h∆∞·ªõng)
// Khi n√†o d√πng: ƒê·ª£i CONFIRM b·∫±ng n·∫øn ƒë·∫£o chi·ªÅu ho·∫∑c ph√¢n k·ª≥, KH√îNG v√†o l·ªánh ngay!

// [C·∫§P 3A] CVD Qu√° Mua (tr√™n BB upper = nguy c∆° ƒë·∫£o chi·ªÅu xu·ªëng)
alertcondition(enableBBBreakAlerts and cvd_is_overbought, '‚ö†Ô∏è BB: Qu√° Mua', 'CVPZ: ‚ö†Ô∏è‚ö†Ô∏è CVD QU√Å MUA ‚ö†Ô∏è‚ö†Ô∏è\nüìä CVD v∆∞·ª£t Bollinger Band tr√™n\nüí° V√πng ƒë·∫£o chi·ªÅu ti·ªÅm nƒÉng\nüö´ KH√îNG short ngay!\n‚úÖ ƒê·ª£i: Ph√¢n k·ª≥ bear HO·∫∂C n·∫øn ƒë·∫£o chi·ªÅu\nüéØ Crypto bi·∫øn ƒë·ªông cao ‚Üí c√≥ th·ªÉ c√≤n ch·∫°y xa')

// [C·∫§P 3B] CVD Qu√° B√°n (d∆∞·ªõi BB lower = nguy c∆° ƒë·∫£o chi·ªÅu l√™n)
alertcondition(enableBBBreakAlerts and cvd_is_oversold, '‚ö†Ô∏è BB: Qu√° B√°n', 'CVPZ: ‚ö†Ô∏è‚ö†Ô∏è CVD QU√Å B√ÅN ‚ö†Ô∏è‚ö†Ô∏è\nüìä CVD xu·ªëng d∆∞·ªõi Bollinger Band d∆∞·ªõi\nüí° V√πng ƒë·∫£o chi·ªÅu ti·ªÅm nƒÉng\nüö´ KH√îNG long ngay!\n‚úÖ ƒê·ª£i: Ph√¢n k·ª≥ bull HO·∫∂C n·∫øn ƒë·∫£o chi·ªÅu\nüéØ Crypto bi·∫øn ƒë·ªông cao ‚Üí c√≥ th·ªÉ c√≤n gi·∫£m s√¢u')

// === 4. TRUNG C·∫§P - H·ªòI T·ª§ VSA+PH√ÇN K·ª≤ (VSA + Divergence Confluence) ===
// M·ª•c ƒë√≠ch: K·∫øt h·ª£p VSA institutional signal v·ªõi Divergence
// ƒê·ªô tin c·∫≠y: CAO (65-70% win rate)
// Khi n√†o d√πng: Setup ch√≠nh, c√≥ th·ªÉ v√†o l·ªánh khi c√≥ confirm price action

// [C·∫§P 4A] VSA TƒÉng + Ph√¢n K·ª≥ TƒÉng (smart money accumulation)
vsaDivBull = (bullCond or cvdVolBullRegular) and hasVSABullish and hasReliableVolume
alertcondition(enableVSAConfluentAlerts and vsaDivBull, '‚ö†Ô∏è VSA+PK: TƒÇNG', 'CVPZ: üí™üí™ VSA + PH√ÇN K·ª≤ TƒÇNG\n‚úÖ Ph√¢n k·ª≥ Bullish\n‚úÖ VSA Bullish (SP/SV/ST/BC/NS/SO)\nüìà Smart money ƒëang mua\nüí∞ Win rate ~68%\nüéØ Entry khi break cao n·∫øn hi·ªán t·∫°i')

// [C·∫§P 4B] VSA Gi·∫£m + Ph√¢n K·ª≥ Gi·∫£m (smart money distribution)
vsaDivBear = (bearCond or cvdVolBearRegular) and hasVSABearish and hasReliableVolume
alertcondition(enableVSAConfluentAlerts and vsaDivBear, '‚ö†Ô∏è VSA+PK: GI·∫¢M', 'CVPZ: üí™üí™ VSA + PH√ÇN K·ª≤ GI·∫¢M\n‚úÖ Ph√¢n k·ª≥ Bearish\n‚úÖ VSA Bearish (SC/ND/UT/WK)\nüìâ Smart money ƒëang b√°n\nüí∞ Win rate ~68%\nüéØ Entry khi break th·∫•p n·∫øn hi·ªán t·∫°i')

// === 5. CAO C·∫§P - H·ªòI T·ª§ BA Y·∫æU T·ªê (Triple Confluence: C+P + C+V + VSA) ===
// M·ª•c ƒë√≠ch: Setup CH·∫ÆC ƒÇN NH·∫§T - c·∫£ 3 y·∫øu t·ªë h·ªôi t·ª• (R·∫§T HI·∫æM!)
// ƒê·ªô tin c·∫≠y: R·∫§T CAO (75-85% win rate)
// Khi n√†o d√πng: ALL-IN setup, tƒÉng g·∫•p ƒë√¥i risk (2% thay v√¨ 1%)
// T·∫ßn su·∫•t: ~1-3 l·∫ßn/th√°ng tr√™n BTC 4H

// [C·∫§P 5] H·ªòI T·ª§ BA - TƒÇNG (Holy Grail Setup)
// Note: Kh√¥ng y√™u c·∫ßu hasReliableVolume - volume check ƒë√£ flexible cho c·∫•p 5+
tripleConfluenceBull = (bullCond and cvdVolBullRegular) and hasVSABullish
alertcondition(enableTripleConfluence and tripleConfluenceBull, 'üåü BA Y·∫æU T·ªê: TƒÇNG', 'CVPZ: üöÄüöÄüöÄ H·ªòI T·ª§ BA Y·∫æU T·ªê TƒÇNG üöÄüöÄüöÄ\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n‚úÖ Ph√¢n k·ª≥ CVD+Gi√° (Regular)\n‚úÖ Ph√¢n k·ª≥ CVD+Volume (Regular)\n‚úÖ VSA TƒÉng (Smart money mua)\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüéØ X√ÅC SU·∫§T: 75-85% (CH·∫ÆC ƒÇN NH·∫§T!)\nüí∞ Risk: TƒÉng l√™n 2% equity\nüìà Entry: NGAY khi break cao n·∫øn hi·ªán t·∫°i\nüõë Stop: D∆∞·ªõi ƒë√°y swing g·∫ßn nh·∫•t\nüéØ TP1: Resistance g·∫ßn (50% close)\nüéØ TP2: Resistance ch√≠nh (trail 50% c√≤n l·∫°i)\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüí° Setup xu·∫•t hi·ªán ~1-3 l·∫ßn/th√°ng\n‚ö†Ô∏è KH√îNG B·ªé L·ª†!')

// [C·∫§P 5] H·ªòI T·ª§ BA - GI·∫¢M (Holy Grail Setup)
// Note: Kh√¥ng y√™u c·∫ßu hasReliableVolume - volume check ƒë√£ flexible cho c·∫•p 5+
tripleConfluenceBear = (bearCond and cvdVolBearRegular) and hasVSABearish
alertcondition(enableTripleConfluence and tripleConfluenceBear, 'üåü BA Y·∫æU T·ªê: GI·∫¢M', 'CVPZ: üí•üí•üí• H·ªòI T·ª§ BA Y·∫æU T·ªê GI·∫¢M üí•üí•üí•\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n‚úÖ Ph√¢n k·ª≥ CVD+Gi√° (Regular)\n‚úÖ Ph√¢n k·ª≥ CVD+Volume (Regular)\n‚úÖ VSA Gi·∫£m (Smart money b√°n)\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüéØ X√ÅC SU·∫§T: 75-85% (CH·∫ÆC ƒÇN NH·∫§T!)\nüí∞ Risk: TƒÉng l√™n 2% equity\nüìâ Entry: NGAY khi break th·∫•p n·∫øn hi·ªán t·∫°i\nüõë Stop: Tr√™n ƒë·ªânh swing g·∫ßn nh·∫•t\nüéØ TP1: Support g·∫ßn (50% close)\nüéØ TP2: Support ch√≠nh (trail 50% c√≤n l·∫°i)\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüí° Setup xu·∫•t hi·ªán ~1-3 l·∫ßn/th√°ng\n‚ö†Ô∏è KH√îNG B·ªé L·ª†!')

// === 6. C·ª∞C ƒêOAN - BB + PH√ÇN K·ª≤ (Extreme Reversal Zone) ===
// M·ª•c ƒë√≠ch: Reversal t·ª´ v√πng c·ª±c ƒëoan (BB) + confirm b·∫±ng Divergence
// ƒê·ªô tin c·∫≠y: CAO (70-75% win rate)
// Khi n√†o d√πng: Reversal trade, scalp ho·∫∑c swing
// ƒê·∫∑c ƒëi·ªÉm: Crypto bi·∫øn ƒë·ªông m·∫°nh ‚Üí BB break th∆∞·ªùng b√°o hi·ªáu ƒë·∫£o chi·ªÅu s·∫Øp t·ªõi

// [C·∫§P 6A] C·ª±c ƒêoan TƒÉng (Oversold + Divergence Bull)
// Note: Kh√¥ng y√™u c·∫ßu hasReliableVolume - BB extreme + divergence ƒë·ªß m·∫°nh
bbDivBull = cvd_is_oversold and (bullCond or cvdVolBullRegular)
alertcondition(enableBBBreakAlerts and bbDivBull, 'üî• C·ª∞C ƒêOAN: TƒÇNG', 'CVPZ: üî•üî• V√ôNG ƒê·∫¢O CHI·ªÄU C·ª∞C ƒêOAN TƒÇNG\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n‚úÖ CVD qu√° b√°n (d∆∞·ªõi BB lower)\n‚úÖ Ph√¢n k·ª≥ Bullish xu·∫•t hi·ªán\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüìà ƒê√°y c·ª±c ƒëoan ‚Üí kh·∫£ nƒÉng b·∫≠t l√™n cao\nüí∞ Win rate ~72%\nüéØ Entry: Long sau n·∫øn ƒë·∫£o chi·ªÅu\nüõë Stop: D∆∞·ªõi BB lower\nüí° Crypto hay V-shape recovery t·ª´ v√πng n√†y')

// [C·∫§P 6B] C·ª±c ƒêoan Gi·∫£m (Overbought + Divergence Bear)
// Note: Kh√¥ng y√™u c·∫ßu hasReliableVolume - BB extreme + divergence ƒë·ªß m·∫°nh
bbDivBear = cvd_is_overbought and (bearCond or cvdVolBearRegular)
alertcondition(enableBBBreakAlerts and bbDivBear, 'üî• C·ª∞C ƒêOAN: GI·∫¢M', 'CVPZ: üî•üî• V√ôNG ƒê·∫¢O CHI·ªÄU C·ª∞C ƒêOAN GI·∫¢M\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n‚úÖ CVD qu√° mua (tr√™n BB upper)\n‚úÖ Ph√¢n k·ª≥ Bearish xu·∫•t hi·ªán\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüìâ ƒê·ªânh c·ª±c ƒëoan ‚Üí kh·∫£ nƒÉng r·ªõt xu·ªëng cao\nüí∞ Win rate ~72%\nüéØ Entry: Short sau n·∫øn ƒë·∫£o chi·ªÅu\nüõë Stop: Tr√™n BB upper\nüí° Crypto hay dump m·∫°nh t·ª´ v√πng n√†y')

// === 7. CAO C·∫§P - VSA‚ÜíPH√ÇN K·ª≤ ƒê·∫¢O CHI·ªÄU (VSA-Divergence Reversal Pattern) ===
// M·ª•c ƒë√≠ch: Ph√°t hi·ªán Wyckoff Distribution/Accumulation (2-bar pattern)
// ƒê·ªô tin c·∫≠y: R·∫§T CAO (75-80% win rate tr√™n TF ‚â•15m)
// Khi n√†o d√πng: Setup CH√çNH cho 4H/1H, c√≥ th·ªÉ tƒÉng risk l√™n 1.5-2%
// Pattern: N·∫øn 1 (VSA bull) ‚Üí N·∫øn 2 (Divergence bear) = Smart money distribution
//          N·∫øn 1 (VSA bear) ‚Üí N·∫øn 2 (Divergence bull) = Smart money accumulation

// [C·∫§P 7A] ƒê·∫¢O CHI·ªÄU GI·∫¢M (Distribution Pattern - Bearish)
vsaDivBearishRev = enableVsaDivPattern and meetsMinTF and prevBarHadVSABull[1] and (bearCond or hiddenBearCond or cvdVolBearRegular or cvdVolBearHidden)
alertcondition(vsaDivAlertEnabled and vsaDivBearishRev, '‚¨• VSA‚ÜíPK: GI·∫¢M', 'CVPZ: ‚¨•‚¨•‚¨• VSA‚ÜíPH√ÇN K·ª≤ ƒê·∫¢O CHI·ªÄU GI·∫¢M ‚¨•‚¨•‚¨•\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüéØ SETUP X√ÅC SU·∫§T CAO 75-80%\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüìä PATTERN PH√ÅT HI·ªÜN:\n  üü¢ N·∫øn 1: VSA TƒÉng (fake bullish)\n  üî¥ N·∫øn 2: Ph√¢n K·ª≥ Gi·∫£m (confirm distribution)\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüí° C∆† CH·∫æ TH·ªä TR∆Ø·ªúNG (Wyckoff Distribution):\n  1Ô∏è‚É£ Smart money t·∫°o illusion bullish (n·∫øn 1)\n  2Ô∏è‚É£ Retail FOMO mua v√†o\n  3Ô∏è‚É£ Smart money offload positions v√†o retail\n  4Ô∏è‚É£ Ph√¢n k·ª≥ xu·∫•t hi·ªán = confirm distribution\n  5Ô∏è‚É£ Gi√° s·∫Ω ƒë·∫£o chi·ªÅu gi·∫£m m·∫°nh\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüìà C√ÅCH V√ÄO L·ªÜNH:\n  ‚úÖ ƒê·ª£i n·∫øn 3 close d∆∞·ªõi low n·∫øn 2\n  ‚úÖ Entry: Short khi break low n·∫øn 2\n  ‚úÖ Entry agressive: Short ngay n·∫øn 2\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüõë STOP LOSS:\n  ‚Ä¢ Conservative: Tr√™n high n·∫øn 1\n  ‚Ä¢ Aggressive: Tr√™n high n·∫øn 2\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüéØ TAKE PROFIT:\n  ‚Ä¢ TP1 (50%): Swing low g·∫ßn nh·∫•t\n  ‚Ä¢ TP2 (30%): Support ch√≠nh\n  ‚Ä¢ TP3 (20%): BB lower / trail\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüí∞ POSITION SIZE:\n  ‚Ä¢ TƒÉng l√™n 1.5-2% risk\n  ‚Ä¢ Risk/Reward t·ªëi thi·ªÉu: 1:2\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n‚ö†Ô∏è L∆ØU √ù CRYPTO:\n  ‚Ä¢ Pattern m·∫°nh nh·∫•t tr√™n 4H, 1H\n  ‚Ä¢ Tr√°nh trade khi th·ªã tr∆∞·ªùng sideway\n  ‚Ä¢ Confirm th√™m v·ªõi HTF trend')

// [C·∫§P 7B] ƒê·∫¢O CHI·ªÄU TƒÇNG (Accumulation Pattern - Bullish)
vsaDivBullishRev = enableVsaDivPattern and meetsMinTF and prevBarHadVSABear[1] and (bullCond or hiddenBullCond or cvdVolBullRegular or cvdVolBullHidden)
alertcondition(vsaDivAlertEnabled and vsaDivBullishRev, '‚¨• VSA‚ÜíPK: TƒÇNG', 'CVPZ: ‚¨•‚¨•‚¨• VSA‚ÜíPH√ÇN K·ª≤ ƒê·∫¢O CHI·ªÄU TƒÇNG ‚¨•‚¨•‚¨•\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüéØ SETUP X√ÅC SU·∫§T CAO 75-80%\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüìä PATTERN PH√ÅT HI·ªÜN:\n  üî¥ N·∫øn 1: VSA Gi·∫£m (fake bearish)\n  üü¢ N·∫øn 2: Ph√¢n K·ª≥ TƒÉng (confirm accumulation)\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüí° C∆† CH·∫æ TH·ªä TR∆Ø·ªúNG (Wyckoff Accumulation):\n  1Ô∏è‚É£ Smart money t·∫°o illusion bearish (n·∫øn 1)\n  2Ô∏è‚É£ Retail panic b√°n ra\n  3Ô∏è‚É£ Smart money mua v√†o gi√° r·∫ª t·ª´ retail\n  4Ô∏è‚É£ Ph√¢n k·ª≥ xu·∫•t hi·ªán = confirm accumulation\n  5Ô∏è‚É£ Gi√° s·∫Ω ƒë·∫£o chi·ªÅu tƒÉng m·∫°nh\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüìà C√ÅCH V√ÄO L·ªÜNH:\n  ‚úÖ ƒê·ª£i n·∫øn 3 close tr√™n high n·∫øn 2\n  ‚úÖ Entry: Long khi break high n·∫øn 2\n  ‚úÖ Entry agressive: Long ngay n·∫øn 2\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüõë STOP LOSS:\n  ‚Ä¢ Conservative: D∆∞·ªõi low n·∫øn 1\n  ‚Ä¢ Aggressive: D∆∞·ªõi low n·∫øn 2\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüéØ TAKE PROFIT:\n  ‚Ä¢ TP1 (50%): Swing high g·∫ßn nh·∫•t\n  ‚Ä¢ TP2 (30%): Resistance ch√≠nh\n  ‚Ä¢ TP3 (20%): BB upper / trail\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüí∞ POSITION SIZE:\n  ‚Ä¢ TƒÉng l√™n 1.5-2% risk\n  ‚Ä¢ Risk/Reward t·ªëi thi·ªÉu: 1:2\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n‚ö†Ô∏è L∆ØU √ù CRYPTO:\n  ‚Ä¢ Pattern m·∫°nh nh·∫•t tr√™n 4H, 1H\n  ‚Ä¢ Crypto hay V-shape recovery\n  ‚Ä¢ Tr√°nh trade khi th·ªã tr∆∞·ªùng sideway\n  ‚Ä¢ Confirm th√™m v·ªõi HTF trend')

// === PLOTSHAPE: NG√îI SAO CHO H·ªòI T·ª§ C·∫§P 5+ ===
// Hi·ªÉn th·ªã ng√¥i sao ‚≠ê tr√™n n·∫øn c√≥ h·ªôi t·ª• c·∫•p 5 tr·ªü l√™n (75%+ win rate setups)

// Aggregate Level 5+ signals
hasLevel5Plus_Bull = tripleConfluenceBull or bbDivBull or vsaDivBullishRev
hasLevel5Plus_Bear = tripleConfluenceBear or bbDivBear or vsaDivBearishRev

// Plot stars above/below candles
plotshape(hasLevel5Plus_Bull, "‚≠ê Level 5+ Bull", shape.labelup, location.belowbar, color.new(color.green, 0), text="‚≠ê", textcolor=color.white, size=size.small)
plotshape(hasLevel5Plus_Bear, "‚≠ê Level 5+ Bear", shape.labeldown, location.abovebar, color.new(color.red, 0), text="‚≠ê", textcolor=color.white, size=size.small)