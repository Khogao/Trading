// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © lenguyenphi
// © 2025 Pi 3.4 Professional - Clean Architecture (No Repainting)
// CRITICAL: Pine v6 required for accurate CVD via ta.requestVolumeDelta (TradingView/ta/8)
//@version=6
indicator("Pi 3.4 Professional", shorttitle="PI 3.4 Pro", overlay=true, max_labels_count=300, max_boxes_count=300, max_lines_count=200)
import TradingView/ta/8 as tav6

// ============================================================================
// INPUT SECTIONS - Organized & Clean
// ============================================================================

// === MASTER PROFILE ===
var GRP_PROFILE = "🔥 1. Master Profile"
profile_selector = input.string("Day Trader", "Trading Profile", options=["Scalper", "Day Trader", "Swing Trader", "Position Trader"], group=GRP_PROFILE)

// === VPP CORE (Enhanced VPP5 Engine) ===
var GRP_VPP = "📊 2. Volume Profile"
vp_lookback = input.int(200, 'VP Lookback', minval=50, maxval=1000, group=GRP_VPP)
vp_levels = input.int(120, 'Price Levels', minval=50, maxval=200, group=GRP_VPP)
show_poc = input.bool(true, "POC", group=GRP_VPP, inline="vp1")
show_va = input.bool(true, "Value Area", group=GRP_VPP, inline="vp1")
show_va_lines = input.bool(true, "VA Lines", group=GRP_VPP, inline="vp2")
vp_volume_type = input.string("Both","Volume Type", options=["Both","Bullish","Bearish"], group=GRP_VPP)
vp_bar_width = input.int(40, "Bar Max Width (px)", minval=1, maxval=500, group=GRP_VPP)
vp_right_offset = input.int(20, "Right Offset (bars)", minval=0, maxval=300, group=GRP_VPP)

// === EXECUTION & PERFORMANCE ===
var GRP_EXEC = "⚡ 3. Execution & Performance"
execution_sensitivity = input.string("Medium", "Execution Sensitivity", options=["Ultra","High","Medium","Low"], group=GRP_EXEC)
auto_adjust_tf = input.bool(true, "Auto-adjust TF Mapping", group=GRP_EXEC)
intraday_mode_custom = input.bool(true, 'Intraday Mode', group=GRP_EXEC)
session_focus_custom = input.bool(true, 'Focus on Current Session', group=GRP_EXEC)
intraday_lookback_days = input.int(4, 'Intraday Lookback (days)', minval=1, maxval=30, group=GRP_EXEC)

// === HTF LEVELS ===
var GRP_HTF = "🔥 4. HTF Levels"
htf_enabled = input.bool(true, "Enable HTF", group=GRP_HTF)
htf_timeframe = input.timeframe("240", "HTF Period", group=GRP_HTF)
htf_show_poc = input.bool(true, "HTF POC", group=GRP_HTF, inline="htf1")
htf_show_va = input.bool(true, "HTF VA", group=GRP_HTF, inline="htf1")
htf_lookback = input.int(30, "HTF lookback (bars on HTF)", minval=5, maxval=200, group=GRP_HTF)
htf_levels = input.int(60, "HTF Price Levels", minval=20, maxval=200, group=GRP_HTF)
htf_va_percent = input.int(70, "HTF Value Area %", minval=10, maxval=99, group=GRP_HTF)

// === ADVANCED SESSION ===
var GRP_SESSION = "🕐 5. Advanced Session"
session_weight_custom = input.float(1.2, "Session Weight Factor", minval=0.1, maxval=5.0, step=0.1, group=GRP_SESSION)
intraday_start_hour = input.int(9,  "Intraday Start Hour",  minval=0, maxval=23, group=GRP_SESSION)
intraday_end_hour = input.int(17, "Intraday End Hour",    minval=0, maxval=23, group=GRP_SESSION)

// === VSA SIGNALS ===
var GRP_VSA = "🎯 6. VSA Analysis"
enable_vsa = input.bool(true, "Enable VSA", group=GRP_VSA)
vsa_sensitivity = input.string("Medium", "Sensitivity", options=["Low", "Medium", "High"], group=GRP_VSA)
show_spring = input.bool(true, "Spring", group=GRP_VSA, inline="sig1")
show_upthrust = input.bool(true, "Upthrust", group=GRP_VSA, inline="sig1")
show_climax = input.bool(true, "Climax", group=GRP_VSA, inline="sig2")
show_effort = input.bool(true, "Effort/Result", group=GRP_VSA, inline="sig2")

// === CVD LITE (Overlay Markers Only) ===
var GRP_CVD = "💎 6B. CVD Lite (Order Flow)"
enable_cvd = input.bool(true, "Enable CVD Analysis", group=GRP_CVD, tooltip="Background CVD calculation for divergence detection")
cvd_anchor = input.timeframe("D", "CVD Reset Period", group=GRP_CVD, tooltip="D=Daily, W=Weekly. Khung thời gian CVD reset về 0")
show_cvd_div = input.bool(true, "Show Divergence Markers", group=GRP_CVD)
show_cvd_lines = input.bool(true, "Show Divergence Lines", group=GRP_CVD)
cvd_lookback_left = input.int(5, "Pivot: Lookback Left", minval=2, maxval=15, group=GRP_CVD)
cvd_lookback_right = input.int(5, "Pivot: Lookback Right", minval=2, maxval=15, group=GRP_CVD)
cvd_range_min = input.int(5, "Pivot: Range Min", minval=1, maxval=60, group=GRP_CVD)
cvd_range_max = input.int(60, "Pivot: Range Max", minval=5, maxval=200, group=GRP_CVD)

// === VOLUME Z-SCORE (Adaptive Classification) ===
var GRP_VOL_Z = "📊 6C. Volume Classification"
enable_vol_zscore = input.bool(true, "Enable Z-Score Coloring", group=GRP_VOL_Z, tooltip="Adaptive volume classification cho crypto")
vol_zscore_length = input.int(20, "Z-Score MA Length", minval=5, maxval=100, group=GRP_VOL_Z)

// === STRUCTURE NODES (HVN/LVN) ===
var GRP_STRUCT = "📍 6D. Structure Nodes (HVN/LVN)"
structure_show_nodes = input.bool(false, "Show HVN/LVN Zones", group=GRP_STRUCT, tooltip="High/Low Volume Nodes - consolidation vs breakout zones")
structure_hvn_threshold = input.int(80, "HVN Threshold (% of Max Vol)", minval=1, maxval=100, group=GRP_STRUCT, tooltip="High Volume Node = consolidation area")
structure_lvn_threshold = input.int(20, "LVN Threshold (% of Max Vol)", minval=0, maxval=100, group=GRP_STRUCT, tooltip="Low Volume Node = breakout/breakdown area")
structure_hvn_color = input.color(color.new(color.gray, 85), "HVN Fill", group=GRP_STRUCT)
structure_lvn_color = input.color(color.new(color.gray, 92), "LVN Fill", group=GRP_STRUCT)
vol_zscore_ltf_sens = input.float(2.5, "LTF Sensitivity (1-15m)", minval=1.0, maxval=5.0, step=0.1, group=GRP_VOL_Z)
vol_zscore_htf_sens = input.float(1.6, "HTF Sensitivity (1H+)", minval=0.5, maxval=3.0, step=0.1, group=GRP_VOL_Z)

// === ALERTS SYSTEM (7-Level) ===
var GRP_ALERTS = "🔔 6D. Alert System (7 Levels)"
enable_alerts = input.bool(true, "Enable Alert System", group=GRP_ALERTS)
// Level 1: Basic Signals
alert_lv1_vsa = input.bool(true, "CẤP 1: Basic VSA", group=GRP_ALERTS, tooltip="Win rate ~50-55%")
alert_lv1_div = input.bool(true, "CẤP 1: Basic Divergence", group=GRP_ALERTS, tooltip="Win rate ~50-55%")
// Level 2: Confluence
alert_lv2_vsa_vp = input.bool(true, "CẤP 2: VSA @ VP", group=GRP_ALERTS, tooltip="Win rate ~65-70%")
alert_lv2_div_vp = input.bool(true, "CẤP 2: Divergence @ VP", group=GRP_ALERTS, tooltip="Win rate ~65-70%")
// Level 3: HTF Alignment
alert_lv3_htf = input.bool(true, "CẤP 3: HTF Alignment", group=GRP_ALERTS, tooltip="Win rate ~70-75%")
// Level 4: Volume Extreme
alert_lv4_vol = input.bool(true, "CẤP 4: Volume Extreme", group=GRP_ALERTS, tooltip="Win rate ~75-80%")
// Level 5: Triple Confluence
alert_lv5_triple = input.bool(true, "CẤP 5: Triple (VSA+DIV+VP)", group=GRP_ALERTS, tooltip="Win rate ~80-85% - HOLY GRAIL!")

// === TREND CONTEXT ===
var GRP_TREND = "🌊 7. Trend Context"
show_ema = input.bool(true, "EMA Lines", group=GRP_TREND)
ema_fast = input.int(21, "Fast EMA", group=GRP_TREND, minval=5, maxval=50)
ema_slow = input.int(50, "Slow EMA", group=GRP_TREND, minval=20, maxval=100)
ema_long = input.int(200, "Long EMA", group=GRP_TREND, minval=100, maxval=300)
show_cloud = input.bool(true, "EMA Cloud", group=GRP_TREND)

// === DISPLAY ===
// === VSA SIGNALS (CVPZero Engine, 10 signals, Z-Score, guards) ===
const string GRP_VSA = "� VSA Signals"
showVSASignals = input.bool(true, "Hiển thị tín hiệu VSA", group=GRP_VSA, tooltip="10 tín hiệu VSA quan trọng nhất cho BTC/Crypto trading")
showSC = input.bool(true, "Selling Climax (SC) - Đỉnh bán tháo", group=GRP_VSA)
showBC = input.bool(true, "Buying Climax (BC) - Đỉnh mua vào", group=GRP_VSA)
showND = input.bool(true, "No Demand (ND) - Không có cầu", group=GRP_VSA)
showNS = input.bool(true, "No Supply (NS) - Không có cung", group=GRP_VSA)
showUT = input.bool(true, "Upthrust (UT) - Đẩy giá giả", group=GRP_VSA)
showSP = input.bool(true, "Spring (SP) - Lò xo bật lên", group=GRP_VSA)
showSV = input.bool(true, "Stopping Volume (SV) - Volume dừng xu hướng", group=GRP_VSA)
showWK = input.bool(true, "Weakness (WK) - Yếu", group=GRP_VSA)
showST = input.bool(true, "Strength (ST) - Mạnh", group=GRP_VSA)
showSO = input.bool(true, "Shakeout (SO) - Rũ bỏ", group=GRP_VSA)
showVSALegend = input.bool(true, "Hiển thị chú giải VSA (legend)", group=GRP_VSA)
legendPosition = input.string("bottom_right", "Vị trí legend", options=["top_left","top_right","bottom_left","bottom_right"], group=GRP_VSA)
vsaVolumeLength = input.int(20, "Độ dài MA Volume cho VSA", minval=5, maxval=100, group=GRP_VSA)
vsaSensitivity = input.float(1.5, "Độ nhạy VSA", minval=1.0, maxval=3.0, step=0.1, group=GRP_VSA)
vsaClassifierMethod = input.string("zscore", "Volume classifier method", options=["ratio", "zscore"], group=GRP_VSA)
vsa_zscore_sensitivity_ltf = input.float(2.5, "VSA Z-score Sensitivity (LTF 1-15m)", minval=0.5, maxval=6.0, step=0.1, group=GRP_VSA)
vsa_zscore_sensitivity_htf = input.float(1.6, "VSA Z-score Sensitivity (HTF 1H+)", minval=0.5, maxval=6.0, step=0.1, group=GRP_VSA)
vsaRequireCvdConfirm = input.bool(false, "Yêu cầu xác nhận CVD (tăng→CVD>MA, giảm→CVD<MA)", group=GRP_VSA, tooltip="Lọc tín hiệu VSA: chỉ hiện khi CVD confirm hướng (tăng cần CVD>MA, giảm cần CVD<MA). Giảm false signal, tăng win rate.")
vsaLabelLimit = input.int(200, "Max VSA Labels", minval=10, maxval=2000, group=GRP_VSA)

// Z-Score logic
mult_num = timeframe.multiplier
isLTF = timeframe.isintraday and mult_num <= 15
isHTF = timeframe.isdaily or timeframe.isweekly or (timeframe.isintraday and mult_num >= 60)
vsa_zscore_sensitivity = isLTF ? vsa_zscore_sensitivity_ltf : (isHTF ? vsa_zscore_sensitivity_htf : vsa_zscore_sensitivity_htf)
volumeMA_vsa2 = ta.sma(volume, vsaVolumeLength)
atr_vsa = ta.atr(14)
spread_vsa = high - low
wideSpread_vsa = spread_vsa > atr_vsa * 1.2
narrowSpread_vsa = spread_vsa < atr_vsa * 0.5
f_safe_ratio(num, den, defVal) => den == 0 ? defVal : num / den
f_zscore(series, length) =>
    _ma = ta.sma(series, length)
    _sd = ta.stdev(series, length)
    _sd == 0 ? 0.0 : (series - _ma) / _sd
vol_z = f_zscore(volume, vsaVolumeLength)
volRatio = f_safe_ratio(volume, volumeMA_vsa2, 1.0)
isHigh_ratio = volRatio >= vsaSensitivity
isVeryHigh_ratio = volRatio >= (vsaSensitivity * 1.5)
isUltraHigh_ratio = volRatio >= (vsaSensitivity * 2.0)
isHigh_zscore = vol_z >= vsa_zscore_sensitivity
isVeryHigh_zscore = vol_z >= (vsa_zscore_sensitivity + 1.0)
isUltraHigh_zscore = vol_z >= (vsa_zscore_sensitivity + 2.0)
isHigh_final = vsaClassifierMethod == "zscore" ? isHigh_zscore : isHigh_ratio
isVeryHigh_final = vsaClassifierMethod == "zscore" ? isVeryHigh_zscore : isVeryHigh_ratio
isUltraHigh_final = vsaClassifierMethod == "zscore" ? isUltraHigh_zscore : isUltraHigh_ratio
lowVolume_vsa = volume < volumeMA_vsa2 * 0.7
highVolume_vsa = isHigh_final
veryHighVolume_vsa = isVeryHigh_final
ultraHighVolume_vsa = isUltraHigh_final
volumeMax_vsa = ta.highest(volume, vsaVolumeLength)
hasReliableVolume = not na(volume) and volumeMax_vsa > 0
_range_eps = 1e-8
normClosePos = (close - low) / math.max(high - low, _range_eps)

// 10 tín hiệu VSA
sellingClimax = showSC and veryHighVolume_vsa and close < open and normClosePos < 0.3
noDemand = showND and lowVolume_vsa and close > open and normClosePos < 0.6 and close[1] < close[2]
upthrust = showUT and highVolume_vsa and high > high[1] and close < close[1] and normClosePos < 0.5
weakness = showWK and highVolume_vsa and wideSpread_vsa and close < open and normClosePos < 0.5
buyingClimax = showBC and veryHighVolume_vsa and close > open and normClosePos > 0.7
noSupply = showNS and lowVolume_vsa and close < open and normClosePos > 0.4 and close[1] > close[2]
spring = showSP and lowVolume_vsa and low < low[1] and close > low and normClosePos > 0.5
stoppingVolume = showSV and ultraHighVolume_vsa and narrowSpread_vsa and ((close > open and close[1] < open[1]) or (close < open and close[1] > open[1]))
strength = showST and highVolume_vsa and wideSpread_vsa and close > open and normClosePos > 0.5
shakeout = showSO and highVolume_vsa and low < low[1] and close > close[1] and normClosePos > 0.6

// CVD confirmation flags
cvdConfirmBull = cvd_value > ta.sma(cvd_value, vsaVolumeLength)
cvdConfirmBear = cvd_value < ta.sma(cvd_value, vsaVolumeLength)

// VSA marker logic
var string[] vsaNames = array.new_string()
var string vsaText = ""
var label[] vsaLabels = array.new<label>()
var int[] vsaLabelXs = array.new_int()
if showVSASignals and hasReliableVolume
    vsaText := ""
    array.clear(vsaNames)
    bullCount = 0
    bearCount = 0
    if sellingClimax and (not vsaRequireCvdConfirm or cvdConfirmBear)
        array.push(vsaNames, "SC")
        bearCount += 1
    if noDemand and (not vsaRequireCvdConfirm or cvdConfirmBear)
        array.push(vsaNames, "ND")
        bearCount += 1
    if upthrust and (not vsaRequireCvdConfirm or cvdConfirmBear)
        array.push(vsaNames, "UT")
        bearCount += 1
    if weakness and (not vsaRequireCvdConfirm or cvdConfirmBear)
        array.push(vsaNames, "WK")
        bearCount += 1
    if buyingClimax and (not vsaRequireCvdConfirm or cvdConfirmBull)
        array.push(vsaNames, "BC")
        bullCount += 1
    if noSupply and (not vsaRequireCvdConfirm or cvdConfirmBull)
        array.push(vsaNames, "NS")
        bullCount += 1
    if spring and (not vsaRequireCvdConfirm or cvdConfirmBull)
        array.push(vsaNames, "SP")
        bullCount += 1
    if stoppingVolume and (not vsaRequireCvdConfirm or cvdConfirmBull)
        array.push(vsaNames, "SV")
        bullCount += 1
    if strength and (not vsaRequireCvdConfirm or cvdConfirmBull)
        array.push(vsaNames, "ST")
        bullCount += 1
    if shakeout and (not vsaRequireCvdConfirm or cvdConfirmBull)
        array.push(vsaNames, "SO")
        bullCount += 1
    // Compose marker text
    if bullCount > 0 or bearCount > 0
        vsaText := "BULL: " + str.tostring(bullCount) + " | BEAR: " + str.tostring(bearCount) + " | " + array.join(vsaNames, ", ")
        // Draw label (limit to vsaLabelLimit)
        if array.size(vsaLabels) < vsaLabelLimit
            lb = label.new(bar_index, high, vsaText, color=color.new(color.blue, 80), style=label.style_label_down, textcolor=color.white, size=size.tiny)
            array.unshift(vsaLabels, lb)
            array.unshift(vsaLabelXs, bar_index)
        else
            label.delete(array.get(vsaLabels, -1))
            array.pop(vsaLabels)
            array.pop(vsaLabelXs)
            tf_str := '4H'
        else if timeframe.multiplier >= 60
            tf_str := '1H'
        else if timeframe.multiplier >= 15
            tf_str := '15m'
        else if timeframe.multiplier >= 5
            tf_str := '5m'
        else
            tf_str := '1m'
    tf_str

// ============================================================================
// ADVANCED VP ENGINE - VPP5 Production
// ============================================================================

// Enhanced VP Variables
var array<float> volume_at_price = array.new<float>()
var array<box> volume_boxes = array.new<box>()
var array<box> node_boxes = array.new<box>()
var float poc_price = 0.0
var float va_high = 0.0
var float va_low = 0.0
var int last_calc_bar = 0
var float price_high = 0.0
var float price_low = 0.0
var float price_step = 0.0

// Enhanced helper functions
f_price_to_index(price, local_price_low, local_price_step) =>
    local_price_step > 0 ? int(math.max(0, math.min(vp_levels - 1, math.floor((price - local_price_low) / local_price_step)))) : 0

f_calculate_value_area(poc_idx, total_vol, local_price_low, local_price_step, va_percentage) =>
    if poc_idx < 0 or total_vol <= 0
        [na, na]
    else
        target_volume = total_vol * va_percentage / 100
        va_volume = array.get(volume_at_price, poc_idx)
        va_upper = poc_idx
        va_lower = poc_idx
        while va_volume < target_volume and (va_upper < vp_levels - 1 or va_lower > 0)
            vol_above = va_upper < vp_levels - 1 ? array.get(volume_at_price, va_upper + 1) : 0.0
            vol_below = va_lower > 0 ? array.get(volume_at_price, va_lower - 1) : 0.0
            if vol_above >= vol_below and va_upper < vp_levels - 1
                va_upper += 1
                va_volume += vol_above
            else if va_lower > 0
                va_lower -= 1
                va_volume += vol_below
            else
                break
        [local_price_low + va_lower * local_price_step, local_price_low + va_upper * local_price_step]

// HVN/LVN structure node detection and drawing (from VPP6+)
f_find_and_draw_nodes(max_vol, local_price_low, local_price_step, effective_lookback) =>
    hvn_vol_threshold = max_vol * structure_hvn_threshold / 100
    lvn_vol_threshold = max_vol * structure_lvn_threshold / 100
    
    // HVN zones (High Volume Nodes - consolidation areas)
    in_hvn_zone = false
    hvn_start_idx = -1
    for i = 0 to vp_levels - 1
        is_hvn = array.get(volume_at_price, i) >= hvn_vol_threshold
        if is_hvn and not in_hvn_zone
            in_hvn_zone := true
            hvn_start_idx := i
        if not is_hvn and in_hvn_zone
            in_hvn_zone := false
            array.push(node_boxes, box.new(bar_index - effective_lookback, local_price_low + hvn_start_idx * local_price_step, 
                 bar_index + vp_right_offset, local_price_low + i * local_price_step, 
                 border_color=na, bgcolor=structure_hvn_color))
    if in_hvn_zone
        array.push(node_boxes, box.new(bar_index - effective_lookback, local_price_low + hvn_start_idx * local_price_step, 
             bar_index + vp_right_offset, local_price_low + vp_levels * local_price_step, 
             border_color=na, bgcolor=structure_hvn_color))
    
    // LVN zones (Low Volume Nodes - breakout areas)
    in_lvn_zone = false
    lvn_start_idx = -1
    for i = 0 to vp_levels - 1
        is_lvn = array.get(volume_at_price, i) <= lvn_vol_threshold
        if is_lvn and not in_lvn_zone
            in_lvn_zone := true
            lvn_start_idx := i
        if not is_lvn and in_lvn_zone
            in_lvn_zone := false
            array.push(node_boxes, box.new(bar_index - effective_lookback, local_price_low + lvn_start_idx * local_price_step, 
                 bar_index + vp_right_offset, local_price_low + i * local_price_step, 
                 border_color=na, bgcolor=structure_lvn_color))
    if in_lvn_zone
        array.push(node_boxes, box.new(bar_index - effective_lookback, local_price_low + lvn_start_idx * local_price_step, 
             bar_index + vp_right_offset, local_price_low + vp_levels * local_price_step, 
             border_color=na, bgcolor=structure_lvn_color))

// VP summary function for HTF analysis
f_vp_summary_local(vp_levels_local, lookback_local, va_pct_local) =>
    vol_local = array.new_float(0)
    for _ = 0 to vp_levels_local - 1
        array.push(vol_local, 0.0)
    ph = ta.highest(high, lookback_local)
    pl = ta.lowest(low, lookback_local)
    step = (ph - pl) / vp_levels_local
    if step <= 0
        [na, na, na]
    else
        for b = 0 to int(math.min(lookback_local - 1, bar_index))
            if volume[b] <= 0
                continue
            tp = (high[b] + low[b] + close[b]) / 3.0
            idx = step > 0 ? int(math.max(0, math.min(vp_levels_local - 1, math.floor((tp - pl) / step)))) : 0
            array.set(vol_local, idx, array.get(vol_local, idx) + volume[b])
        maxv = array.max(vol_local)
        if maxv <= 0
            [na, na, na]
        else
            poc_i = array.indexof(vol_local, maxv)
            total_vol = 0.0
            for i2 = 0 to vp_levels_local - 1
                total_vol += array.get(vol_local, i2)
            target = total_vol * va_pct_local / 100.0
            va_vol = array.get(vol_local, poc_i)
            va_up = poc_i
            va_dn = poc_i
            while va_vol < target and (va_up < vp_levels_local - 1 or va_dn > 0)
                vol_up = va_up < vp_levels_local - 1 ? array.get(vol_local, va_up + 1) : 0.0
                vol_dn = va_dn > 0 ? array.get(vol_local, va_dn - 1) : 0.0
                if vol_up >= vol_dn and va_up < vp_levels_local - 1
                    va_up += 1
                    va_vol += vol_up
                else if va_dn > 0
                    va_dn -= 1
                    va_vol += vol_dn
                else
                    break
            poc_price_local = pl + poc_i * step
            vah_local = pl + va_up * step
            val_local = pl + va_dn * step
            [poc_price_local, vah_local, val_local]

// ============================================================================
// HTF ANALYSIS - VPP5 Enhanced
// ============================================================================

// HTF line handles (Pine v6 compatible)
var line htf_poc_line = line(na)
var line htf_vah_line = line(na)
var line htf_val_line = line(na)
var float poc_htf = 0.0
var float vah_htf = 0.0
var float val_htf = 0.0

// Advanced execution logic from VPP5
tf_mode = f_get_timeframe_mode()
tf_minutes = timeframe.in_seconds(timeframe.period) / 60.0

base_update_freq = switch tf_mode
    '1D'  => math.max(10, final_lookback / 20)
    '4H'  => math.max(5, final_lookback / 30)
    '1H'  => math.max(3, final_lookback / 40)
    '15m' => math.max(2, final_lookback / 50)
    => 1

final_update_freq = switch execution_sensitivity
    'Ultra'  => 1
    'High'   => 2
    'Medium' => int(math.max(3, base_update_freq))
    => int(math.max(5, base_update_freq * 2))

// Enhanced volume and price movement detection
avg_len = int(math.min(50, bar_index + 1))
avg_vol_norm = ta.sma(volume, avg_len) / tf_minutes
cur_vol_norm = volume / tf_minutes

vol_thresh = switch execution_sensitivity
    'Ultra'  => 1.3
    'High'   => 1.7
    'Medium' => 2.5
    'Low'    => 4.0

move_thresh = switch execution_sensitivity
    'Ultra'  => 0.002
    'High'   => 0.003
    'Medium' => 0.005
    'Low'    => 0.01

vol_spike = cur_vol_norm > avg_vol_norm * vol_thresh and avg_vol_norm > 0
price_move = math.abs(close - nz(close[1])) / nz(close[1], 1) > move_thresh

// Enhanced update logic
needs_update = barstate.islast or (bar_index - last_calc_bar >= final_update_freq) or vol_spike or price_move

// Enhanced lookback calculation
new_day_flag_series = ta.change(time("D")) != 0
bars_since_new_day_series = ta.barssince(new_day_flag_series)
bars_per_day = 1440 / tf_minutes

int effective_lookback = na
if final_intraday_mode
    effective_lookback := int(math.min(final_lookback, intraday_lookback_days * bars_per_day))
else
    tmp_look = switch tf_mode
        '1D'  => math.min(final_lookback, 40)
        '4H'  => math.min(final_lookback, 120)
        '1H'  => math.min(final_lookback, 240)
        '15m' => math.min(final_lookback, 500)
        => math.min(final_lookback, 300)
    effective_lookback := int(tmp_look)

// HTF VP calculation
if htf_enabled
    [poc_htf_tmp, vah_htf_tmp, val_htf_tmp] = request.security(syminfo.tickerid, htf_timeframe, 
         f_vp_summary_local(htf_levels, htf_lookback, htf_va_percent), lookahead=barmerge.lookahead_off)
    if not na(poc_htf_tmp)
        poc_htf := poc_htf_tmp
        vah_htf := vah_htf_tmp
        val_htf := val_htf_tmp

// ============================================================================
// VSA ANALYSIS - Clean & Reliable
// ============================================================================

// Bar Analysis Type
type BarAnalysis
    bool is_up
    bool is_down
    bool high_volume
    bool low_volume
    bool wide_range
    bool narrow_range
    float close_position

// VSA Functions
f_analyze_bar() =>
    vol_ma = ta.sma(volume, 20)
    range_ma = ta.sma(high - low, 20)
    current_range = high - low
    
    // Volume analysis
    vol_ratio = vol_ma > 0 ? volume / vol_ma : 1.0
    is_high_vol = vol_ratio > vol_threshold
    is_low_vol = vol_ratio < (1.0 / vol_threshold)
    
    // Range analysis  
    range_ratio = range_ma > 0 ? current_range / range_ma : 1.0
    is_wide = range_ratio > (1.0 / range_threshold)
    is_narrow = range_ratio < range_threshold
    
    // Close position
    close_pos = current_range > 0 ? (close - low) / current_range : 0.5
    
    // Put constructor on one line to avoid line-continuation parse issues
    BarAnalysis.new(close > open, close < open, is_high_vol, is_low_vol, is_wide, is_narrow, close_pos)

// VSA Signals
bar_data = f_analyze_bar()

// Support/Resistance levels
support_level = ta.lowest(low, 20)[1]
resistance_level = ta.highest(high, 20)[1]

// VSA Patterns
is_spring = enable_vsa and show_spring and 
     bar_data.is_down and low <= support_level and 
     close > low + (high - low) * 0.3 and bar_data.high_volume

is_upthrust = enable_vsa and show_upthrust and 
     bar_data.is_up and high >= resistance_level and 
     close < high - (high - low) * 0.3 and bar_data.high_volume

is_selling_climax = enable_vsa and show_climax and 
     bar_data.is_down and bar_data.wide_range and bar_data.high_volume

is_buying_climax = enable_vsa and show_climax and 
     bar_data.is_up and bar_data.wide_range and bar_data.high_volume

is_effort_no_result = enable_vsa and show_effort and 
     bar_data.high_volume and bar_data.narrow_range

// Enhanced Spring (current logic is good but can be more precise)
is_spring_enhanced = enable_vsa and show_spring and 
     bar_data.low_volume and bar_data.narrow_range and
     close > (high + low) / 2 and  // Close in upper half
     close > open and               // Bullish close
     low <= ta.lowest(low, 10)[1]   // Testing previous lows

// Enhanced Upthrust
is_upthrust_enhanced = enable_vsa and show_upthrust and
     bar_data.high_volume and bar_data.narrow_range and
     close < (high + low) / 2 and  // Close in lower half  
     high >= ta.highest(high, 10)[1] // Testing previous highs

// VSA Score
vsa_score = 0.0
vsa_score += is_spring ? 3.0 : 0
vsa_score += is_selling_climax ? 2.0 : 0
vsa_score -= is_upthrust ? 3.0 : 0
vsa_score -= is_buying_climax ? 2.0 : 0
vsa_score -= is_effort_no_result ? 1.0 : 0

// ============================================================================
// CVD LITE ENGINE (Overlay Markers Only - From CVPZero)
// ============================================================================

// CVD Calculation (Background only, no chart display)
// Note: tav6 imported at top of file

f_cvd_close() =>
    [_o, _h, _l, _c] = tav6.requestVolumeDelta("1", cvd_anchor)
    _c

cvd_value = enable_cvd ? f_cvd_close() : na

// Session Reset Tracking (để tránh false divergence khi CVD reset)
var int last_cvd_reset_bar = 0
cvd_new_session = ta.change(time(cvd_anchor)) != 0
if cvd_new_session
    last_cvd_reset_bar := bar_index

// CVD Divergence Detection (Pivot-based, like CVPZero)
cvd_pl_val = ta.pivotlow(cvd_value, cvd_lookback_left, cvd_lookback_right)
cvd_ph_val = ta.pivothigh(cvd_value, cvd_lookback_left, cvd_lookback_right)
cvd_pl_found = not na(cvd_pl_val)
cvd_ph_found = not na(cvd_ph_val)
cvd_pl_since = ta.barssince(cvd_pl_found)
cvd_ph_since = ta.barssince(cvd_ph_found)
cvd_in_range_pl = cvd_pl_since[1] >= cvd_range_min and cvd_pl_since[1] <= cvd_range_max
cvd_in_range_ph = cvd_ph_since[1] >= cvd_range_min and cvd_ph_since[1] <= cvd_range_max

// Check if both pivots are in same CVD cycle (after same reset)
cvd_prev_pl_bar = ta.valuewhen(cvd_pl_found, bar_index - cvd_lookback_right, 1)
cvd_prev_ph_bar = ta.valuewhen(cvd_ph_found, bar_index - cvd_lookback_right, 1)
cvd_same_cycle_bull = (cvd_prev_pl_bar - nz(last_cvd_reset_bar, 0)) >= 0 and (bar_index - cvd_lookback_right - nz(last_cvd_reset_bar, 0)) >= 0
cvd_same_cycle_bear = (cvd_prev_ph_bar - nz(last_cvd_reset_bar, 0)) >= 0 and (bar_index - cvd_lookback_right - nz(last_cvd_reset_bar, 0)) >= 0

// CVD+Price Regular Divergence
cvd_price_ll = low[cvd_lookback_right] < ta.valuewhen(cvd_pl_found, low[cvd_lookback_right], 1)
cvd_cvd_hl = cvd_pl_val > ta.valuewhen(cvd_pl_found, cvd_pl_val, 1)
cvd_bull_regular = enable_cvd and show_cvd_div and cvd_same_cycle_bull and cvd_in_range_pl and cvd_price_ll and cvd_cvd_hl and cvd_pl_found

cvd_price_hh = high[cvd_lookback_right] > ta.valuewhen(cvd_ph_found, high[cvd_lookback_right], 1)
cvd_cvd_lh = cvd_ph_val < ta.valuewhen(cvd_ph_found, cvd_ph_val, 1)
cvd_bear_regular = enable_cvd and show_cvd_div and cvd_same_cycle_bear and cvd_in_range_ph and cvd_price_hh and cvd_cvd_lh and cvd_ph_found

// CVD+Price Hidden Divergence
cvd_price_hl = low[cvd_lookback_right] > ta.valuewhen(cvd_pl_found, low[cvd_lookback_right], 1)
cvd_cvd_ll = cvd_pl_val < ta.valuewhen(cvd_pl_found, cvd_pl_val, 1)
cvd_bull_hidden = enable_cvd and show_cvd_div and cvd_same_cycle_bull and cvd_in_range_pl and cvd_price_hl and cvd_cvd_ll and cvd_pl_found

cvd_price_lh = high[cvd_lookback_right] < ta.valuewhen(cvd_ph_found, high[cvd_lookback_right], 1)
cvd_cvd_hh = cvd_ph_val > ta.valuewhen(cvd_ph_found, cvd_ph_val, 1)
cvd_bear_hidden = enable_cvd and show_cvd_div and cvd_same_cycle_bear and cvd_in_range_ph and cvd_price_lh and cvd_cvd_hh and cvd_ph_found

// Combined divergence flags
cvd_has_bull_div = cvd_bull_regular or cvd_bull_hidden
cvd_has_bear_div = cvd_bear_regular or cvd_bear_hidden

// Divergence line connections (stored for drawing later)
var line cvd_bull_line = line(na)
var line cvd_bear_line = line(na)

// Pre-calculate y-coordinates for lines (to avoid ta.valuewhen inside if blocks)
cvd_prev_low_y = ta.valuewhen(cvd_pl_found, low[cvd_lookback_right], 1)
cvd_prev_high_y = ta.valuewhen(cvd_ph_found, high[cvd_lookback_right], 1)

if show_cvd_lines and cvd_has_bull_div and not na(cvd_prev_pl_bar)
    line.delete(cvd_bull_line)
    cvd_bull_line := line.new(
      int(cvd_prev_pl_bar), cvd_prev_low_y,
      bar_index - cvd_lookback_right, low[cvd_lookback_right],
      color=cvd_bull_regular ? color.lime : color.new(color.lime, 60),
      width=cvd_bull_regular ? 2 : 1,
      style=cvd_bull_regular ? line.style_solid : line.style_dashed)

if show_cvd_lines and cvd_has_bear_div and not na(cvd_prev_ph_bar)
    line.delete(cvd_bear_line)
    cvd_bear_line := line.new(
      int(cvd_prev_ph_bar), cvd_prev_high_y,
      bar_index - cvd_lookback_right, high[cvd_lookback_right],
      color=cvd_bear_regular ? color.red : color.new(color.red, 60),
      width=cvd_bear_regular ? 2 : 1,
      style=cvd_bear_regular ? line.style_solid : line.style_dashed)

// ============================================================================
// VOLUME Z-SCORE CLASSIFICATION (From VPP5+)
// ============================================================================

f_zscore_vol(src, len) =>
    ma = ta.sma(src, len)
    sd = ta.stdev(src, len)
    sd != 0 ? (src - ma) / sd : 0

// Adaptive sensitivity based on timeframe
vol_zscore_value = enable_vol_zscore ? f_zscore_vol(volume, vol_zscore_length) : 0
vol_zscore_thresh = (timeframe.isintraday and timeframe.multiplier <= 15) ? vol_zscore_ltf_sens : vol_zscore_htf_sens

vol_is_ultra_high = enable_vol_zscore and vol_zscore_value >= vol_zscore_thresh * 1.5
vol_is_very_high = enable_vol_zscore and vol_zscore_value >= vol_zscore_thresh and vol_zscore_value < vol_zscore_thresh * 1.5
vol_is_high = enable_vol_zscore and vol_zscore_value >= vol_zscore_thresh * 0.6 and vol_zscore_value < vol_zscore_thresh
vol_is_low = enable_vol_zscore and vol_zscore_value < vol_zscore_thresh * 0.6

// ============================================================================
// MAIN VP CALCULATION & EXECUTION - VPP5 Enhanced
// ============================================================================

// Initialize volume array if needed
if array.size(volume_at_price) != vp_levels
    array.clear(volume_at_price)
    for i = 0 to vp_levels - 1
        array.push(volume_at_price, 0.0)

// Main VP Calculation
price_high_all = ta.highest(high, effective_lookback)
price_low_all = ta.lowest(low, effective_lookback)
price_step_all = (price_high_all - price_low_all) / vp_levels

if needs_update
    // Cleanup existing drawings
    for bx in volume_boxes
        box.delete(bx)
    array.clear(volume_boxes)

    // Recalculate volume profile
    array.fill(volume_at_price, 0.0)
    price_high := price_high_all
    price_low := price_low_all  
    price_step := price_step_all

    if price_step > 0
        for b = 0 to int(math.min(effective_lookback - 1, bar_index))
            if volume[b] <= 0
                continue
            
            // Enhanced volume filtering
            is_bullish = close[b] >= open[b]
            include_volume = vp_volume_type == 'Both' or (vp_volume_type == 'Bullish' and is_bullish) or (vp_volume_type == 'Bearish' and not is_bullish)
            if not include_volume
                continue

            // Advanced volume weighting
            normalized_vol = volume[b] / tf_minutes
            age_decay_tf = switch tf_mode
                '1D'  => 0.002
                '4H'  => 0.006
                '1H'  => 0.012
                '15m' => 0.03
                => 0.06
            age_decay = final_intraday_mode ? 0.03 : age_decay_tf
            age_weight = 1.0 / (1.0 + age_decay * b)
            
            // Session weight factor
            session_weight_factor = 1.0
            if final_session_focus
                if final_intraday_mode
                    h = hour(time[b], syminfo.timezone)
                    in_window = intraday_start_hour <= intraday_end_hour ? (h >= intraday_start_hour and h < intraday_end_hour) : (h >= intraday_start_hour or h < intraday_end_hour)
                    if in_window
                        session_weight_factor := session_weight_custom
                else
                    if bars_since_new_day_series[b] <= bars_per_day
                        session_weight_factor := session_weight_custom

            weighted_volume = normalized_vol * age_weight * session_weight_factor
            
            // Enhanced price distribution
            body_ratio = math.abs(close[b] - open[b]) / math.max(high[b] - low[b], price_step)
            typical_price = nz(body_ratio * (open[b] + close[b]) / 2 + (1 - body_ratio) * (high[b] + low[b]) / 2, close[b])
            price_range = high[b] - low[b]

            if price_range <= 0
                idx = f_price_to_index(typical_price, price_low, price_step)
                array.set(volume_at_price, idx, array.get(volume_at_price, idx) + weighted_volume * tf_minutes)
            else
                start_idx = f_price_to_index(low[b], price_low, price_step)
                end_idx = f_price_to_index(high[b], price_low, price_step)
                denom = math.max(1, end_idx - start_idx + 1)
                dist_denom = math.max(price_range / 2, price_step)
                for j = start_idx to end_idx
                    level_price = price_low + j * price_step
                    distance_factor = math.max(0.0, 1.0 - math.abs(level_price - typical_price) / dist_denom)
                    weight = math.max(0.05, distance_factor)
                    distributed_vol = weighted_volume * weight / denom
                    array.set(volume_at_price, j, array.get(volume_at_price, j) + distributed_vol * tf_minutes)

        // Calculate POC and VA
        max_vol = array.max(volume_at_price)
        if max_vol > 0
            poc_idx = array.indexof(volume_at_price, max_vol)
            poc_price := price_low + poc_idx * price_step
            va_percentage = final_intraday_mode ? 70 : 70
            [va_low_val, va_high_val] = f_calculate_value_area(poc_idx, array.sum(volume_at_price), price_low, price_step, va_percentage)
            va_low := va_low_val
            va_high := va_high_val

            // Draw volume profile bars
            x_base = bar_index + vp_right_offset
            for i = 0 to vp_levels - 1
                level_volume = array.get(volume_at_price, i)
                if level_volume > 0
                    bar_length = int(math.round(level_volume / max_vol * vp_bar_width))
                    if bar_length > 0
                        level_price = price_low + i * price_step
                        is_in_va = show_va and not na(va_low_val) and level_price >= va_low_val and level_price <= va_high_val
                        is_poc = i == poc_idx and show_poc
                        box_color = is_poc ? color_poc : is_in_va ? color_va : vp_vol_color
                        array.push(volume_boxes, box.new(x_base, level_price - price_step / 2, x_base + bar_length, level_price + price_step / 2, bgcolor=box_color, border_color=na))
            
            // Draw HVN/LVN structure nodes (from VPP6+)
            if structure_show_nodes
                // Cleanup old node boxes
                for nb in node_boxes
                    box.delete(nb)
                array.clear(node_boxes)
                // Draw new HVN/LVN zones
                f_find_and_draw_nodes(max_vol, price_low, price_step, effective_lookback)

    last_calc_bar := bar_index

// EMA Lines
ema_fast_value = ta.ema(close, ema_fast)
ema_slow_value = ta.ema(close, ema_slow) 
ema_long_value = ta.ema(close, ema_long)

// Precompute ATR each bar for consistency
atr_value = ta.atr(14)
bar_range = high - low
wide_range = bar_range > atr_value * range_threshold

// Enhanced range analysis
range_percentile = ta.percentrank(bar_range, 50)
ultra_wide_range = range_percentile > 95
ultra_narrow_range = range_percentile < 5

plot(show_ema ? ema_fast_value : na, "Fast EMA", color.aqua, 1)
plot(show_ema ? ema_slow_value : na, "Slow EMA", color.orange, 1)
plot(show_ema ? ema_long_value : na, "Long EMA", color.gray, 2)

// EMA Cloud
p1 = plot(show_ema ? ema_fast_value : na, color=na)
p2 = plot(show_ema ? ema_slow_value : na, color=na)
fill(p1, p2, 
     color=show_cloud and show_ema ? 
          (ema_fast_value > ema_slow_value ? color.new(color.green, 85) : color.new(color.red, 85)) : na)

// Enhanced HTF Lines with VPP5 logic
if htf_enabled and not na(poc_htf)
    poc_start_x = bar_index - nz(effective_lookback, 100)
    poc_end_x = bar_index + vp_right_offset + vp_bar_width

    // HTF POC Line
    if htf_show_poc
        if na(htf_poc_line)
            htf_poc_line := line.new(poc_start_x, poc_htf, poc_end_x, poc_htf, color=color_htf_poc, width=2)
        else
            line.set_xy1(htf_poc_line, poc_start_x, poc_htf)
            line.set_xy2(htf_poc_line, poc_end_x, poc_htf)

    // HTF VA Lines  
    if htf_show_va and not na(vah_htf) and not na(val_htf)
        if na(htf_vah_line)
            htf_vah_line := line.new(poc_start_x, vah_htf, poc_end_x, vah_htf, color=color_htf_va, width=1, style=line.style_dashed)
        else
            line.set_xy1(htf_vah_line, poc_start_x, vah_htf)
            line.set_xy2(htf_vah_line, poc_end_x, vah_htf)
        
        if na(htf_val_line)
            htf_val_line := line.new(poc_start_x, val_htf, poc_end_x, val_htf, color=color_htf_va, width=1, style=line.style_dashed)
        else
            line.set_xy1(htf_val_line, poc_start_x, val_htf)
            line.set_xy2(htf_val_line, poc_end_x, val_htf)

// Enhanced VA Lines with VPP5 styling
if show_va_lines and not na(va_high) and not na(va_low) and needs_update
    line.new(bar_index - effective_lookback, va_high, bar_index + vp_right_offset + vp_bar_width, va_high, 
         color=color_va, width=1, style=line.style_dashed, extend=extend.none)
    line.new(bar_index - effective_lookback, va_low, bar_index + vp_right_offset + vp_bar_width, va_low, 
         color=color_va, width=1, style=line.style_dashed, extend=extend.none)

// Enhanced POC Box  
if show_poc and not na(poc_price) and needs_update
    box.new(bar_index - effective_lookback, poc_price - price_step / 4, bar_index + vp_right_offset - 5, 
         poc_price + price_step / 4, bgcolor=color_poc, border_color=color_poc)

// Background
bgcolor(show_background and math.abs(vsa_score) > 2 ? 
     (vsa_score > 0 ? color.new(color.green, 90) : color.new(color.red, 90)) : na)

// VSA Labels
if barstate.isconfirmed and enable_vsa
    // Use precomputed ATR
    if is_spring
        label.new(bar_index, low - atr_value * 0.5, "Spring", 
             textcolor=color.green, style=label.style_none, size=size.small)
    if is_upthrust  
        label.new(bar_index, high + atr_value * 0.5, "Upthrust", 
             textcolor=color.red, style=label.style_none, size=size.small)
    if is_selling_climax
        label.new(bar_index, low - atr_value * 0.3, "SC", 
             textcolor=color.blue, style=label.style_none, size=size.tiny)
    if is_buying_climax
        label.new(bar_index, high + atr_value * 0.3, "BC", 
             textcolor=color.purple, style=label.style_none, size=size.tiny)

// Info Panel (Pine v6 compatible)
var table info_table = table(na)

if show_info and barstate.islast
    pos = switch info_position
        "top_left" => position.top_left
        "top_right" => position.top_right  
        "bottom_left" => position.bottom_left
        => position.bottom_right
    
    if na(info_table)
        info_table := table.new(pos, 2, 8, 
             bgcolor=color.new(color.white, 85), border_width=1)
    
    // Trend analysis
    trend_fast = close > ema_fast_value ? "↗" : "↘"
    trend_medium = ema_fast_value > ema_slow_value ? "BULL" : "BEAR"
    trend_long = close > ema_long_value ? "BULL" : "BEAR"
    
    table.cell(info_table, 0, 0, "PI 3.4 Pro", bgcolor=color.new(color.blue, 80), text_color=color.white)
    table.cell(info_table, 1, 0, profile_selector, text_color=color.gray)
    
    table.cell(info_table, 0, 1, "Trend Fast", text_color=color.black)
    table.cell(info_table, 1, 1, trend_fast, text_color=close > ema_fast_value ? color.green : color.red)
    
    table.cell(info_table, 0, 2, "Trend Med", text_color=color.black)
    table.cell(info_table, 1, 2, trend_medium, text_color=ema_fast_value > ema_slow_value ? color.green : color.red)
    
    table.cell(info_table, 0, 3, "Trend Long", text_color=color.black)  
    table.cell(info_table, 1, 3, trend_long, text_color=close > ema_long_value ? color.green : color.red)
    
    table.cell(info_table, 0, 4, "Volume", text_color=color.black)
    vol_status = bar_data.high_volume ? "HIGH" : bar_data.low_volume ? "LOW" : "NORMAL"
    table.cell(info_table, 1, 4, vol_status, 
         text_color=bar_data.high_volume ? color.red : bar_data.low_volume ? color.gray : color.blue)
    
    table.cell(info_table, 0, 5, "VSA Score", text_color=color.black)
    table.cell(info_table, 1, 5, str.tostring(vsa_score, "#.#"), 
         text_color=vsa_score > 0 ? color.green : vsa_score < 0 ? color.red : color.gray)
    
    table.cell(info_table, 0, 6, "POC", text_color=color.black)
    table.cell(info_table, 1, 6, not na(poc_price) ? str.tostring(poc_price, format.mintick) : "N/A", 
         text_color=color_poc)
    
    table.cell(info_table, 0, 7, "HTF POC", text_color=color.black)
    table.cell(info_table, 1, 7, not na(poc_htf) ? str.tostring(poc_htf, format.mintick) : "N/A", 
         text_color=color_htf_poc)

show_webhook_alerts = input.bool(true, "Enable Webhook Alerts", group=GRP_DISPLAY)

// ============================================================================
// ADVANCED WEBHOOK ALERTS - JSON PAYLOAD
// ============================================================================

// Helper function to build a structured JSON string for webhook alerts
f_build_alert_json(signal_type, signal_score) =>
    // Note: PineScript does not have a native JSON library. We build the string manually.
    // The receiving server (server.py) is expected to parse this string.
    string json_template = '{{"signal":"{}", "score":{}, "symbol":"{}", "timeframe":"{}", "price":{}, "volume":{}, "vsa_score":{}, "poc":{}, "va_high":{}, "va_low":{}, "htf_poc":{}, "source":"Pi-3.4-Pro"}}'
    str.format(json_template, signal_type, str.tostring(signal_score, "#.#"), syminfo.ticker, timeframe.period, str.tostring(close), str.tostring(volume), str.tostring(vsa_score, "#.#"), str.tostring(poc_price, format.mintick), str.tostring(va_high, format.mintick), str.tostring(va_low, format.mintick), str.tostring(poc_htf, format.mintick), "Pi-3.4-Pro")

// Trigger alerts on confirmed bars
if barstate.isconfirmed and show_webhook_alerts
    string alert_message = na
    if vsa_score < -2.5
        alert_message := f_build_alert_json("Strong Bearish VSA", vsa_score)
    else if vsa_score > 2.5
        alert_message := f_build_alert_json("Strong Bullish VSA", vsa_score)
    else if is_spring
        alert_message := f_build_alert_json("Spring Signal", 3.0) // Assign a fixed score for event-based signals
    else if is_upthrust
        alert_message := f_build_alert_json("Upthrust Signal", -3.0) // Assign a fixed score

    if not na(alert_message)
        // This sends the JSON payload. In TradingView alerts, set the "Message" to {{plot("alert_json")}} and select the Webhook URL.
        alert(alert_message, freq = alert.freq_once_per_bar_close)

// ============================================================================
// CVD DIVERGENCE MARKERS (Overlay on Price Chart)
// ============================================================================

if show_cvd_div and cvd_has_bull_div
    label.new(bar_index - cvd_lookback_right, low[cvd_lookback_right] - atr_value * 0.5, 
      cvd_bull_regular ? "C+P↑" : "C+P↗", 
      color=cvd_bull_regular ? color.new(color.lime, 0) : color.new(color.lime, 50),
      textcolor=color.white,
      style=label.style_label_up,
      size=cvd_bull_regular ? size.small : size.tiny,
      tooltip="CVD+Price Divergence\n" + (cvd_bull_regular ? "Regular: Reversal signal" : "Hidden: Trend continuation"))

if show_cvd_div and cvd_has_bear_div
    label.new(bar_index - cvd_lookback_right, high[cvd_lookback_right] + atr_value * 0.5, 
      cvd_bear_regular ? "C+P↓" : "C+P↘", 
      color=cvd_bear_regular ? color.new(color.red, 0) : color.new(color.red, 50),
      textcolor=color.white,
      style=label.style_label_down,
      size=cvd_bear_regular ? size.small : size.tiny,
      tooltip="CVD+Price Divergence\n" + (cvd_bear_regular ? "Regular: Reversal signal" : "Hidden: Trend continuation"))

// ============================================================================
// ADVANCED 7-LEVEL ALERT SYSTEM (PI34 Pro Enhanced)
// ============================================================================

// Helper: Check proximity to VP levels
dist_to_poc = not na(poc_price) ? math.abs(close - poc_price) / atr_value : 999
dist_to_vah = not na(va_high) ? math.abs(close - va_high) / atr_value : 999
dist_to_val = not na(va_low) ? math.abs(close - va_low) / atr_value : 999
near_poc = dist_to_poc < 1.0
near_va = dist_to_vah < 1.0 or dist_to_val < 1.0

dist_to_htf_poc = not na(poc_htf) ? math.abs(close - poc_htf) / atr_value : 999
dist_to_htf_vah = not na(vah_htf) ? math.abs(close - vah_htf) / atr_value : 999
dist_to_htf_val = not na(val_htf) ? math.abs(close - val_htf) / atr_value : 999
near_htf_poc = dist_to_htf_poc < 1.5
near_htf_va = dist_to_htf_vah < 1.5 or dist_to_htf_val < 1.5

// VSA Aggregated Flags
has_vsa_bull = is_spring or is_selling_climax or vsa_score > 2.0
has_vsa_bear = is_upthrust or is_buying_climax or vsa_score < -2.0

// === CẤP 1: BASIC SIGNALS (50-55% Win Rate) ===
lv1_vsa_bull = alert_lv1_vsa and has_vsa_bull
lv1_vsa_bear = alert_lv1_vsa and has_vsa_bear
lv1_div_bull = alert_lv1_div and cvd_has_bull_div
lv1_div_bear = alert_lv1_div and cvd_has_bear_div

// Use alert() instead of alertcondition() for dynamic messages
if barstate.isconfirmed and enable_alerts and lv1_vsa_bull
    alert("🟢 CẤP 1: VSA BULLISH\n📊 Win rate: ~50-55%\n💡 Signal: " + (is_spring ? "Spring" : is_selling_climax ? "Selling Climax" : "VSA Score > 2") + "\n⚠️ Cần confirm với divergence hoặc VP!", alert.freq_once_per_bar_close)

if barstate.isconfirmed and enable_alerts and lv1_vsa_bear
    alert("🔴 CẤP 1: VSA BEARISH\n📊 Win rate: ~50-55%\n💡 Signal: " + (is_upthrust ? "Upthrust" : is_buying_climax ? "Buying Climax" : "VSA Score < -2") + "\n⚠️ Cần confirm với divergence hoặc VP!", alert.freq_once_per_bar_close)

if barstate.isconfirmed and enable_alerts and lv1_div_bull
    alert("🟢 CẤP 1: CVD DIVERGENCE BULL\n📊 Win rate: ~50-55%\n💡 Type: " + (cvd_bull_regular ? "Regular (Reversal)" : "Hidden (Continuation)") + "\n⚠️ Cần confirm với VSA hoặc VP!", alert.freq_once_per_bar_close)

if barstate.isconfirmed and enable_alerts and lv1_div_bear
    alert("🔴 CẤP 1: CVD DIVERGENCE BEAR\n📊 Win rate: ~50-55%\n💡 Type: " + (cvd_bear_regular ? "Regular (Reversal)" : "Hidden (Continuation)") + "\n⚠️ Cần confirm với VSA hoặc VP!", alert.freq_once_per_bar_close)

// === CẤP 2: CONFLUENCE (65-70% Win Rate) ===
lv2_vsa_vp_bull = alert_lv2_vsa_vp and has_vsa_bull and (near_poc or near_va)
lv2_vsa_vp_bear = alert_lv2_vsa_vp and has_vsa_bear and (near_poc or near_va)
lv2_div_vp_bull = alert_lv2_div_vp and cvd_has_bull_div and (near_poc or near_va)
lv2_div_vp_bear = alert_lv2_div_vp and cvd_has_bear_div and (near_poc or near_va)

alertcondition(enable_alerts and lv2_vsa_vp_bull, "LV2: VSA @ VP Bullish", 
  "🟢🟢 CẤP 2: VSA @ VOLUME PROFILE\n" +
  "📊 Win rate: ~65-70%\n" +
  "💡 VSA Signal AT " + (near_poc ? "POC" : "VA") + "\n" +
  "📍 ENTRY: Có thể vào ngay\n" +
  "🛑 STOP: Dưới " + (near_poc ? "POC" : "VAL") + "\n" +
  "✅ TARGET: 2R")

alertcondition(enable_alerts and lv2_vsa_vp_bear, "LV2: VSA @ VP Bearish", 
  "🔴🔴 CẤP 2: VSA @ VOLUME PROFILE\n" +
  "📊 Win rate: ~65-70%\n" +
  "💡 VSA Signal AT " + (near_poc ? "POC" : "VA") + "\n" +
  "📍 ENTRY: Có thể vào ngay\n" +
  "🛑 STOP: Trên " + (near_poc ? "POC" : "VAH") + "\n" +
  "✅ TARGET: 2R")

alertcondition(enable_alerts and lv2_div_vp_bull, "LV2: Divergence @ VP Bullish", 
  "🟢🟢 CẤP 2: DIVERGENCE @ VP\n" +
  "📊 Win rate: ~65-70%\n" +
  "💡 CVD Divergence AT " + (near_poc ? "POC" : "VA") + "\n" +
  "📍 ENTRY: Chờ close > " + (near_poc ? "POC" : "VAL") + "\n" +
  "✅ TARGET: 2R")

alertcondition(enable_alerts and lv2_div_vp_bear, "LV2: Divergence @ VP Bearish", 
  "🔴🔴 CẤP 2: DIVERGENCE @ VP\n" +
  "📊 Win rate: ~65-70%\n" +
  "💡 CVD Divergence AT " + (near_poc ? "POC" : "VA") + "\n" +
  "📍 ENTRY: Chờ close < " + (near_poc ? "POC" : "VAH") + "\n" +
  "✅ TARGET: 2R")

// === CẤP 3: HTF ALIGNMENT (70-75% Win Rate) ===
lv3_htf_bull = alert_lv3_htf and (has_vsa_bull or cvd_has_bull_div) and (near_htf_poc or near_htf_va)
lv3_htf_bear = alert_lv3_htf and (has_vsa_bear or cvd_has_bear_div) and (near_htf_poc or near_htf_va)

alertcondition(enable_alerts and lv3_htf_bull, "LV3: HTF Alignment Bullish", 
  "🟢🟢🟢 CẤP 3: HTF ALIGNMENT BULL\n" +
  "📊 Win rate: ~70-75%\n" +
  "💡 Signal AT HTF " + (near_htf_poc ? "POC" : "VA") + " (" + htf_timeframe + ")\n" +
  "🏔️ HTF context support!\n" +
  "📍 ENTRY: Vào ngay\n" +
  "🛑 STOP: Dưới HTF " + (near_htf_poc ? "POC" : "VAL") + "\n" +
  "✅ TARGET: 2.5R")

alertcondition(enable_alerts and lv3_htf_bear, "LV3: HTF Alignment Bearish", 
  "🔴🔴🔴 CẤP 3: HTF ALIGNMENT BEAR\n" +
  "📊 Win rate: ~70-75%\n" +
  "💡 Signal AT HTF " + (near_htf_poc ? "POC" : "VA") + " (" + htf_timeframe + ")\n" +
  "🏔️ HTF context resistance!\n" +
  "📍 ENTRY: Vào ngay\n" +
  "🛑 STOP: Trên HTF " + (near_htf_poc ? "POC" : "VAH") + "\n" +
  "✅ TARGET: 2.5R")

// === CẤP 4: VOLUME EXTREME (75-80% Win Rate) ===
lv4_vol_bull = alert_lv4_vol and vol_is_ultra_high and (has_vsa_bull or cvd_has_bull_div) and (near_poc or near_va)
lv4_vol_bear = alert_lv4_vol and vol_is_ultra_high and (has_vsa_bear or cvd_has_bear_div) and (near_poc or near_va)

alertcondition(enable_alerts and lv4_vol_bull, "LV4: Volume Extreme Bullish", 
  "🟢🟢🟢🟢 CẤP 4: VOLUME EXTREME BULL\n" +
  "📊 Win rate: ~75-80%\n" +
  "💡 Ultra High Volume (Z-Score: " + str.tostring(vol_zscore_value, "#.##") + ")\n" +
  "📊 VSA/Div AT VP level\n" +
  "🔥 INSTITUTIONAL ACTIVITY!\n" +
  "📍 ENTRY: VÀO NGAY!\n" +
  "🛑 STOP: Tight (0.5R)\n" +
  "✅ TARGET: 3R")

alertcondition(enable_alerts and lv4_vol_bear, "LV4: Volume Extreme Bearish", 
  "🔴🔴🔴🔴 CẤP 4: VOLUME EXTREME BEAR\n" +
  "📊 Win rate: ~75-80%\n" +
  "💡 Ultra High Volume (Z-Score: " + str.tostring(vol_zscore_value, "#.##") + ")\n" +
  "📊 VSA/Div AT VP level\n" +
  "🔥 INSTITUTIONAL DUMP!\n" +
  "📍 ENTRY: VÀO NGAY!\n" +
  "🛑 STOP: Tight (0.5R)\n" +
  "✅ TARGET: 3R")

// === CẤP 5: TRIPLE CONFLUENCE (80-85% Win Rate - HOLY GRAIL) ===
lv5_triple_bull = alert_lv5_triple and has_vsa_bull and cvd_has_bull_div and (near_poc or near_va)
lv5_triple_bear = alert_lv5_triple and has_vsa_bear and cvd_has_bear_div and (near_poc or near_va)

alertcondition(enable_alerts and lv5_triple_bull, "LV5: TRIPLE CONFLUENCE BULL (Holy Grail)", 
  "🟢🟢🟢🟢🟢 CẤP 5: TRIPLE CONFLUENCE - HOLY GRAIL!\n" +
  "━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n" +
  "✅ VSA Signal: " + (is_spring ? "Spring" : "Bullish") + "\n" +
  "✅ CVD Divergence: " + (cvd_bull_regular ? "Regular" : "Hidden") + "\n" +
  "✅ Volume Profile: AT " + (near_poc ? "POC" : "VA") + "\n" +
  "━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n" +
  "🎯 Win rate: 80-85% (CHẮC ĂN NHẤT!)\n" +
  "💰 Risk: 2% vốn (TĂNG LÊN!)\n" +
  "🔥 Setup hiếm, 1-3 lần/tháng!\n\n" +
  "📍 ENTRY: VÀO NGAY không chờ!\n" +
  "🛑 STOP: Dưới " + (near_poc ? "POC" : "VAL") + "\n" +
  "✅ TARGET:\n" +
  "  • 50% @ 2R\n" +
  "  • 30% @ 3R\n" +
  "  • 20% trail tới 5R+\n\n" +
  "🚀 ALL-IN MINDSET!\n" +
  "💎 Đây là cơ hội vàng!")

alertcondition(enable_alerts and lv5_triple_bear, "LV5: TRIPLE CONFLUENCE BEAR (Holy Grail)", 
  "🔴🔴🔴🔴🔴 CẤP 5: TRIPLE CONFLUENCE - HOLY GRAIL!\n" +
  "━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n" +
  "✅ VSA Signal: " + (is_upthrust ? "Upthrust" : "Bearish") + "\n" +
  "✅ CVD Divergence: " + (cvd_bear_regular ? "Regular" : "Hidden") + "\n" +
  "✅ Volume Profile: AT " + (near_poc ? "POC" : "VA") + "\n" +
  "━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n" +
  "🎯 Win rate: 80-85% (CHẮC ĂN NHẤT!)\n" +
  "💰 Risk: 2% vốn (TĂNG LÊN!)\n" +
  "🔥 Setup hiếm, 1-3 lần/tháng!\n\n" +
  "📍 ENTRY: VÀO NGAY không chờ!\n" +
  "🛑 STOP: Trên " + (near_poc ? "POC" : "VAH") + "\n" +
  "✅ TARGET:\n" +
  "  • 50% @ 2R\n" +
  "  • 30% @ 3R\n" +
  "  • 20% trail tới 5R+\n\n" +
  "🚀 ALL-IN MINDSET!\n" +
  "💎 Đây là cơ hội vàng!")

// Legacy alerts for users not using webhooks (optional)
alertcondition(is_spring, "Spring Signal", "Spring pattern detected")
alertcondition(is_upthrust, "Upthrust Signal", "Upthrust pattern detected") 
alertcondition(vsa_score > 2.5, "Strong Bullish VSA", "Strong bullish VSA confluence")
alertcondition(vsa_score < -2.5, "Strong Bearish VSA", "Strong bearish VSA confluence")