// ¬© 2025 Gemini AI - PI v2.1 Fixed (No LinePool System)
// @version=5
indicator("PI v2.5", shorttitle="PI v2.5", overlay=true, max_labels_count=500)

// === GREG'S WAY (GW) - PH·∫¶N 0: KHAI B√ÅO & C·∫§U H√åNH C·ªêT L√ïI ===
var float VALUE_AREA_PERCENT = 0.7
var float CLIMAX_VOL_THRESHOLD = 0.95
var float DEFAULT_CLOSE_LOCATION = 0.5
var float MIN_PRICE_RANGE = 0.00001
var int VA_UPDATE_INTERVAL = 10
var float VA_PRICE_MOVE_THRESHOLD = 0.03

// S·ª≠a khai b√°o type - m·ªói field tr√™n m·ªôt d√≤ng
type BarAnalysis
    bool isUp
    bool isDown
    bool isNarrow
    bool isWide
    bool isHighVol
    bool isLowVol
    float location

// === PH·∫¶N 1: B·∫¢NG ƒêI·ªÄU KHI·ªÇN & C√ÄI ƒê·∫∂T ===
var string GRP_DISPLAY = "üé® Giao Dien & Hien Thi"
showInfoPanel = input.bool(false, "Bang Thong Tin", group=GRP_DISPLAY)
dashboardPosition = input.string("top_right", "Vi tri Dashboard", options=["top_left", "top_center", "top_right", "middle_left", "middle_center", "middle_right", "bottom_left", "bottom_center", "bottom_right"], group=GRP_DISPLAY)
showBackground = input.bool(false, "To Nen Tin Hieu Manh", group=GRP_DISPLAY)
showScoreOnBars = input.bool(false, "Hien Thi Diem VSA", group=GRP_DISPLAY)

var string GRP_SCORE_LABEL = "üìä T√πy Ch·ªânh Nh√£n ƒêi·ªÉm VSA"
scoreLabelOffset = input.float(0.2, "Kho·∫£ng c√°ch (x ATR)", group=GRP_SCORE_LABEL, minval=0, step=0.05)
scoreLabelBullColor = input.color(color.new(color.green, 25), "M√†u ƒëi·ªÉm TƒÉng", group=GRP_SCORE_LABEL)
scoreLabelBearColor = input.color(color.new(color.red, 25), "M√†u ƒëi·ªÉm Gi·∫£m", group=GRP_SCORE_LABEL)

var string GRP_VP = "üìä Value Area"
showVALines = input.bool(true, "Hien thi POC, VAH, VAL", group=GRP_VP)
vpLookback = input.int(50, "Do dai tinh VA", group=GRP_VP, minval=20, maxval=200)
vpProximityPercent = input.float(0.3, "Bien do Tim kiem quanh VA (%)", group=GRP_VP, minval=0.1, maxval=2.0, step=0.1)

var string GRP_TR_LINES = "üìà Duong Trading Range"
showTRLines = input.bool(true, "Ve Duong S/R tu dong", group=GRP_TR_LINES)
trLineOffset = input.int(20, "Do dai ke duong", group=GRP_TR_LINES, minval=5, maxval=50)

var string GRP_SIGNALS = "üéØ Cau Hinh Tin Hieu"
enableSpringUpthrust = input.bool(true, "Spring & Upthrust", group=GRP_SIGNALS)
enableClimacticVol = input.bool(true, "Volume Cuc Dai (Climax)", group=GRP_SIGNALS)
enableNoSupplyDemand = input.bool(true, "No Supply & No Demand", group=GRP_SIGNALS)
enableStoppingVol = input.bool(true, "Stopping Volume", group=GRP_SIGNALS)
enableEffortVsResult = input.bool(true, "No Luc vs Ket Qua", group=GRP_SIGNALS)
enableShakeout = input.bool(true, "Shakeout", group=GRP_SIGNALS)
enableSOS_SOW = input.bool(true, "Sign of Strength/Weakness", group=GRP_SIGNALS)
enableTestBar = input.bool(true, "Test Bar", group=GRP_SIGNALS)

var string GRP_PARAMS = "‚öôÔ∏è Tham So Chien Luoc"
lookbackH_L = input.int(12, "Do dai tim H/L (Spring/UT)", group=GRP_PARAMS, minval=5, maxval=100)
volLookback = input.int(20, "Do dai tinh Volume TB", group=GRP_PARAMS)
volMultiplier = input.float(1.8, "He so Volume Cao", group=GRP_PARAMS, step=0.1)
lowVolMultiplier = input.float(0.6, "He so Volume Thap", group=GRP_PARAMS, step=0.1)
climaxLookback = input.int(40, "Do dai tim Volume Climax", group=GRP_PARAMS)
scoreLookback = input.int(10, "Do dai tinh Diem VSA", group=GRP_PARAMS)
narrowRangeFactor = input.float(0.7, "He so Nen Hep (Narrow)", group=GRP_PARAMS)
wideRangeFactor = input.float(1.3, "He so Nen Rong (Wide)", group=GRP_PARAMS)
bullishCloseLocation = input.float(0.6, "Nguong Dong cua Bullish", group=GRP_PARAMS, step=0.1)
bearishCloseLocation = input.float(0.4, "Nguong Dong cua Bearish", group=GRP_PARAMS, step=0.1)

var string GRP_TREND = "üåä He Thong Dan Duong"
useDualEMA = input.bool(true, "Su dung He thong EMA Kep", group=GRP_TREND)
emaFastLength = input.int(21, "EMA Nhanh", group=GRP_TREND)
emaFastColor = input.color(color.aqua, "M√†u", group=GRP_TREND)
emaSlowLength = input.int(50, "EMA Cham", group=GRP_TREND)
emaSlowColor = input.color(color.orange, "M√†u", group=GRP_TREND)
showEmaCloud = input.bool(true, "Hien thi Dam may Xu huong", group=GRP_TREND)
useEma200 = input.bool(true, "Su dung EMA 200 (Boi canh)", group=GRP_TREND)
emaLength200 = input.int(200, "EMA 200", group=GRP_TREND)
ema200Color = input.color(color.gray, "M√†u", group=GRP_TREND)

// === PH·∫¶N 2: KH·ªûI T·∫†O & H√ÄM TI·ªÜN √çCH ===
var float cached_dPOC = na
var float cached_dVAH = na
var float cached_dVAL = na
var int last_va_bar = 0
var bool va_cache_valid = false

f_safeDivision(n, d) => d > MIN_PRICE_RANGE ? n / d : na

// S·ª≠a h√†m f_safeSum - c√∫ ph√°p v√≤ng l·∫∑p for
f_safeSum(source, length) =>
    _sum = 0.0
    lookback_len = math.min(length - 1, bar_index)
    if lookback_len >= 0
        for i = 0 to lookback_len
            _sum += nz(source[i])
    _sum

// Helper: n·ªëi chu·ªói cho m·∫£ng string (thay array.join)
f_join(arr_id, sep) =>
    _txt = ""
    arr_sz = array.size(arr_id)
    if arr_sz > 0
        for i = 0 to arr_sz - 1
            _txt += array.get(arr_id, i)
            if i < arr_sz - 1
                _txt += sep
    _txt

// Helper: percentile volume trong lookback
f_vol_percentile(len) =>
    float rank = 0.0
    for i = 1 to len
        rank += volume > volume[i] ? 1.0 : 0.0
    rank / len * 100.0

f_analyzeBar() =>
    _range = high - low
    _avgVolume = ta.sma(volume, volLookback)
    _isNarrow = _range < ta.sma(_range, volLookback) * narrowRangeFactor
    _isWide = _range > ta.sma(_range, volLookback) * wideRangeFactor
    _isHighVol = volume > _avgVolume * volMultiplier
    _isLowVol = volume < _avgVolume * lowVolMultiplier
    _location = f_safeDivision(close - low, _range)
    BarAnalysis.new(close > open, close < open, _isNarrow, _isWide, _isHighVol, _isLowVol, nz(_location, 0.5))

f_isNearVA(price) =>
    if not va_cache_valid or na(cached_dPOC)
        false
    else
        pocDiff = f_safeDivision(math.abs(price - cached_dPOC), cached_dPOC)
        vahDiff = f_safeDivision(math.abs(price - cached_dVAH), cached_dVAH)
        valDiff = f_safeDivision(math.abs(price - cached_dVAL), cached_dVAL)
        (not na(pocDiff) and pocDiff < vpProximityPercent / 100) or (not na(vahDiff) and vahDiff < vpProximityPercent / 100) or (not na(valDiff) and valDiff < vpProximityPercent / 100)

f_calculateValueArea() =>
    rowCount = 200
    lookback_high = ta.highest(high, vpLookback)
    lookback_low = ta.lowest(low, vpLookback)
    step_price = f_safeDivision(lookback_high - lookback_low, rowCount - 1)
    
    if na(step_price) or step_price <= MIN_PRICE_RANGE
        [close, lookback_high, lookback_low]
    else
        price_rows = array.new<float>(rowCount, 0)
        volume_rows = array.new<float>(rowCount, 0)
        array.fill(volume_rows, 0)
        
        for i = 0 to rowCount - 1
            array.set(price_rows, i, lookback_low + step_price * i)
        
        total_volume = 0.0
        for i = 0 to math.min(vpLookback - 1, bar_index)
            bar_high = high[i]
            bar_low = low[i]
            bar_vol = nz(volume[i])
            total_volume += bar_vol
            
            start_index = math.max(0, math.round(f_safeDivision(bar_low - lookback_low, step_price)))
            end_index = math.min(rowCount - 1, math.round(f_safeDivision(bar_high - lookback_low, step_price)))
            
            if start_index <= end_index
                rows_in_bar = end_index - start_index + 1
                vol_per_row = bar_vol / rows_in_bar
                for j = start_index to end_index
                    current_vol = array.get(volume_rows, j)
                    array.set(volume_rows, j, current_vol + vol_per_row)
        
        poc_volume = array.max(volume_rows)
        poc_index = na(poc_volume) ? na : array.indexof(volume_rows, poc_volume)
        _dPOC = na(poc_index) ? close : array.get(price_rows, poc_index)
        
        va_volume_target = total_volume * VALUE_AREA_PERCENT
        va_volume_current = nz(poc_volume)
        up_index = nz(poc_index, 0) + 1
        down_index = nz(poc_index, 0) - 1
        
        while va_volume_current < va_volume_target and (up_index < rowCount or down_index >= 0)
            vol_up = up_index < rowCount ? array.get(volume_rows, up_index) : 0
            vol_down = down_index >= 0 ? array.get(volume_rows, down_index) : 0
            
            if vol_up == 0 and vol_down == 0
                break
                
            if vol_up >= vol_down and up_index < rowCount
                va_volume_current += vol_up
                up_index += 1
            else if down_index >= 0
                va_volume_current += vol_down
                down_index -= 1
            else
                up_index += 1
        
        _dVAH = up_index > nz(poc_index, 0) ? array.get(price_rows, math.min(rowCount - 1, up_index - 1)) : _dPOC
        _dVAL = down_index < nz(poc_index, 0) ? array.get(price_rows, math.max(0, down_index + 1)) : _dPOC
        
        if _dVAH < _dPOC
            _dVAH := _dPOC + (step_price * 5)
        if _dVAL > _dPOC
            _dVAL := _dPOC - (step_price * 5)
        
        [_dPOC, _dVAH, _dVAL]

// === PH·∫¶N 3: V√íNG L·∫∂P T√çNH TO√ÅN CH√çNH ===
bar = f_analyzeBar()
fastEMA = ta.ema(close, emaFastLength)
slowEMA = ta.ema(close, emaSlowLength)
ema200 = ta.ema(close, emaLength200)
isUptrend = useDualEMA ? fastEMA > slowEMA : close > ema200

lowest_low_val = ta.lowest(low, lookbackH_L)[1]
highest_high_val = ta.highest(high, lookbackH_L)[1]
highest_vol_val = ta.highest(volume, climaxLookback)

atr14 = ta.atr(14)
avgRange = ta.sma(high - low, volLookback)
isWideNow = (high - low) > avgRange * wideRangeFactor
isNarrowNow = (high - low) < avgRange * narrowRangeFactor
volPR = f_vol_percentile(climaxLookback)

// Update VA m·ªói bar ƒë·ªÉ ƒë·∫£m b·∫£o lu√¥n c√≥ data
[newPOC, newVAH, newVAL] = f_calculateValueArea()
if not na(newPOC)
    cached_dPOC := newPOC
    cached_dVAH := newVAH
    cached_dVAL := newVAL
    va_cache_valid := true
    last_va_bar := bar_index

float barScore = 0.0

// S·ª≠a kh·ªüi t·∫°o array
var bullish_signals_on_bar = array.new<string>()
var bearish_signals_on_bar = array.new<string>()

array.clear(bullish_signals_on_bar)
array.clear(bearish_signals_on_bar)

// Kh·ªüi t·∫°o c·ªù t√≠n hi·ªáu
bool isSpring = false
bool isUpthrust = false
bool isSellingClimax = false
bool isBuyingClimax = false
bool isStoppingVol = false
bool isEffortVsFall = false
bool isEffortVsRise = false
bool isShakeout = false
bool isSOS = false
bool isSOW = false
bool isTestBar = false
bool isNoSupply = false
bool isNoDemand = false

// VSA SIGNAL DETECTION (tinh ch·ªânh logic, kh√¥ng ƒë·ªïi t√≠nh nƒÉng)
if barstate.isconfirmed
    // SPRING / UPTHRUST
    isSpring := enableSpringUpthrust and bar.isDown and low < lowest_low_val and close > lowest_low_val and bar.location > bullishCloseLocation and bar.isHighVol and isWideNow
    isUpthrust := enableSpringUpthrust and bar.isUp and high > highest_high_val and close < highest_high_val and bar.location < bearishCloseLocation and bar.isHighVol and isWideNow
    
    // CLIMAX theo percentile
    isSellingClimax := enableClimacticVol and bar.isDown and isWideNow and volPR >= 95
    isBuyingClimax  := enableClimacticVol and bar.isUp   and isWideNow and volPR >= 95

    // STOPPING VOLUME
    isStoppingVol := enableStoppingVol and bar.isDown and (bar.isHighVol or volPR >= 85) and bar.location >= bullishCloseLocation and (high - low) >= avgRange

    // EFFORT vs RESULT
    isEffortVsFall := enableEffortVsResult and bar.isDown and (bar.isHighVol or volPR >= 75) and isNarrowNow
    isEffortVsRise := enableEffortVsResult and bar.isUp   and (bar.isHighVol or volPR >= 75) and isNarrowNow

    // SOS / SOW v·ªõi VA
    isSOS := enableSOS_SOW and bar.isUp and (bar.isHighVol or volPR >= 75) and bar.location > 0.7 and (va_cache_valid ? (close > nz(cached_dVAH, cached_dPOC)) : true)
    isSOW := enableSOS_SOW and bar.isDown and (bar.isHighVol or volPR >= 75) and bar.location < 0.3 and (va_cache_valid ? (close < nz(cached_dVAL, cached_dPOC)) : true)

    // NO SUPPLY / NO DEMAND
    isNoSupply := enableNoSupplyDemand and bar.isDown and isNarrowNow and (volume < math.min(volume[1], volume[2]) * 0.9)
    isNoDemand := enableNoSupplyDemand and bar.isUp   and isNarrowNow and (volume < math.min(volume[1], volume[2]) * 0.9)

    // TEST: sau s·ª©c m·∫°nh g·∫ßn (1‚Äì3 bar)
    recentStrength = (nz(isSpring[1]) or nz(isSellingClimax[1]) or nz(isStoppingVol[1]) or nz(isSOS[1]) or nz(isSpring[2]) or nz(isSellingClimax[2]) or nz(isStoppingVol[2]) or nz(isSOS[2]) or nz(isSpring[3]) or nz(isSellingClimax[3]) or nz(isStoppingVol[3]) or nz(isSOS[3]))
    isTestBar := enableTestBar and bar.isDown and isNarrowNow and (volume < math.min(volume[1], volume[2]) * 0.9) and bar.location > bullishCloseLocation and recentStrength

    // C·ªông ƒëi·ªÉm & icon (gi·ªØ nguy√™n c∆° ch·∫ø)
    if isSpring
        array.push(bullish_signals_on_bar, "üî∫")
        barScore += 2.5
    if isSellingClimax
        array.push(bullish_signals_on_bar, "üî¥")
        barScore += 2.0
    if isStoppingVol
        array.push(bullish_signals_on_bar, "‚èπÔ∏è")
        barScore += 2.2
    if isEffortVsFall
        array.push(bullish_signals_on_bar, "‚ÜóÔ∏è")
        barScore += 2.0
    if isShakeout
        array.push(bullish_signals_on_bar, "‚ö†Ô∏è")
        barScore += 2.2
    if isSOS
        array.push(bullish_signals_on_bar, "üìà")
        barScore += 2.4
    if isTestBar
        array.push(bullish_signals_on_bar, "‚ÜîÔ∏è")
        barScore += 1.5
    if isNoSupply
        array.push(bullish_signals_on_bar, "üî∏")
        barScore += 1.0
    if isUpthrust
        array.push(bearish_signals_on_bar, "üîª")
        barScore -= 2.5
    if isBuyingClimax
        array.push(bearish_signals_on_bar, "üü¢")
        barScore -= 2.0
    if isEffortVsRise
        array.push(bearish_signals_on_bar, "‚ÜòÔ∏è")
        barScore -= 2.0
    if isSOW
        array.push(bearish_signals_on_bar, "üìâ")
        barScore -= 2.4
    if isNoDemand
        array.push(bearish_signals_on_bar, "üîπ")
        barScore -= 1.0

vsaScore = f_safeSum(barScore, scoreLookback)

// === PH·∫¶N 4: HI·ªÇN TH·ªä & GIAO DI·ªÜN NG∆Ø·ªúI D√ôNG ===
p_ema200 = plot(useEma200 ? ema200 : na, "EMA 200", ema200Color, 1)
p_fast = plot(useDualEMA ? fastEMA : na, "EMA Nhanh", emaFastColor, 1)
p_slow = plot(useDualEMA ? slowEMA : na, "EMA Cham", emaSlowColor, 1)

fill(p_fast, p_slow, color=useDualEMA and showEmaCloud ? (fastEMA > slowEMA ? color.new(color.green, 85) : color.new(color.red, 85)) : na)

// === V·∫º VALUE AREA B·∫∞NG PLOT (D√çNH V·ªöI N·∫æN) ===
plot(showVALines ? cached_dPOC : na, "POC", color.red, 1, plot.style_line)
plot(showVALines ? cached_dVAH : na, "VAH", color.blue, 1, plot.style_line)
plot(showVALines ? cached_dVAL : na, "VAL", color.blue, 1, plot.style_line)

bgcolor(showBackground and math.abs(vsaScore) > 2.5 ? (vsaScore > 0 ? color.new(color.green, 40) : color.new(color.red, 40)) : na)

// === TRADING RANGE MARKS (KH√îNG D√ôNG LinePool) ===
plotchar(showTRLines and isSpring, "Spring", "‚ñ≤", location.belowbar, color.green, size=size.tiny)
plotchar(showTRLines and isUpthrust, "Upthrust", "‚ñº", location.abovebar, color.red, size=size.tiny)

// === SIGNAL LABELS ===
if array.size(bullish_signals_on_bar) > 0
    bullish_text = f_join(bullish_signals_on_bar, "+")
    shouldShowStar = isSellingClimax
    finalBullText = shouldShowStar ? bullish_text + "‚≠ê" : bullish_text
    labelPrice = low - (atr14 * 0.5)
    label.new(bar_index, labelPrice, finalBullText, style=label.style_none, yloc=yloc.price,
              color=color.new(color.gray, 30), textcolor=color.black, size=size.normal)

if array.size(bearish_signals_on_bar) > 0
    bearish_text = f_join(bearish_signals_on_bar, "+")
    shouldShowStar = isBuyingClimax
    finalBearText = shouldShowStar ? bearish_text + "‚≠ê" : bearish_text
    labelPrice = high + (atr14 * 0.8)
    label.new(bar_index, labelPrice, finalBearText, style=label.style_none, yloc=yloc.price,
              color=color.new(color.gray, 30), textcolor=color.black, size=size.normal)

// === SCORE LABELS ===
if showScoreOnBars and vsaScore != 0
    scoreOffset = vsaScore > 0 ? -(atr14 * 0.8) : (atr14 * 0.8)
    scoreLabelPrice = vsaScore > 0 ? low + scoreOffset : high + scoreOffset
    scoreTextColor = vsaScore > 0 ? color.blue : color.maroon
    label.new(bar_index, scoreLabelPrice, str.tostring(vsaScore, "#.#"), style=label.style_none, yloc=yloc.price,
              color=color.new(color.gray, 30), textcolor=scoreTextColor, size=size.small)

// === DASHBOARD ===
var table infoTable = na
if showInfoPanel and barstate.islast
    tablePosition = switch dashboardPosition
        "top_left" => position.top_left
        "top_center" => position.top_center
        "top_right" => position.top_right
        "middle_left" => position.middle_left
        "middle_center" => position.middle_center
        "middle_right" => position.middle_right
        "bottom_left" => position.bottom_left
        "bottom_center" => position.bottom_center
        "bottom_right" => position.bottom_right
        => position.top_right
    
    if na(infoTable)
        infoTable := table.new(tablePosition, 2, 6, bgcolor=color.new(color.gray, 85), border_width=1)
    
    table.cell(infoTable, 0, 0, "VSA ANALYSIS", text_color=color.orange, bgcolor=color.black)
    table.cell(infoTable, 1, 0, timeframe.period, text_color=color.aqua, bgcolor=color.black)
    table.cell(infoTable, 0, 1, "Trend:", text_color=color.black)
    table.cell(infoTable, 0, 2, "VSA Score:", text_color=color.black)
    table.cell(infoTable, 0, 3, "Volume:", text_color=color.black)
    table.cell(infoTable, 0, 4, "Range:", text_color=color.black)
    table.cell(infoTable, 0, 5, "Near VA:", text_color=color.black)
    table.cell(infoTable, 1, 1, isUptrend ? "BULLISH" : "BEARISH", text_color=isUptrend ? color.green : color.red)
    table.cell(infoTable, 1, 2, str.tostring(vsaScore, "#.##"), text_color=vsaScore > 0 ? color.green : vsaScore < 0 ? color.red : color.gray)
    table.cell(infoTable, 1, 3, bar.isHighVol ? "HIGH" : bar.isLowVol ? "LOW" : "NORMAL", text_color=bar.isHighVol ? color.red : bar.isLowVol ? color.gray : color.blue)
    table.cell(infoTable, 1, 4, bar.isWide ? "WIDE" : bar.isNarrow ? "NARROW" : "NORMAL", text_color=bar.isWide ? color.orange : bar.isNarrow ? color.gray : color.blue)
    table.cell(infoTable, 1, 5, f_isNearVA(close) ? "YES" : "NO", text_color=f_isNearVA(close) ? color.red : color.gray)

// === ALERTS ===
alertcondition(vsaScore > 3.0, "VSA Bullish Strong", "VSA Bullish Signal Detected")
alertcondition(vsaScore < -3.0, "VSA Bearish Strong", "VSA Bearish Signal Detected")
