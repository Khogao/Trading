//@version=5
indicator("VSA-Wyckoff Analyst (TF Presets)", shorttitle="VW-Analyst", overlay=true, max_labels_count=300)

// ========== KI·ªÇU D·ªÆ LI·ªÜU ==========
type VolumeContext
    float current
    float average
    float median
    float percentileRank
    bool isHigh
    bool isLow
    bool isExtreme

type BarCharacteristics
    float barRange
    float avgRange
    float closeLocation
    bool isNarrow
    bool isWide
    bool isUp
    bool isDown
    VolumeContext volume

type VSASignal
    string name
    string type  // "bullish" | "bearish"
    float strength  // 0.0 .. 5.0
    array<string> reasons
    bool isValid

// ========== PRESET THEO TF ==========
var string GRP_TF = "üß≠ Presets theo Khung th·ªùi gian"
tf_mode = input.string("Auto theo TF", "Ch·∫ø ƒë·ªô Preset", options=["Auto theo TF","Manual override"], group=GRP_TF)
manual_volLookback  = input.int(20, "Manual ‚Ä¢ Volume Lookback", minval=5, maxval=200, group=GRP_TF)
manual_swingLookback= input.int(10, "Manual ‚Ä¢ Swing Lookback",  minval=3, maxval=200, group=GRP_TF)
manual_highVolThr   = input.float(1.5, "Manual ‚Ä¢ High Vol √óSMA", minval=1.0, step=0.1, group=GRP_TF)
manual_lowVolThr    = input.float(0.7, "Manual ‚Ä¢ Low Vol √óSMA",  maxval=1.0, step=0.05, group=GRP_TF)

// Tr·∫£ v·ªÅ b·ªô tham s·ªë theo TF ƒëang m·ªü
f_tf_presets() =>
    // M·∫∑c ƒë·ªãnh
    int vLook = 20
    int sLook = 10
    float hiT = 1.5
    float loT = 0.7
    // Ph√¢n nh√°nh theo TF
    // 1m
    if timeframe.isminutes and timeframe.multiplier == 1
        vLook := 30, sLook := 12, hiT := 1.6, loT := 0.65
    // 3m
    else if timeframe.isminutes and timeframe.multiplier == 3
        vLook := 28, sLook := 12, hiT := 1.55, loT := 0.68
    // 5m
    else if timeframe.isminutes and timeframe.multiplier == 5
        vLook := 26, sLook := 12, hiT := 1.5, loT := 0.7
    // 15m
    else if timeframe.isminutes and timeframe.multiplier == 15
        vLook := 24, sLook := 12, hiT := 1.45, loT := 0.72
    // 30m
    else if timeframe.isminutes and timeframe.multiplier == 30
        vLook := 22, sLook := 12, hiT := 1.4, loT := 0.75
    // 1H
    else if timeframe.isminutes and timeframe.multiplier == 60
        vLook := 22, sLook := 14, hiT := 1.4, loT := 0.75
    // 4H
    else if timeframe.isminutes and timeframe.multiplier == 240
        vLook := 20, sLook := 18, hiT := 1.35, loT := 0.78
    // 1D
    else if timeframe.isdaily
        vLook := 20, sLook := 20, hiT := 1.3, loT := 0.8
    // Manual override
    if tf_mode == "Manual override"
        vLook := manual_volLookback
        sLook := manual_swingLookback
        hiT := manual_highVolThr
        loT := manual_lowVolThr
    [vLook, sLook, hiT, loT]

// L·∫•y preset hi·ªán t·∫°i
[vLookCur, sLookCur, hiVolThrCur, loVolThrCur] = f_tf_presets()

// ========== C√ÄI ƒê·∫∂T C·ªêT L√ïI ==========
var string GRP_VSA = "üéØ VSA - C√†i ƒë·∫∑t C·ªët l√µi"
trendLength = input.int(50, "EMA Xu h∆∞·ªõng", group=GRP_VSA, minval=10)
minConfluence = input.int(1, "S·ªë t√≠n hi·ªáu t·ªëi thi·ªÉu ƒë·ªÉ hi·ªÉn th·ªã", group=GRP_VSA, minval=1, maxval=6)

var string GRP_FILTER = "üîç B·ªô l·ªçc"
useTrendFilter   = input.bool(true, "L·ªçc theo xu h∆∞·ªõng EMA", group=GRP_FILTER)
useVolumeFilter  = input.bool(true, "L·ªçc theo ch·∫•t l∆∞·ª£ng Volume", group=GRP_FILTER)
liqHoursFilter   = input.bool(false, "Crypto/liquidity hours (t√πy ch·ªçn)", group=GRP_FILTER)

// B·∫≠t/t·∫Øt m·∫´u h√¨nh
var string GRP_TOGGLES = "üö¶ B·∫≠t/T·∫Øt M·∫´u h√¨nh VSA"
enableSpringUpthrust = input.bool(true, "1. Spring / Upthrust", group=GRP_TOGGLES)
enableClimax         = input.bool(true, "2. Buying / Selling Climax", group=GRP_TOGGLES)
enableStoppingVol    = input.bool(true, "3. Stopping Volume", group=GRP_TOGGLES)
enableShakeout       = input.bool(true, "4. Shakeout", group=GRP_TOGGLES)
enableEffortResult   = input.bool(true, "5. Effort vs Result", group=GRP_TOGGLES)
enableNoSupplyDemand = input.bool(true, "6. No Supply / No Demand", group=GRP_TOGGLES)
enableTestBar        = input.bool(true, "7. Test Bar", group=GRP_TOGGLES)

// Ng∆∞·ª°ng s·ª©c m·∫°nh
var string GRP_CUSTOMIZE = "üéõÔ∏è Ng∆∞·ª°ng S·ª©c m·∫°nh T√≠n hi·ªáu"
springStrength        = input.float(2.5, "Spring Min Strength", group=GRP_CUSTOMIZE, minval=1.0, maxval=5.0, step=0.1)
upthrustStrength      = input.float(2.5, "Upthrust Min Strength", group=GRP_CUSTOMIZE, minval=1.0, maxval=5.0, step=0.1)
climaxStrength        = input.float(3.0, "Climax Min Strength", group=GRP_CUSTOMIZE, minval=1.0, maxval=5.0, step=0.1)
stoppingVolStrength   = input.float(2.0, "Stopping Volume Min Strength", group=GRP_CUSTOMIZE, minval=1.0, maxval=5.0, step=0.1)
shakeoutStrength      = input.float(2.5, "Shakeout Min Strength", group=GRP_CUSTOMIZE, minval=1.0, maxval=5.0, step=0.1)
effortResultStrength  = input.float(2.0, "Effort/Result Min Strength", group=GRP_CUSTOMIZE, minval=1.0, maxval=5.0, step=0.1)
noSupplyDemandStrength= input.float(1.5, "No Supply/Demand Min Strength", group=GRP_CUSTOMIZE, minval=1.0, maxval=5.0, step=0.1)
climaxVolThresholdPct = input.float(90.0, "Climax Volume Threshold (%)", group=GRP_CUSTOMIZE, minval=80.0, maxval=99.0)

// Hi·ªÉn th·ªã
var string GRP_DISPLAY = "üé® Hi·ªÉn th·ªã"
showLabels     = input.bool(true, "Hi·ªÉn th·ªã nh√£n", group=GRP_DISPLAY)
showBackground = input.bool(false, "T√¥ m√†u n·ªÅn theo confluence", group=GRP_DISPLAY)
showDashboard  = input.bool(true, "B·∫£ng ƒëi·ªÅu khi·ªÉn", group=GRP_DISPLAY)

// ========== H√ÄM PH·ª§ ==========
f_percentile_rank(src, len) =>
    float rank = 0.0
    for i = 1 to len
        rank += src > src[i] ? 1.0 : 0.0
    rank / len * 100.0

f_getVolumeContext() =>
    current = volume
    average = ta.sma(volume, vLookCur)
    median  = ta.median(volume, vLookCur)
    pr      = f_percentile_rank(volume, vLookCur)
    isHigh  = current > average * hiVolThrCur
    isLow   = current < average * loVolThrCur
    isExtreme = pr > 90 or pr < 10
    VolumeContext.new(current, average, median, pr, isHigh, isLow, isExtreme)

f_getBarCharacteristics(vol_ctx) =>
    barRange = high - low
    avgRange = ta.atr(14)
    closeLocation = barRange > 0 ? (close - low) / barRange : 0.5
    isNarrow = barRange < avgRange * 0.7
    isWide   = barRange > avgRange * 1.3
    isUp     = close > open
    isDown   = close < open
    BarCharacteristics.new(barRange, avgRange, closeLocation, isNarrow, isWide, isUp, isDown, vol_ctx)

// Ch·∫•t l∆∞·ª£ng volume (·ªïn ƒë·ªãnh, kh√¥ng spike c·ª±c ƒëoan, v√† gi·ªù thanh kho·∫£n ‚Äì t√πy ch·ªçn)
f_getVolumeQuality() =>
    vol_ma20   = ta.sma(volume, 20)
    vol_sd20   = ta.stdev(volume, 20)
    isSpike    = volume > (vol_ma20 + 3.0 * vol_sd20)
    cv5        = ta.sma(volume, 5) > 0 ? ta.stdev(volume, 5) / ta.sma(volume, 5) : 1.0
    isStable   = cv5 < 0.8
    hourUTC    = hour(time, "UTC")
    isLiqHour  = liqHoursFilter ? (hourUTC >= 8 and hourUTC <= 20) : true
    // 0..3
    (isStable ? 1 : 0) + (not isSpike ? 1 : 0) + (isLiqHour ? 1 : 0)

f_sortSignalsByStrength(signals) =>
    _s = array.copy(signals)
    if array.size(_s) > 1
        for i = 0 to array.size(_s) - 2
            for j = i + 1 to array.size(_s) - 1
                si = array.get(_s, i)
                sj = array.get(_s, j)
                if sj.strength > si.strength
                    array.set(_s, i, sj)
                    array.set(_s, j, si)
    _s

// ========== PH√ÅT HI·ªÜN T√çN HI·ªÜU ==========
f_detectSpring(bar) =>
    s = VSASignal.new("Spring", "bullish", 0.0, array.new<string>(), false)
    swingLow = ta.lowest(low, sLookCur)[1]
    priceFail = low < swingLow and close > swingLow
    volOK = bar.volume.isHigh or bar.volume.percentileRank > 70
    closeStrong = bar.closeLocation > 0.5
    if priceFail
        array.push(s.reasons, "Break d∆∞·ªõi h·ªó tr·ª£ r·ªìi ph·ª•c h·ªìi")
        s.strength += 2.0
    if volOK
        array.push(s.reasons, "Volume cao x√°c nh·∫≠n")
        s.strength += 1.5
    if closeStrong
        array.push(s.reasons, "ƒê√≥ng c·ª≠a n·ª≠a tr√™n")
        s.strength += 1.0
    s.isValid := s.strength >= springStrength
    s

f_detectUpthrust(bar) =>
    s = VSASignal.new("Upthrust", "bearish", 0.0, array.new<string>(), false)
    swingHigh = ta.highest(high, sLookCur)[1]
    priceFail = high > swingHigh and close < swingHigh
    volOK = bar.volume.isHigh or bar.volume.percentileRank > 70
    closeWeak = bar.closeLocation < 0.5
    if priceFail
        array.push(s.reasons, "Break l√™n kh√°ng c·ª± r·ªìi th·∫•t b·∫°i")
        s.strength += 2.0
    if volOK
        array.push(s.reasons, "Volume cao x√°c nh·∫≠n")
        s.strength += 1.5
    if closeWeak
        array.push(s.reasons, "ƒê√≥ng c·ª≠a n·ª≠a d∆∞·ªõi")
        s.strength += 1.0
    s.isValid := s.strength >= upthrustStrength
    s

f_detectShakeout(bar) =>
    s = VSASignal.new("Shakeout", "bullish", 0.0, array.new<string>(), false)
    swingLow = ta.lowest(low, sLookCur)[1]
    failWide  = (low < swingLow and close > swingLow) and bar.isWide
    volX = bar.volume.isExtreme or bar.volume.percentileRank > 85
    if failWide
        array.push(s.reasons, "Xuy√™n h·ªó tr·ª£ v·ªõi spread r·ªông, b·∫≠t l·∫°i")
        s.strength += 2.5
    if volX
        array.push(s.reasons, "Volume c·ª±c ƒë·∫°i x√°c nh·∫≠n")
        s.strength += 1.5
    if bar.closeLocation > 0.6
        array.push(s.reasons, "ƒê√≥ng cao trong bi√™n")
        s.strength += 1.0
    s.isValid := s.strength >= shakeoutStrength
    s

f_detectStoppingVolume(bar) =>
    s = VSASignal.new("Stopping Vol", "bullish", 0.0, array.new<string>(), false)
    if bar.isDown and bar.volume.percentileRank > 80
        array.push(s.reasons, "Down bar v·ªõi volume cao")
        s.strength += 2.0
    if bar.closeLocation > 0.6
        array.push(s.reasons, "Close ·ªü ph·∫ßn tr√™n bi√™n")
        s.strength += 1.5
    s.isValid := s.strength >= stoppingVolStrength
    s

f_detectNoSupply(bar) =>
    s = VSASignal.new("No Supply", "bullish", 0.0, array.new<string>(), false)
    if bar.isDown and (bar.volume.isLow or bar.volume.percentileRank < 25)
        array.push(s.reasons, "Down bar v·ªõi volume th·∫•p")
        s.strength += 1.5
    if bar.isNarrow
        array.push(s.reasons, "Spread h·∫πp")
        s.strength += 1.0
    if close < close[3]
        array.push(s.reasons, "Sau nh·ªãp gi·∫£m")
        s.strength += 0.5
    s.isValid := s.strength >= noSupplyDemandStrength
    s

// C·ªù ‚Äúc√≥ s·ª©c m·∫°nh tr∆∞·ªõc ƒë√≥‚Äù ƒë·ªÉ ph·ª•c v·ª• Test
var bool prevStrengthBull = false
var bool prevStrengthBear = false

f_detectTestBar(bar) =>
    s = VSASignal.new("Test Bar", "bullish", 0.0, array.new<string>(), false)
    bool afterStrength = nz(prevStrengthBull[1]) // ƒë·ªçc c·ªù t·ª´ bar tr∆∞·ªõc
    if bar.isDown and (bar.volume.isLow or bar.volume.percentileRank < 20)
        array.push(s.reasons, "Test: down bar v·ªõi volume th·∫•p")
        s.strength += 2.0
    if bar.closeLocation > 0.5
        array.push(s.reasons, "ƒê√≥ng c·ª≠a n·ª≠a tr√™n")
        s.strength += 1.0
    if afterStrength
        array.push(s.reasons, "Theo sau t√≠n hi·ªáu s·ª©c m·∫°nh")
        s.strength += 1.5
    s.isValid := s.strength >= testBarStrength
    s

f_detectBuyingClimax(bar) =>
    s = VSASignal.new("Buying Climax", "bearish", 0.0, array.new<string>(), false)
    if bar.isUp and bar.volume.percentileRank > climaxVolThresholdPct
        array.push(s.reasons, "Up bar v·ªõi volume c·ª±c ƒë·∫°i")
        s.strength += 2.5
    if bar.isWide
        array.push(s.reasons, "Spread r·ªông")
        s.strength += 1.0
    if bar.closeLocation < 0.4
        array.push(s.reasons, "ƒê√≥ng th·∫•p trong bi√™n")
        s.strength += 1.5
    s.isValid := s.strength >= climaxStrength
    s

f_detectSellingClimax(bar) =>
    s = VSASignal.new("Selling Climax", "bullish", 0.0, array.new<string>(), false)
    if bar.isDown and bar.volume.percentileRank > climaxVolThresholdPct
        array.push(s.reasons, "Down bar v·ªõi volume c·ª±c ƒë·∫°i")
        s.strength += 2.5
    if bar.isWide
        array.push(s.reasons, "Spread r·ªông")
        s.strength += 1.0
    if bar.closeLocation > 0.6
        array.push(s.reasons, "ƒê√≥ng cao trong bi√™n")
        s.strength += 1.5
    s.isValid := s.strength >= climaxStrength
    s

f_detectNoDemand(bar) =>
    s = VSASignal.new("No Demand", "bearish", 0.0, array.new<string>(), false)
    if bar.isUp and (bar.volume.isLow or bar.volume.percentileRank < 25)
        array.push(s.reasons, "Up bar v·ªõi volume th·∫•p")
        s.strength += 1.5
    if bar.isNarrow
        array.push(s.reasons, "Spread h·∫πp")
        s.strength += 1.0
    if close > close[3]
        array.push(s.reasons, "Sau nh·ªãp tƒÉng")
        s.strength += 0.5
    s.isValid := s.strength >= noSupplyDemandStrength
    s

f_detectEffortVsResult(bar) =>
    s = VSASignal.new("Effort vs Result", "", 0.0, array.new<string>(), false)
    bool highEffort = bar.volume.percentileRank > 75
    bool littleResult = (not bar.isWide) and (bar.barRange < bar.avgRange * 0.9)
    if highEffort and littleResult
        array.push(s.reasons, "N·ªó l·ª±c cao, k·∫øt qu·∫£ th·∫•p")
        s.strength += 2.0
        if bar.closeLocation > 0.5
            s.type := "bullish"
            array.push(s.reasons, "Close n·ª≠a tr√™n")
            s.strength += 0.5
        else
            s.type := "bearish"
            array.push(s.reasons, "Close n·ª≠a d∆∞·ªõi")
            s.strength += 0.5
    s.isValid := s.strength >= effortResultStrength
    s

// ========== TREND ==========
f_getTrendBias() =>
    ema = ta.ema(close, trendLength)
    close > ema ? 1 : close < ema ? -1 : 0

// ========== MAIN ==========
var activeSignals = array.new<VSASignal>()
var float totalBullishScore = 0.0
var float totalBearishScore = 0.0
var int   confluenceCount   = 0
var int   volumeQuality     = 0

if bar_index > math.max(vLookCur, sLookCur)
    volCtx = f_getVolumeContext()
    bar    = f_getBarCharacteristics(volCtx)
    trendBias = f_getTrendBias()
    volumeQuality := f_getVolumeQuality()

    if barstate.isconfirmed and (volumeQuality >= 2 or not useVolumeFilter)
        array.clear(activeSignals)
        // Spring / Upthrust
        if enableSpringUpthrust
            sp = f_detectSpring(bar)
            if sp.isValid and (not useTrendFilter or trendBias >= 0)
                array.push(activeSignals, sp)
            ut = f_detectUpthrust(bar)
            if ut.isValid and (not useTrendFilter or trendBias <= 0)
                array.push(activeSignals, ut)
        // Shakeout
        if enableShakeout
            so = f_detectShakeout(bar)
            if so.isValid and (not useTrendFilter or trendBias >= 0)
                array.push(activeSignals, so)
        // Stopping Vol
        if enableStoppingVol
            sv = f_detectStoppingVolume(bar)
            if sv.isValid and (not useTrendFilter or trendBias >= 0)
                array.push(activeSignals, sv)
        // No Supply / No Demand
        if enableNoSupplyDemand
            ns = f_detectNoSupply(bar)
            if ns.isValid and (not useTrendFilter or trendBias >= 0)
                array.push(activeSignals, ns)
            nd = f_detectNoDemand(bar)
            if nd.isValid and (not useTrendFilter or trendBias <= 0)
                array.push(activeSignals, nd)
        // Climax
        if enableClimax
            bc = f_detectBuyingClimax(bar)
            if bc.isValid and (not useTrendFilter or trendBias <= 0)
                array.push(activeSignals, bc)
            sc = f_detectSellingClimax(bar)
            if sc.isValid and (not useTrendFilter or trendBias >= 0)
                array.push(activeSignals, sc)
        // Effort vs Result
        if enableEffortResult
            evr = f_detectEffortVsResult(bar)
            if evr.isValid
                if (evr.type == "bullish" and (not useTrendFilter or trendBias >= 0)) or (evr.type == "bearish" and (not useTrendFilter or trendBias <= 0))
                    array.push(activeSignals, evr)
        // Test
        if enableTestBar
            tb = f_detectTestBar(bar)
            if tb.isValid and (not useTrendFilter or trendBias >= 0)
                array.push(activeSignals, tb)

    // T√≠nh ƒëi·ªÉm
    confluenceCount := array.size(activeSignals)
    totalBullishScore := 0.0
    totalBearishScore := 0.0
    if confluenceCount > 0
        for s in activeSignals
            if s.type == "bullish"
                totalBullishScore += s.strength
            else if s.type == "bearish"
                totalBearishScore += s.strength

    // C·∫≠p nh·∫≠t c·ªù strength cho Test c·ªßa bar k·∫ø ti·∫øp
    bool strengthBullNow = false
    bool strengthBearNow = false
    for s in activeSignals
        if s.type == "bullish"
            strengthBullNow := true
        if s.type == "bearish"
            strengthBearNow := true
    prevStrengthBull := strengthBullNow
    prevStrengthBear := strengthBearNow

// ========== DISPLAY ==========
emaPlot = ta.ema(close, trendLength)
plot(emaPlot, "Trend EMA", color=color.gray, linewidth=1, display=display.none)

bgcolor(showBackground and confluenceCount >= minConfluence and (totalBullishScore > 0 or totalBearishScore > 0)
     ? (totalBullishScore > totalBearishScore ? color.new(color.green, 90) : color.new(color.red, 90))
     : na)

if showLabels and confluenceCount >= minConfluence and confluenceCount > 0
    sorted = f_sortSignalsByStrength(activeSignals)
    strongest = array.get(sorted, 0)
    txt = strongest.name + " (" + str.tostring(strongest.strength, "#.#") + ")"
    col = strongest.type == "bullish" ? color.new(color.green, 0) : color.new(color.red, 0)
    yloc_ = strongest.type == "bullish" ? location.belowbar : location.abovebar
    style_ = strongest.type == "bullish" ? label.style_label_up : label.style_label_down
    label.new(bar_index, na, txt, color=col, textcolor=color.white, style=style_, yloc=yloc_, size=size.small)

// ========== DASHBOARD ==========
var table dashboard = na
if showDashboard and barstate.islast
    if na(dashboard)
        dashboard := table.new(position.top_right, 2, 7, bgcolor=color.new(color.black, 80), border_width=1)
    table.clear(dashboard, 0, 6, 0, 1)
    table.cell(dashboard, 0, 0, "VSA ANALYSIS", text_color=color.white, bgcolor=color.blue, colspan=2)
    volCtxDash = f_getVolumeContext()
    trendBiasDash = f_getTrendBias()
    table.cell(dashboard, 0, 1, "Preset:")
    table.cell(dashboard, 1, 1, tf_mode == "Manual override" ? "Manual" : "Auto " + timeframe.period, text_color=color.white)
    table.cell(dashboard, 0, 2, "Trend:")
    table.cell(dashboard, 1, 2, trendBiasDash > 0 ? "BULLISH" : trendBiasDash < 0 ? "BEARISH" : "NEUTRAL", text_color=trendBiasDash > 0 ? color.green : trendBiasDash < 0 ? color.red : color.gray)
    table.cell(dashboard, 0, 3, "Vol PR:")
    table.cell(dashboard, 1, 3, str.tostring(volCtxDash.percentileRank, "#") + "%", text_color=volCtxDash.isHigh ? color.orange : volCtxDash.isLow ? color.gray : color.white)
    table.cell(dashboard, 0, 4, "Vol Quality:")
    vQC = f_getVolumeQuality()
    vCol = vQC == 3 ? color.green : vQC == 2 ? color.orange : color.red
    table.cell(dashboard, 1, 4, str.tostring(vQC) + "/3", text_color=vCol)
    table.cell(dashboard, 0, 5, "Confluence:")
    table.cell(dashboard, 1, 5, str.tostring(confluenceCount), text_color=confluenceCount > 0 ? color.green : color.gray)
    table.cell(dashboard, 0, 6, "Bull/Bear:")
    table.cell(dashboard, 1, 6, str.tostring(totalBullishScore, "#.#") + " / " + str.tostring(totalBearishScore, "#.#"), text_color= totalBullishScore > totalBearishScore ? color.green : totalBearishScore > totalBullishScore ? color.red : color.gray)

// ========== ALERTS ==========
alertcondition(confluenceCount >= minConfluence and totalBullishScore > totalBearishScore, "VSA Bullish Signal", "VSA Bullish confluence detected")
alertcondition(confluenceCount >= minConfluence and totalBearishScore > totalBullishScore, "VSA Bearish Signal", "VSA Bearish confluence detected")
alertcondition(confluenceCount >= minConfluence and totalBearishScore > totalBullishScore, "VSA Bearish Signal", "VSA Bearish confluence detected")
