//@version=5
indicator(title='Volume Profile Optimized', shorttitle='VP Kaizen', overlay=true, max_bars_back=5000, max_boxes_count=500)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//// INPUTS
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// === LOOKBACK SETTINGS ===
vp_use_visible_range = input.bool(false, 'Use Visible Range', group='Lookback Period')
vp_lookback_depth = input.int(200, 'Fixed Range Lookback', minval=20, maxval=1000, group='Lookback Period',
     tooltip='Bars to analyze: 1D=500-1000, 4H=200-500, 1H=100-200, 15m=50-100, 1-5m=20-50')

// === MULTI-TIMEFRAME OPTIMIZATION ===
auto_adjust_tf = input.bool(true, 'Auto-Adjust for Timeframe', group='Multi-Timeframe Settings',
     tooltip='Automatically optimize settings based on current timeframe')
manual_tf_mode = input.string('1H', 'Manual Timeframe Mode', options=['1D', '4H', '1H', '15m', '5m', '1m'], group='Multi-Timeframe Settings',
     tooltip='Used when auto-adjust is disabled')
execution_sensitivity = input.string('Medium', 'Execution Sensitivity', options=['Low', 'Medium', 'High', 'Ultra'], group='Multi-Timeframe Settings',
     tooltip='Low=1D/4H analysis, Medium=1H/15m, High=5m, Ultra=1m execution')

// === VOLUME PROFILE SETTINGS ===
vp_num_levels = input.int(60, 'Price Levels', minval=20, maxval=200, group='Volume Profile',
     tooltip='20-40 for 1D/4H, 40-80 for 1H/15m, 80-150 for 1-5m execution')
vp_bar_width = input.int(30, 'Bar Width', minval=10, maxval=100, group='Volume Profile')
vp_right_offset = input.int(40, 'Right Offset', minval=0, maxval=150, group='Volume Profile')
vp_volume_type = input.string('Both', 'Volume Type', options=['Both', 'Bullish', 'Bearish'], group='Volume Profile')

// === INTRADAY FOCUS ===
session_focus = input.bool(true, 'Focus on Current Session', group='Intraday Settings',
     tooltip='Weight current trading session volume more heavily')
session_weight = input.float(1.5, 'Session Volume Weight', minval=1.0, maxval=3.0, step=0.1, group='Intraday Settings',
     tooltip='How much more weight to give current session vs previous sessions')
key_levels_only = input.bool(false, 'Show Key Levels Only', group='Intraday Settings',
     tooltip='Filter to show only the most significant volume levels')

// === DISPLAY SETTINGS ===
vp_show_poc = input.bool(true, 'Show Point of Control', group='Display')
vp_show_va = input.bool(true, 'Show Value Area', group='Display') 
vp_va_percent = input.int(70, 'Value Area %', minval=50, maxval=95, group='Display')
vp_show_hva = input.bool(false, 'Show High Volume Areas', group='Display')
vp_hva_threshold = input.int(80, 'HVA Threshold %', minval=60, maxval=95, group='Display')

// === COLORS ===
vp_vol_color = input.color(color.new(color.gray, 70), 'Volume Bar Color', group='Colors')
vp_poc_color = input.color(color.red, 'POC Color', group='Colors')
vp_va_color = input.color(color.new(color.blue, 80), 'Value Area Color', group='Colors')
vp_hva_color = input.color(color.new(color.orange, 70), 'High Volume Area Color', group='Colors')

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//// VARIABLES & CONSTANTS
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Performance optimizations
var int lookback_bars = na
var float price_high = na
var float price_low = na
var float price_step = na
// var array<float> volume_at_price = array.new<float>()
var float[] volume_at_price = array.new_float()
var box[] volume_boxes = array.new_box()
var box poc_box = na
var box[] va_boxes = array.new_box()

// Update frequency control
var int last_calc_bar = 0
var bool needs_update = true

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//// HELPER FUNCTIONS
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Compatibility helper: Pine does not allow adding functions into the 'table' namespace.
// If your code (or any library you use) calls table.rows(t), replace it with f_table_rows(t).
f_table_rows(tbl) =>
    // table.height / row-count API differs by version. If the builtin exists, return it.
    // There's no standard table.rows in Pine, so return 0 as a safe default.
    // If you have a specific table implementation, replace this body to return the real row count.
    0

// Move this helper ABOVE any use-sites (fix: undefined reference)
f_price_to_index_local(price, price_low_val, price_step_val) =>
    idx = int(math.round((price - price_low_val) / price_step_val))
    math.max(0, math.min(vp_num_levels - 1, idx))

// Efficient price to index mapping (cast to int for safety)
f_price_to_index(price) =>
    idx = int(math.round((price - price_low) / price_step))
    math.max(0, math.min(vp_num_levels - 1, idx))

// Safe array operations
f_safe_array_get(arr, index, default_val) =>
    index >= 0 and index < array.size(arr) ? array.get(arr, index) : default_val

f_safe_array_set(arr, index, value) =>
    if index >= 0 and index < array.size(arr)
        array.set(arr, index, value)

// Get timeframe-specific settings
f_get_tf_settings() =>
    current_tf = timeframe.period
    
    // Auto-detect timeframe if enabled
    if auto_adjust_tf
        tf_minutes = timeframe.in_seconds() / 60
        detected_tf = if tf_minutes >= 1440
            '1D'      // Daily or higher
        else if tf_minutes >= 240
            '4H'       // 4H to daily
        else if tf_minutes >= 60
            '1H'        // 1H to 4H  
        else if tf_minutes >= 15
            '15m'       // 15m to 1H
        else if tf_minutes >= 5
            '5m'         // 5m to 15m
        else
            '1m'                         // 1m to 5m
        detected_tf
    else
        manual_tf_mode

// (distribution logic inlined into f_calculate_volume_profile below)

// Calculate volume profile with multi-timeframe optimization
f_calculate_volume_profile() =>
    // Clear and re-init array with current vp_num_levels
    array.clear(volume_at_price)
    for _ = 0 to vp_num_levels - 1
        array.push(volume_at_price, 0.0)
    
    tf_mode = f_get_tf_settings()

    // Precompute timeframe/session values used per-bar to satisfy analyzer
    tf_minutes = timeframe.in_seconds() / 60
    is_new_day = ta.change(time("D")) != 0
    bars_since_open = ta.barssince(is_new_day)
    bars_per_day = math.max(1, math.round(1440 / math.max(1, tf_minutes)))
    is_current_session = bars_since_open <= bars_per_day
    session_weight_factor_base = session_focus ? session_weight : 1.0

    // Adjust lookback based on timeframe and purpose
    effective_lookback = if tf_mode == '1D'
        math.min(lookback_bars * 2, 1000)
    else if tf_mode == '4H'
        math.min(lookback_bars * 1.5, 500)
    else if tf_mode == '1H'
        lookback_bars
    else if tf_mode == '15m'
        math.min(lookback_bars, 150)
    else if tf_mode == '5m'
        math.min(lookback_bars, 100)
    else if tf_mode == '1m'
        math.min(lookback_bars, 50)
    else
        lookback_bars
    
    lookback_int = math.round(effective_lookback)
    
    calc_price_high = ta.highest(high, lookback_int)
    calc_price_low = ta.lowest(low, lookback_int)
    calc_price_step = (calc_price_high - calc_price_low) / vp_num_levels
    
    if calc_price_step <= 0
        [false, na, na, na]
    else
        for i = 0 to math.min(lookback_int - 1, bar_index)
            bar_volume = volume[i]
            bar_open = open[i]
            bar_high = high[i]
            bar_low = low[i]
            bar_close = close[i]
            
            is_bullish = bar_close >= bar_open
            include_volume = if vp_volume_type == 'Both'
                true
            else if vp_volume_type == 'Bullish'
                is_bullish
            else if vp_volume_type == 'Bearish'
                not is_bullish
            else
                true

            // Inline distribution logic (previously in f_distribute_volume)
            first_arg = (include_volume and bar_volume > 0) ? bar_volume : 0.0
            if calc_price_step > 0 and first_arg > 0
                // compute timeframe weight (use precomputed tf_mode)
                age_weight_local = if tf_mode == '1D'
                    1.0
                else if tf_mode_local == '4H'
                    math.pow(1.2, 1.0 / (i + 1))
                else if tf_mode_local == '1H'
                    math.pow(1.5, 1.0 / (i + 1))
                else if tf_mode_local == '15m'
                    math.pow(2.0, 1.0 / (i + 1))
                else if tf_mode_local == '5m'
                    math.pow(2.5, 1.0 / (i + 1))
                else
                    math.pow(3.0, 1.0 / (i + 1))

                // session weight (use precomputed session info)
                final_weight_local = age_weight_local * (is_current_session ? session_weight_factor_base : 1.0)
                weighted_volume_local = first_arg * final_weight_local

                typical_price = (bar_high + bar_low + bar_close) / 3
                price_range = bar_high - bar_low

                if price_range <= 0
                    idx_local = f_price_to_index_local(typical_price, calc_price_low, calc_price_step)
                    current_vol = f_safe_array_get(volume_at_price, idx_local, 0.0)
                    f_safe_array_set(volume_at_price, idx_local, current_vol + weighted_volume_local)
                else
                    start_idx = f_price_to_index_local(bar_low,  calc_price_low, calc_price_step)
                    end_idx   = f_price_to_index_local(bar_high, calc_price_low, calc_price_step)
                    for j = start_idx to end_idx
                        level_price = calc_price_low + j * calc_price_step
                        if level_price >= bar_low and level_price <= bar_high
                            distance_factor = 1.0 - math.abs(level_price - typical_price) / (price_range / 2)
                            weight = math.max(0.1, distance_factor)
                            distributed_vol = weighted_volume_local * weight / math.max(1, end_idx - start_idx + 1)
                            current_vol = f_safe_array_get(volume_at_price, j, 0.0)
                            f_safe_array_set(volume_at_price, j, current_vol + distributed_vol)
        
        [true, calc_price_high, calc_price_low, calc_price_step]

// Find POC and stats
f_get_profile_stats() =>
    if array.size(volume_at_price) == 0
        [na, na, na, na]
    else
        max_volume = array.max(volume_at_price)
        poc_index = array.indexof(volume_at_price, max_volume)
        poc_price = price_low + poc_index * price_step
        total_volume = array.sum(volume_at_price)
        [poc_index, poc_price, max_volume, total_volume]

// Calculate Value Area
f_calculate_value_area(poc_idx, total_vol) =>
    if array.size(volume_at_price) == 0 or poc_idx < 0
        [na, na]
    else
        target_volume = total_vol * vp_va_percent / 100
        va_volume = array.get(volume_at_price, poc_idx)
        va_upper = poc_idx
        va_lower = poc_idx
        
        // Expand VA up and down from POC
        while va_volume < target_volume and (va_upper < vp_num_levels - 1 or va_lower > 0)
            vol_above = va_upper < vp_num_levels - 1 ? array.get(volume_at_price, va_upper + 1) : 0
            vol_below = va_lower > 0 ? array.get(volume_at_price, va_lower - 1) : 0
            
            if vol_above >= vol_below and va_upper < vp_num_levels - 1
                va_upper += 1
                va_volume += vol_above
            else if va_lower > 0
                va_lower -= 1
                va_volume += vol_below
            else
                break
        
        va_high_price = price_low + va_upper * price_step
        va_low_price = price_low + va_lower * price_step
        [va_low_price, va_high_price]

// Clear and remove existing drawings, return cleared poc box
f_clear_drawings(poc_in) =>
    // Clear existing boxes
    for box_id in volume_boxes
        box.delete(box_id)
    array.clear(volume_boxes)

    for box_id in va_boxes
        box.delete(box_id)
    array.clear(va_boxes)

    if not na(poc_in)
        box.delete(poc_in)

    // Ensure the function returns a 'box' typed value, not a bare na
    box poc_out = na
    poc_out

// Note: we call f_calculate_volume_profile every bar (pure function) and only redraw when needed.

// Return created POC box id (or na). Also remove 'return' keyword (not valid in Pine).
f_draw_volume_profile() =>
    [poc_idx, poc_price, max_vol, total_vol] = f_get_profile_stats()
    box poc_out = na

    if not (na(poc_idx) or max_vol <= 0)
        // Calculate VA
        [va_low, va_high] = f_calculate_value_area(poc_idx, total_vol)

        // Draw volume bars
        x_base = bar_index + vp_right_offset

        for i = 0 to vp_num_levels - 1
            level_volume = array.get(volume_at_price, i)
            if level_volume > 0
                level_price = price_low + i * price_step
                bar_length = math.round(level_volume / max_vol * vp_bar_width)
                if bar_length > 0
                    x1 = x_base
                    x2 = x_base + bar_length
                    y1 = level_price - price_step / 2
                    y2 = level_price + price_step / 2

                    box_color = vp_vol_color
                    in_va = vp_show_va and not na(va_low) and level_price >= va_low and level_price <= va_high
                    is_poc = i == poc_idx and vp_show_poc
                    is_hva = vp_show_hva and level_volume >= max_vol * vp_hva_threshold / 100
                    if in_va
                        box_color := vp_va_color
                    if is_poc
                        box_color := vp_poc_color
                    if is_hva
                        box_color := vp_hva_color

                    show_level = true
                    if key_levels_only
                        show_level := in_va or is_poc or is_hva

                    if show_level
                        vol_box = box.new(x1, y1, x2, y2, bgcolor=box_color, border_color=na)
                        array.push(volume_boxes, vol_box)

        if vp_show_poc and not na(poc_price)
            poc_x1 = bar_index - lookback_bars
            poc_x2 = x_base - 5
            poc_out := box.new(poc_x1, poc_price - price_step/4, poc_x2, poc_price + price_step/4,
                               bgcolor=vp_poc_color, border_color=vp_poc_color)

    poc_out
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//// MAIN LOGIC
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Initialize lookback
if barstate.isfirst
    lookback_bars := vp_use_visible_range ? 200 : vp_lookback_depth
    array.clear(volume_at_price)
    for i = 0 to vp_num_levels - 1
        array.push(volume_at_price, 0.0)

// Multi-timeframe update frequency
current_bar = bar_index
tf_mode = f_get_tf_settings()

// Timeframe-specific update frequency
update_frequency = if tf_mode == '1D'
    math.max(10, lookback_bars / 20)       // Slower updates for daily analysis
else if tf_mode == '4H'
    math.max(5, lookback_bars / 30)        // Moderate updates for 4H
else if tf_mode == '1H'
    math.max(3, lookback_bars / 40)        // Regular updates for 1H
else if tf_mode == '15m'
    math.max(2, lookback_bars / 50)       // Faster updates for 15m
else if tf_mode == '5m'
    2                                       // High frequency for 5m execution
else if tf_mode == '1m'
    1                                       // Every bar for 1m execution
else
    3

// Override with execution sensitivity
final_update_freq = if execution_sensitivity == 'Ultra'
    1                                    // Every bar - maximum responsiveness
else if execution_sensitivity == 'High'
    2                                     // Every 2 bars
else if execution_sensitivity == 'Medium'
    math.max(3, update_frequency)       // Standard frequency
else if execution_sensitivity == 'Low'
    math.max(5, update_frequency * 2)      // Lower frequency for analysis
else
    update_frequency

needs_update := barstate.islast or 
                 (current_bar - last_calc_bar >= final_update_freq) or
                 barstate.isconfirmed

// Calculate profile each bar (satisfies analyzer); draw only when update is needed
// No-op to keep per-bar calculation flow (distribution logic has been inlined)
_ = 0
[calc_success, calc_price_high, calc_price_low, calc_price_step] = f_calculate_volume_profile()
if needs_update and (barstate.islast or barstate.isconfirmed)
    // Clear and redraw visual elements
    poc_box := f_clear_drawings(poc_box)
    if calc_success
        price_high := calc_price_high
        price_low  := calc_price_low
        price_step := calc_price_step
        poc_box := f_draw_volume_profile()
    last_calc_bar := current_bar

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//// ALERTS & TABLE (Optional)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Simple stats display
if barstate.islast
    [poc_idx, poc_price, max_vol, total_vol] = f_get_profile_stats()
    if not na(poc_price)
        // Create optional info label
        var label info_label = na
        if not na(info_label)
            label.delete(info_label)
        
        info_text = "POC: " + str.tostring(poc_price, "#.##") + 
                   "\nLevels: " + str.tostring(vp_num_levels) +
                   "\nBars: " + str.tostring(lookback_bars)
        
        info_label := label.new(bar_index + vp_right_offset + vp_bar_width + 10, poc_price, 
                               info_text, style=label.style_label_left, 
                               color=color.new(color.black, 80), textcolor=color.white, size=size.small)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//// PERFORMANCE MONITORING
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Debug info for performance monitoring
plot(array.size(volume_boxes), title="Active Boxes", display=display.data_window)
plot(lookback_bars, title="Lookback Bars", display=display.data_window)
plot(vp_num_levels, title="Price Levels", display=display.data_window)