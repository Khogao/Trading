//@version=5
// TITLE: VP Intraday Crypto Pro v1.2
// DESC: Enhanced v1.1 with crypto-specific optimizations for Bitcoin/ETH/Solana intraday trading
indicator(title='VP Intraday Crypto Pro v1.2', shorttitle='VP Crypto', overlay=true, max_bars_back=5000, max_boxes_count=500, max_lines_count=500)

// === CRYPTO-SPECIFIC CONSTANTS ===
CRYPTO_PRECISION_LEVELS = 100  // Optimized for crypto price action
CRYPTO_SESSION_WEIGHT = 2.5    // Higher weight for active trading sessions
GAUSSIAN_SIGMA_CRYPTO = 0.2    // Tighter distribution for crypto volatility
MEMORY_CLEANUP_CYCLE = 75      // Faster cleanup for active crypto markets
MIN_CRYPTO_VOLUME = 0.1        // Lower threshold for crypto volume
CRYPTO_AGE_DECAY = 0.015       // Faster decay for crypto's fast-moving nature

// === ENHANCED INPUTS (Based on v1.1) ===
// --- Core Settings ---
vp_lookback_depth = input.int(200, 'Lookback Bars', minval=50, maxval=1000, group='Core Settings')
vp_num_levels = input.int(CRYPTO_PRECISION_LEVELS, 'Price Levels', minval=50, maxval=200, group='Core Settings', tooltip="Optimized for crypto: 100 levels") 
vp_bar_width = input.int(30, 'Bar Width', minval=10, maxval=100, group='Core Settings')
vp_right_offset = input.int(40, 'Right Offset', minval=0, maxval=150, group='Core Settings')

// --- Enhanced Crypto Timeframe Support ---
auto_adjust_tf = input.bool(true, 'Auto-Adjust for Timeframe', group='Crypto Multi-Timeframe')
manual_tf_mode = input.string('15m', 'Manual Timeframe Mode', options=['4H', '1H', '15m', '5m', '1m'], group='Crypto Multi-Timeframe')
execution_sensitivity = input.string('High', 'Update Sensitivity', options=['Medium', 'High', 'Ultra'], group='Crypto Multi-Timeframe', tooltip="High/Ultra recommended for crypto")

// --- Crypto Session Settings ---
session_focus = input.bool(true, 'Focus on Active Sessions', group='Crypto Sessions')
session_weight = input.float(CRYPTO_SESSION_WEIGHT, 'Session Weight', minval=1.0, maxval=4.0, step=0.1, group='Crypto Sessions')
vp_volume_type = input.string('Both', 'Volume Type', options=['Both', 'Bullish', 'Bearish'], group='Crypto Sessions')

// --- Enhanced Crypto Trading Hours ---
crypto_market_mode = input.string('24/7', 'Market Mode', options=['24/7', 'US Hours', 'Asia Hours', 'EU Hours', 'Custom'], group='Crypto Sessions')
intraday_mode = input.bool(true, 'Intraday Mode', group='Crypto Sessions')
intraday_start_hour = input.int(00, 'Active Window Start (UTC)', minval=0, maxval=23, group='Crypto Sessions')
intraday_end_hour = input.int(23, 'Active Window End (UTC)', minval=0, maxval=23, group='Crypto Sessions')
intraday_lookback_days = input.int(5, 'Intraday Lookback (days)', minval=1, maxval=15, group='Crypto Sessions', tooltip="Shorter for crypto's fast pace")

// --- Enhanced Display ---
vp_show_poc = input.bool(true, 'Show POC', group='Display')
vp_show_va = input.bool(true, 'Show Value Area', group='Display')
vp_va_percent = input.int(70, 'Value Area %', minval=50, maxval=95, group='Display')
intraday_va_percent = input.int(80, 'Intraday VA %', minval=60, maxval=95, group='Display', tooltip="Tighter VA for crypto")

// --- NEW: Crypto-Specific Features ---
vp_show_hva = input.bool(true, 'Show High Volume Nodes', group='Crypto Features', inline='hva')
vp_hva_threshold = input.int(75, 'HVN Threshold %', minval=60, maxval=95, group='Crypto Features', inline='hva')
show_volume_spikes = input.bool(true, 'Mark Volume Spikes', group='Crypto Features', inline='spikes')
volume_spike_multiplier = input.float(3.0, 'Spike Multiplier', minval=2.0, maxval=5.0, step=0.5, group='Crypto Features', inline='spikes')

// --- Enhanced Volume Distribution ---
volume_distribution_method = input.string('Gaussian', 'Distribution Method', options=['Standard', 'Gaussian', 'Smart'], group='Advanced Volume', tooltip="Gaussian recommended for crypto")
price_action_weight = input.bool(true, 'Price Action Weighting', group='Advanced Volume', tooltip="Weight by candle body vs wick ratio")
volatility_adjustment = input.bool(true, 'Volatility Adjustment', group='Advanced Volume', tooltip="Adjust for crypto volatility")

// --- VAH/VAL Line Enhancements (from v1.1) ---
vp_show_va_lines = input.bool(true, "Show VAH/VAL Lines", group="Display", inline="va_lines")
vp_va_line_width = input.int(2, "Line Width", minval=1, maxval=5, group="Display", inline="va_lines")
vp_va_line_style = input.string('Dashed', 'Line Style', options=['Solid', 'Dashed', 'Dotted'], group="Display", inline="va_lines")

// --- Crypto-Optimized Colors ---
vp_vol_color = input.color(color.new(#2E86AB, 70), 'Volume Bar Color', group='Crypto Colors')
vp_poc_color = input.color(#F23557, 'POC Color', group='Crypto Colors')
vp_va_color = input.color(color.new(#F18F01, 75), 'Value Area Color', group='Crypto Colors')
vp_hva_color = input.color(color.new(#C73E1D, 60), 'HVA Color', group='Crypto Colors')
vp_spike_color = input.color(#A4036F, 'Volume Spike Color', group='Crypto Colors')

// === ENHANCED TYPE SYSTEM (Simplified from v4.0) ===
// --- REMOVE custom 'type' + constructor usage and use simple globals instead ---

// === GLOBAL VARIABLES (Enhanced from v1.1) ===
var float[] volume_at_price = array.new_float(vp_num_levels, 0.0)

// Memory manager replacement (flat variables)
var array<box> mem_volume_boxes = array.new_box(0)
var array<line> mem_key_lines = array.new_line(0)
var array<label> mem_spike_markers = array.new_label(0)
var int mem_cleanup_counter = 0
var bool mem_needs_cleanup = false

// Session info replacement (flat variables)
var bool sess_is_active = false
var float sess_session_multiplier = 1.0
var int sess_active_hours_count = 0

var int last_calc_bar = 0
var float last_price_low = na
var float last_price_step = na
var float cached_atr = na
var float[] volume_spike_levels = array.new_float(0)  // FIX: proper float array init

// Ensure price vars exist before use
var float price_high = na
var float price_low = na
var float price_step = na

// Initialize enhanced arrays
if barstate.isfirst
    array.clear(mem_volume_boxes)
    array.clear(mem_key_lines)
    array.clear(mem_spike_markers)
    mem_cleanup_counter := 0

// === ENHANCED HELPER FUNCTIONS ===

// Crypto-optimized timeframe detection
f_get_crypto_timeframe_mode() =>
    if auto_adjust_tf
        tf_minutes = timeframe.in_seconds() / 60
        tf_minutes >= 240 ? '4H' : tf_minutes >= 60 ? '1H' : tf_minutes >= 15 ? '15m' : tf_minutes >= 5 ? '5m' : '1m'
    else
        manual_tf_mode

// Enhanced price-to-index with crypto precision
f_price_to_index_crypto(price, local_price_low, local_price_step) =>
    if local_price_step > 0 and not na(price) and not na(local_price_low)
        raw_index = (price - local_price_low) / local_price_step
        int(math.max(0, math.min(vp_num_levels - 1, math.round(raw_index))))
    else
        0

// Advanced volume distribution (from v4.0 enhancements)
f_distribute_volume_enhanced(center_price, volume, price_low, price_step, method) =>
    distribution = array.new_float(vp_num_levels, 0.0)
    center_idx = f_price_to_index_crypto(center_price, price_low, price_step)

    if method == 'Gaussian'
        sigma = GAUSSIAN_SIGMA_CRYPTO * vp_num_levels / 100
        total_weight = 0.0
        for i = 0 to vp_num_levels - 1
            distance = math.abs(i - center_idx)
            weight = math.exp(-0.5 * math.pow(distance / sigma, 2))
            array.set(distribution, i, weight)
            total_weight += weight
        if total_weight > 0
            for i = 0 to vp_num_levels - 1
                normalized_weight = array.get(distribution, i) / total_weight
                array.set(distribution, i, volume * normalized_weight)
    else if method == 'Smart'
        range_factor = 3
        for i = math.max(0, center_idx - range_factor) to math.min(vp_num_levels - 1, center_idx + range_factor)
            distance = math.abs(i - center_idx)
            weight = distance == 0 ? 0.5 : 0.5 / (distance * 2)
            array.set(distribution, i, volume * weight)
    else
        if center_idx >= 0 and center_idx < vp_num_levels
            array.set(distribution, center_idx, volume)
    distribution

// Crypto session detection with multiple market support
f_is_crypto_active_session() =>
    current_hour = hour(time)
    
    switch crypto_market_mode
        '24/7' => true
        'US Hours' => current_hour >= 14 and current_hour < 21  // 9AM-4PM EST in UTC
        'Asia Hours' => current_hour >= 0 and current_hour < 8   // Asia trading hours
        'EU Hours' => current_hour >= 8 and current_hour < 16    // EU trading hours
        'Custom' => 
            if intraday_start_hour <= intraday_end_hour
                current_hour >= intraday_start_hour and current_hour < intraday_end_hour
            else
                current_hour >= intraday_start_hour or current_hour < intraday_end_hour
        => true

// Enhanced Value Area calculation with crypto optimizations
f_calculate_crypto_value_area(poc_idx, total_vol, local_price_low, local_price_step, va_percentage) =>
    if poc_idx < 0 or total_vol <= 0 or poc_idx >= vp_num_levels
        [na, na]
    else
        target_volume = total_vol * va_percentage / 100
        va_volume = array.get(volume_at_price, poc_idx)
        va_upper = poc_idx
        va_lower = poc_idx
        
        // Iterative expansion with crypto-specific logic
        expansion_bias = 0.6  // Slight bias towards expanding upward in crypto
        
        while va_volume < target_volume and (va_upper < vp_num_levels - 1 or va_lower > 0)
            vol_above = va_upper < vp_num_levels - 1 ? array.get(volume_at_price, va_upper + 1) : 0.0
            vol_below = va_lower > 0 ? array.get(volume_at_price, va_lower - 1) : 0.0
            
            // Apply expansion bias for crypto
            vol_above_weighted = vol_above * (1 + expansion_bias)
            vol_below_weighted = vol_below * (1 - expansion_bias)
            
            if vol_above_weighted >= vol_below_weighted and va_upper < vp_num_levels - 1
                va_upper += 1
                va_volume += vol_above
            else if va_lower > 0
                va_lower -= 1
                va_volume += vol_below
            else
                break
        
        [local_price_low + va_lower * local_price_step, local_price_low + va_upper * local_price_step]

// Updated cleanup function to use flat memory vars
f_cleanup_memory_enhanced() =>
    cleanup_needed = mem_cleanup_counter >= MEMORY_CLEANUP_CYCLE or mem_needs_cleanup
    if cleanup_needed or barstate.islast
        // Clean volume boxes
        for i = array.size(mem_volume_boxes) - 1 to 0
            box.delete(array.get(mem_volume_boxes, i))
        array.clear(mem_volume_boxes)
        // Clean lines
        for i = array.size(mem_key_lines) - 1 to 0
            line.delete(array.get(mem_key_lines, i))
        array.clear(mem_key_lines)
        // Clean spike markers
        for i = array.size(mem_spike_markers) - 1 to 0
            label.delete(array.get(mem_spike_markers, i))
        array.clear(mem_spike_markers)
        mem_cleanup_counter := 0
        mem_needs_cleanup := false

// Volume spike detection for crypto
f_detect_volume_spike(current_vol, avg_vol) =>
    show_volume_spikes and current_vol > avg_vol * volume_spike_multiplier

// Helper: sum float array (needed for total_vol)
f_array_sum_float(arr) =>
    s = 0.0
    for i = 0 to array.size(arr) - 1
        s += array.get(arr, i)
    s

// === ENHANCED MAIN LOGIC ===
tf_mode = f_get_crypto_timeframe_mode()
tf_minutes = timeframe.in_seconds() / 60

// Precompute sma20 once per-bar to avoid repeated ta.sma calls inside loops
sma20 = ta.sma(volume, 20)

// Crypto-optimized update frequency
base_update_freq = switch tf_mode
    '4H'  => 8
    '1H'  => 5
    '15m' => 3
    '5m'  => 2
    '1m'  => 1
    => 2

final_update_freq = switch execution_sensitivity
    'Ultra'  => 1
    'High'   => math.max(1, int(base_update_freq * 0.5))
    'Medium' => base_update_freq
    => int(base_update_freq * 1.5)

// Enhanced volume and price movement detection
avg_len = int(math.min(30, bar_index + 1))  // Shorter average for crypto
avg_vol_norm = ta.sma(volume, avg_len) / tf_minutes
cur_vol_norm = volume / tf_minutes
cached_atr := ta.atr(14)

vol_spike = cur_vol_norm > avg_vol_norm * 2.0 and avg_vol_norm > 0
price_move = math.abs(close - nz(close[1])) / nz(close[1], 1) > 0.003  // Tighter for crypto
session_change = sess_is_active != f_is_crypto_active_session()

needs_update = barstate.islast or (bar_index - last_calc_bar >= final_update_freq) or vol_spike or price_move or session_change

// Update session info
sess_is_active := f_is_crypto_active_session()
sess_session_multiplier := sess_is_active ? session_weight : 1.0

// Calculate effective lookback for crypto
bars_per_day = 1440 / tf_minutes
effective_lookback = if intraday_mode
    int(math.min(vp_lookback_depth, intraday_lookback_days * bars_per_day))
else
    switch tf_mode
        '4H'  => math.min(vp_lookback_depth, 120)
        '1H'  => math.min(vp_lookback_depth, 200)
        '15m' => math.min(vp_lookback_depth, 400)
        '5m'  => math.min(vp_lookback_depth, 300)
        '1m'  => math.min(vp_lookback_depth, 200)
        => vp_lookback_depth

// Ensure volume_at_price array size matches
if array.size(volume_at_price) != vp_num_levels
    array.clear(volume_at_price)
    for i = 0 to vp_num_levels - 1
        array.push(volume_at_price, 0.0)

if needs_update
    // Enhanced memory cleanup
    f_cleanup_memory_enhanced()
    
    array.fill(volume_at_price, 0.0)
    array.clear(volume_spike_levels)
    
    price_high := ta.highest(high, effective_lookback)
    price_low := ta.lowest(low, effective_lookback)
    price_step := (price_high - price_low) / vp_num_levels

    if price_step > 0
        // Enhanced calculation loop with crypto optimizations
        for b = 0 to math.min(effective_lookback - 1, bar_index)
            is_bullish = close[b] >= open[b]
            include_volume = vp_volume_type == 'Both' or (vp_volume_type == 'Bullish' and is_bullish) or (vp_volume_type == 'Bearish' and not is_bullish)
            
            if not include_volume or volume[b] <= MIN_CRYPTO_VOLUME
                continue
            
            normalized_vol = volume[b] / tf_minutes
            
            // Crypto-specific age decay (faster than traditional markets)
            age_weight = math.exp(-CRYPTO_AGE_DECAY * b)
            
            // Session weighting
            session_weight_factor = sess_session_multiplier
            
            // Volatility adjustment
            volatility_factor = 1.0
            if volatility_adjustment and not na(cached_atr)
                volatility_factor := 1.0 + (cached_atr[b] / close[b] * 2.0)
            
            // Price action weighting
            body_ratio = 1.0
            if price_action_weight
                candle_range = high[b] - low[b]
                if candle_range > 0
                    body_ratio := math.abs(close[b] - open[b]) / candle_range
                    body_ratio := math.max(0.3, body_ratio)  // Minimum weight for wicks
            
            weighted_volume = normalized_vol * age_weight * session_weight_factor * volatility_factor * body_ratio
            
            // Volume spike detection and tracking
            avg_volume_check = sma20[b]
            if f_detect_volume_spike(volume[b], avg_volume_check)
                array.push(volume_spike_levels, (high[b] + low[b]) / 2)
            
            // Enhanced volume distribution
            if volume_distribution_method == 'Standard'
                typical_price = (high[b] + low[b] + close[b]) / 3
                idx = f_price_to_index_crypto(typical_price, price_low, price_step)
                array.set(volume_at_price, idx, array.get(volume_at_price, idx) + weighted_volume * tf_minutes)
            else
                typical_price = (high[b] + low[b] + close[b]) / 3
                vol_distribution = f_distribute_volume_enhanced(typical_price, weighted_volume * tf_minutes, price_low, price_step, volume_distribution_method)
                
                // Add distributed volume to main array
                for j = 0 to math.min(array.size(vol_distribution) - 1, vp_num_levels - 1)
                    if j < array.size(vol_distribution)
                        distributed_vol = array.get(vol_distribution, j)
                        current_vol = array.get(volume_at_price, j)
                        array.set(volume_at_price, j, current_vol + distributed_vol)
        
        // === ENHANCED RENDERING ===
        max_vol = array.max(volume_at_price)
        if max_vol > 0
            poc_idx = array.indexof(volume_at_price, max_vol)
            poc_price = price_low + poc_idx * price_step
            total_vol = f_array_sum_float(volume_at_price)
            va_percentage_to_use = intraday_mode ? intraday_va_percent : vp_va_percent
            [va_low, va_high] = f_calculate_crypto_value_area(poc_idx, total_vol, price_low, price_step, va_percentage_to_use)
            
            x_base = bar_index + vp_right_offset
            hva_threshold_volume = max_vol * vp_hva_threshold / 100
            
            // Render enhanced volume bars
            for i = 0 to vp_num_levels - 1
                level_volume = array.get(volume_at_price, i)
                if level_volume > 0
                    bar_length = int(math.round(level_volume / max_vol * vp_bar_width))
                    if bar_length > 0
                        level_price = price_low + i * price_step
                        
                        // Enhanced color logic
                        is_poc = i == poc_idx
                        is_in_va = vp_show_va and not na(va_low) and level_price >= va_low and level_price <= va_high
                        is_hva = vp_show_hva and level_volume >= hva_threshold_volume

                        box_color = is_poc and vp_show_poc ? vp_poc_color : is_hva ? vp_hva_color : is_in_va ? vp_va_color : vp_vol_color
                        
                        // Create enhanced volume bar — single-line box.new to avoid parser error
                        b = box.new(x_base, level_price + price_step/2, x_base + bar_length, level_price - price_step/2, xloc = xloc.bar_index)
                        box.set_bgcolor(b, box_color)
                        box.set_border_color(b, color.new(box_color, 40))
                        box.set_border_width(b, 1)
                        array.push(mem_volume_boxes, b)

            // Render POC line
            if vp_show_poc and not na(poc_price)
                poc_x1 = bar_index - effective_lookback
                poc_x2 = bar_index + vp_right_offset + vp_bar_width
                poc_line = line.new(poc_x1, poc_price, poc_x2, poc_price, color=vp_poc_color, width=3, style=line.style_solid)
                array.push(mem_key_lines, poc_line)
            
            // Render enhanced VAH/VAL lines
            if vp_show_va_lines and not na(va_high) and not na(va_low)
                line_style = switch vp_va_line_style
                    'Solid' => line.style_solid
                    'Dotted' => line.style_dotted
                    => line.style_dashed
                
                vah_line = line.new(bar_index - effective_lookback, va_high, bar_index + vp_right_offset + vp_bar_width, va_high, 
                                  color=vp_va_color, width=vp_va_line_width, style=line_style)
                val_line = line.new(bar_index - effective_lookback, va_low, bar_index + vp_right_offset + vp_bar_width, va_low, 
                                  color=vp_va_color, width=vp_va_line_width, style=line_style)
                array.push(mem_key_lines, vah_line)
                array.push(mem_key_lines, val_line)
            
            // Mark volume spikes
            if show_volume_spikes and array.size(volume_spike_levels) > 0
                for i = 0 to math.min(array.size(volume_spike_levels) - 1, 10)  // Limit to 10 markers
                    spike_price = array.get(volume_spike_levels, i)
                    spike_marker = label.new(x_base - 5, spike_price, "⚡", color=color.new(vp_spike_color, 0), 
                                           textcolor=vp_spike_color, style=label.style_label_center, size=size.tiny)
                    array.push(mem_spike_markers, spike_marker)
        
        last_price_low := price_low
        last_price_step := price_step
    
    last_calc_bar := bar_index

// Increment cleanup counter
mem_cleanup_counter += 1
if mem_cleanup_counter >= MEMORY_CLEANUP_CYCLE
    mem_needs_cleanup := true