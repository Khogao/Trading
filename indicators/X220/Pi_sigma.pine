// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© lenguyenphi
// Â© 2025 Pi 3.4 Professional - Clean Architecture (No Repainting)
//@version=5
indicator("Pi 3.4 Professional", shorttitle="PI 3.4 Pro", overlay=true, max_labels_count=300, max_boxes_count=300, max_lines_count=200)

// ============================================================================
// INPUT SECTIONS - Organized & Clean
// ============================================================================

// === MASTER PROFILE ===
var GRP_PROFILE = "ðŸ”¥ 1. Master Profile"
profile_selector = input.string("Day Trader", "Trading Profile", options=["Scalper", "Day Trader", "Swing Trader", "Position Trader"], group=GRP_PROFILE)

// === VPP CORE ===
var GRP_VPP = "ðŸ“Š 2. Volume Profile"
vp_lookback = input.int(200, 'VP Lookback', minval=50, maxval=500, group=GRP_VPP)
vp_levels = input.int(100, 'Price Levels', minval=50, maxval=150, group=GRP_VPP)
show_poc = input.bool(true, "POC", group=GRP_VPP, inline="vp1")
show_va = input.bool(true, "Value Area", group=GRP_VPP, inline="vp1")
show_va_lines = input.bool(true, "VA Lines", group=GRP_VPP, inline="vp2")

// === HTF LEVELS ===
var GRP_HTF = "ðŸ”¥ 3. HTF Levels"
htf_enabled = input.bool(true, "Enable HTF", group=GRP_HTF)
htf_timeframe = input.timeframe("240", "HTF Period", group=GRP_HTF)
htf_show_poc = input.bool(true, "HTF POC", group=GRP_HTF, inline="htf1")
htf_show_va = input.bool(true, "HTF VA", group=GRP_HTF, inline="htf1")

// === VSA SIGNALS ===
var GRP_VSA = "ðŸŽ¯ 4. VSA Analysis"
enable_vsa = input.bool(true, "Enable VSA", group=GRP_VSA)
vsa_sensitivity = input.string("Medium", "Sensitivity", options=["Low", "Medium", "High"], group=GRP_VSA)
show_spring = input.bool(true, "Spring", group=GRP_VSA, inline="sig1")
show_upthrust = input.bool(true, "Upthrust", group=GRP_VSA, inline="sig1")
show_climax = input.bool(true, "Climax", group=GRP_VSA, inline="sig2")
show_effort = input.bool(true, "Effort/Result", group=GRP_VSA, inline="sig2")

// === TREND CONTEXT ===
var GRP_TREND = "ðŸŒŠ 5. Trend Context"
show_ema = input.bool(true, "EMA Lines", group=GRP_TREND)
ema_fast = input.int(21, "Fast EMA", group=GRP_TREND, minval=5, maxval=50)
ema_slow = input.int(50, "Slow EMA", group=GRP_TREND, minval=20, maxval=100)
ema_long = input.int(200, "Long EMA", group=GRP_TREND, minval=100, maxval=300)
show_cloud = input.bool(true, "EMA Cloud", group=GRP_TREND)

// === DISPLAY ===
var GRP_DISPLAY = "ðŸ“± 6. Display"
show_info = input.bool(true, "Info Panel", group=GRP_DISPLAY)
info_position = input.string("top_right", "Panel Position", 
     options=["top_left", "top_right", "bottom_left", "bottom_right"], group=GRP_DISPLAY)
show_background = input.bool(false, "VSA Background", group=GRP_DISPLAY)

// === COLORS ===
var GRP_COLORS = "ðŸŽ¨ 7. Colors"
color_poc = input.color(color.new(color.red, 0), "POC", group=GRP_COLORS, inline="c1")
color_va = input.color(color.new(color.blue, 70), "Value Area", group=GRP_COLORS, inline="c1")
color_htf_poc = input.color(color.new(color.purple, 0), "HTF POC", group=GRP_COLORS, inline="c2")
color_htf_va = input.color(color.new(color.orange, 50), "HTF VA", group=GRP_COLORS, inline="c2")

// ============================================================================
// PROFILE CONFIGURATION - Clean Logic
// ============================================================================

// FIX: Proper type declarations with initial values
var int lookback_bars = 200
var bool intraday_mode = true
var float vol_threshold = 1.8
var float range_threshold = 0.7

switch profile_selector
    "Scalper" => 
        lookback_bars := 100
        intraday_mode := true
        vol_threshold := 1.5
        range_threshold := 0.8
    "Day Trader" => 
        lookback_bars := 200
        intraday_mode := true
        vol_threshold := 1.8
        range_threshold := 0.7
    "Swing Trader" => 
        lookback_bars := 400
        intraday_mode := false
        vol_threshold := 2.0
        range_threshold := 0.6
    "Position Trader" => 
        lookback_bars := 600
        intraday_mode := false
        vol_threshold := 2.2
        range_threshold := 0.5

// Use custom or profile settings
final_lookback = vp_lookback > 0 ? vp_lookback : lookback_bars

// ============================================================================
// CORE VP ENGINE - Stable & Reliable
// ============================================================================

// VP Variables - GLOBAL SCOPE with proper type declarations
var array<float> volume_at_price = array.new<float>()
var array<box> vp_boxes = array.new<box>()
var float poc_price = na
var float va_high = na
var float va_low = na
// Cache the last computed price range to reuse when not updating
var float g_price_low = na
var float g_price_high = na
var float g_price_step = na

// Helper Functions
f_price_to_index(price, low_price, step) =>
    step > 0 ? math.round((price - low_price) / step) : 0

// FIX: Make function callable each bar; throttle heavy calc via do_update flag and cached values
// CHANGED: accept highest_price and lowest_price as parameters (extracted from internal scope)
f_calculate_vp(bool do_update, float highest_price, float lowest_price) =>
    // Default to cached values
    result_low = g_price_low
    result_high = g_price_high
    result_step = g_price_step
    float result_poc = poc_price
    float result_vah = va_high
    float result_val = va_low

    // Compute if updating or we have no cache yet
    if do_update or na(result_step)
        array.clear(volume_at_price)
        for i = 0 to vp_levels - 1
            array.push(volume_at_price, 0.0)
        
        // CHANGED: price_step now uses passed-in highest/lowest
        price_step = (highest_price - lowest_price) / vp_levels
        
        float local_poc_price = na
        float local_va_high = na
        float local_va_low = na
        
        if price_step > 0
            for i = 0 to final_lookback - 1
                if i <= bar_index and volume[i] > 0
                    bar_low = low[i]
                    bar_high = high[i]
                    bar_volume = volume[i]
                    
                    start_idx = f_price_to_index(bar_low, lowest_price, price_step)
                    end_idx = f_price_to_index(bar_high, lowest_price, price_step)
                    
                    start_idx := math.max(0, math.min(vp_levels - 1, start_idx))
                    end_idx := math.max(0, math.min(vp_levels - 1, end_idx))
                    
                    levels_covered = math.max(1, end_idx - start_idx + 1)
                    volume_per_level = bar_volume / levels_covered
                    
                    for j = start_idx to end_idx
                        if j >= 0 and j < vp_levels
                            current_vol = array.get(volume_at_price, j)
                            array.set(volume_at_price, j, current_vol + volume_per_level)
            
            max_volume = array.max(volume_at_price)
            if max_volume > 0
                poc_index = array.indexof(volume_at_price, max_volume)
                local_poc_price := lowest_price + poc_index * price_step
                
                target_volume = array.sum(volume_at_price) * 0.70
                va_volume = max_volume
                va_upper = poc_index
                va_lower = poc_index
                
                while va_volume < target_volume and (va_upper < vp_levels - 1 or va_lower > 0)
                    vol_above = va_upper < vp_levels - 1 ? array.get(volume_at_price, va_upper + 1) : 0
                    vol_below = va_lower > 0 ? array.get(volume_at_price, va_lower - 1) : 0
                    
                    if vol_above >= vol_below and va_upper < vp_levels - 1
                        va_upper += 1
                        va_volume += vol_above
                    else if va_lower > 0
                        va_lower -= 1
                        va_volume += vol_below
                    else
                        break
                
                local_va_high := lowest_price + va_upper * price_step
                local_va_low := lowest_price + va_lower * price_step
        
        // Update results to return
        result_low := lowest_price
        result_high := highest_price
        result_step := price_step
        result_poc := local_poc_price
        result_vah := local_va_high
        result_val := local_va_low
    
    [result_low, result_high, result_step, result_poc, result_vah, result_val]

// ============================================================================
// HTF ANALYSIS - No Repainting
// ============================================================================

// Simple HTF POC calculation (no complex dependencies)
f_htf_poc() =>
    request.security(syminfo.tickerid, htf_timeframe, 
         ta.highest(volume, 20) > ta.sma(volume, 20) * 2 ? (high + low) / 2 : na,
         lookahead=barmerge.lookahead_off)

f_htf_support() =>
    request.security(syminfo.tickerid, htf_timeframe,
         ta.lowest(low, 20),
         lookahead=barmerge.lookahead_off)

f_htf_resistance() =>
    request.security(syminfo.tickerid, htf_timeframe,
         ta.highest(high, 20),
         lookahead=barmerge.lookahead_off)

// HTF Data
htf_poc = htf_enabled ? f_htf_poc() : na
htf_support = htf_enabled ? f_htf_support() : na
htf_resistance = htf_enabled ? f_htf_resistance() : na

// ============================================================================
// VSA ANALYSIS - Clean & Reliable
// ============================================================================

// Bar Analysis Type
type BarAnalysis
    bool is_up
    bool is_down
    bool high_volume
    bool low_volume
    bool wide_range
    bool narrow_range
    float close_position

// VSA Functions
f_analyze_bar() =>
    vol_ma = ta.sma(volume, 20)
    range_ma = ta.sma(high - low, 20)
    current_range = high - low
    
    // Volume analysis
    vol_ratio = vol_ma > 0 ? volume / vol_ma : 1.0
    is_high_vol = vol_ratio > vol_threshold
    is_low_vol = vol_ratio < (1.0 / vol_threshold)
    
    // Range analysis  
    range_ratio = range_ma > 0 ? current_range / range_ma : 1.0
    is_wide = range_ratio > (1.0 / range_threshold)
    is_narrow = range_ratio < range_threshold
    
    // Close position
    close_pos = current_range > 0 ? (close - low) / current_range : 0.5
    
    // Put constructor on one line to avoid line-continuation parse issues
    BarAnalysis.new(close > open, close < open, is_high_vol, is_low_vol, is_wide, is_narrow, close_pos)

// VSA Signals
bar_data = f_analyze_bar()

// Support/Resistance levels
support_level = ta.lowest(low, 20)[1]
resistance_level = ta.highest(high, 20)[1]

// VSA Patterns
is_spring = enable_vsa and show_spring and 
     bar_data.is_down and low <= support_level and 
     close > low + (high - low) * 0.3 and bar_data.high_volume

is_upthrust = enable_vsa and show_upthrust and 
     bar_data.is_up and high >= resistance_level and 
     close < high - (high - low) * 0.3 and bar_data.high_volume

is_selling_climax = enable_vsa and show_climax and 
     bar_data.is_down and bar_data.wide_range and bar_data.high_volume

is_buying_climax = enable_vsa and show_climax and 
     bar_data.is_up and bar_data.wide_range and bar_data.high_volume

is_effort_no_result = enable_vsa and show_effort and 
     bar_data.high_volume and bar_data.narrow_range

// VSA Score
vsa_score = 0.0
vsa_score += is_spring ? 3.0 : 0
vsa_score += is_selling_climax ? 2.0 : 0
vsa_score -= is_upthrust ? 3.0 : 0
vsa_score -= is_buying_climax ? 2.0 : 0
vsa_score -= is_effort_no_result ? 1.0 : 0

// ============================================================================
// EXECUTION & PLOTTING
// ============================================================================

// Update VP calculation (optimized frequency)
should_update = barstate.islast or bar_index % 5 == 0

// CHANGED: Precompute rolling extremes each bar (extracted from f_calculate_vp to ensure consistency)
hi_lookback = ta.highest(high, final_lookback)
lo_lookback = ta.lowest(low, final_lookback)

// CHANGED: Pass precomputed hi/lo into f_calculate_vp
[calc_low, calc_high, calc_step, calc_poc, calc_vah, calc_val] = f_calculate_vp(should_update, hi_lookback, lo_lookback)
if should_update
    g_price_low := calc_low
    g_price_high := calc_high
    g_price_step := calc_step
    poc_price := calc_poc
    va_high := calc_vah
    va_low := calc_val

// EMA Lines
ema_fast_value = ta.ema(close, ema_fast)
ema_slow_value = ta.ema(close, ema_slow) 
ema_long_value = ta.ema(close, ema_long)

// Precompute ATR each bar for consistency
atr_value = ta.atr(14)

plot(show_ema ? ema_fast_value : na, "Fast EMA", color.aqua, 1)
plot(show_ema ? ema_slow_value : na, "Slow EMA", color.orange, 1)
plot(show_ema ? ema_long_value : na, "Long EMA", color.gray, 2)

// EMA Cloud
p1 = plot(show_ema ? ema_fast_value : na, color=na)
p2 = plot(show_ema ? ema_slow_value : na, color=na)
fill(p1, p2, 
     color=show_cloud and show_ema ? 
          (ema_fast_value > ema_slow_value ? color.new(color.green, 85) : color.new(color.red, 85)) : na)

// HTF Lines
plot(htf_show_poc and not na(htf_poc) ? htf_poc : na, 
     "HTF POC", color_htf_poc, 2, plot.style_line)
plot(htf_show_va and not na(htf_support) ? htf_support : na, 
     "HTF Support", color_htf_va, 1, plot.style_line)
plot(htf_show_va and not na(htf_resistance) ? htf_resistance : na, 
     "HTF Resistance", color_htf_va, 1, plot.style_line)

// POC Line
plot(show_poc and not na(poc_price) ? poc_price : na, 
     "POC", color_poc, 2, plot.style_line)

// VA Lines  
// CHANGED: Use a valid plot style (plot.style_line). Dashed style is not available for plot().
plot(show_va_lines and not na(va_high) ? va_high : na, 
     "VAH", color_va, 1, plot.style_line)
plot(show_va_lines and not na(va_low) ? va_low : na, 
     "VAL", color_va, 1, plot.style_line)

// Background
bgcolor(show_background and math.abs(vsa_score) > 2 ? 
     (vsa_score > 0 ? color.new(color.green, 90) : color.new(color.red, 90)) : na)

// VSA Labels
if barstate.isconfirmed and enable_vsa
    // Use precomputed ATR
    if is_spring
        label.new(bar_index, low - atr_value * 0.5, "Spring", 
             textcolor=color.green, style=label.style_none, size=size.small)
    if is_upthrust  
        label.new(bar_index, high + atr_value * 0.5, "Upthrust", 
             textcolor=color.red, style=label.style_none, size=size.small)
    if is_selling_climax
        label.new(bar_index, low - atr_value * 0.3, "SC", 
             textcolor=color.blue, style=label.style_none, size=size.tiny)
    if is_buying_climax
        label.new(bar_index, high + atr_value * 0.3, "BC", 
             textcolor=color.purple, style=label.style_none, size=size.tiny)

// Info Panel
var table info_table = na

if show_info and barstate.islast
    pos = switch info_position
        "top_left" => position.top_left
        "top_right" => position.top_right  
        "bottom_left" => position.bottom_left
        => position.bottom_right
    
    if na(info_table)
        info_table := table.new(pos, 2, 8, 
             bgcolor=color.new(color.white, 85), border_width=1)
    
    // Trend analysis
    trend_fast = close > ema_fast_value ? "â†—" : "â†˜"
    trend_medium = ema_fast_value > ema_slow_value ? "BULL" : "BEAR"
    trend_long = close > ema_long_value ? "BULL" : "BEAR"
    
    table.cell(info_table, 0, 0, "PI 3.4 Pro", bgcolor=color.new(color.blue, 80), text_color=color.white)
    table.cell(info_table, 1, 0, profile_selector, text_color=color.gray)
    
    table.cell(info_table, 0, 1, "Trend Fast", text_color=color.black)
    table.cell(info_table, 1, 1, trend_fast, text_color=close > ema_fast_value ? color.green : color.red)
    
    table.cell(info_table, 0, 2, "Trend Med", text_color=color.black)
    table.cell(info_table, 1, 2, trend_medium, text_color=ema_fast_value > ema_slow_value ? color.green : color.red)
    
    table.cell(info_table, 0, 3, "Trend Long", text_color=color.black)  
    table.cell(info_table, 1, 3, trend_long, text_color=close > ema_long_value ? color.green : color.red)
    
    table.cell(info_table, 0, 4, "Volume", text_color=color.black)
    vol_status = bar_data.high_volume ? "HIGH" : bar_data.low_volume ? "LOW" : "NORMAL"
    table.cell(info_table, 1, 4, vol_status, 
         text_color=bar_data.high_volume ? color.red : bar_data.low_volume ? color.gray : color.blue)
    
    table.cell(info_table, 0, 5, "VSA Score", text_color=color.black)
    table.cell(info_table, 1, 5, str.tostring(vsa_score, "#.#"), 
         text_color=vsa_score > 0 ? color.green : vsa_score < 0 ? color.red : color.gray)
    
    table.cell(info_table, 0, 6, "POC", text_color=color.black)
    table.cell(info_table, 1, 6, not na(poc_price) ? str.tostring(poc_price, format.mintick) : "N/A", 
         text_color=color_poc)
    
    table.cell(info_table, 0, 7, "HTF POC", text_color=color.black)
    table.cell(info_table, 1, 7, not na(htf_poc) ? str.tostring(htf_poc, format.mintick) : "N/A", 
         text_color=color_htf_poc)

// Alerts
alertcondition(is_spring, "Spring Signal", "Spring pattern detected")
alertcondition(is_upthrust, "Upthrust Signal", "Upthrust pattern detected") 
alertcondition(vsa_score > 2.5, "Strong Bullish VSA", "Strong bullish VSA confluence")
alertcondition(vsa_score < -2.5, "Strong Bearish VSA", "Strong bearish VSA confluence")