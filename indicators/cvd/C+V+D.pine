//@version=5
// TITLE: VSA + CVD Overlay (v2.0 - Dual Divergence)
// DESC: Upgraded to include both traditional Volume divergence and high-precision CVD divergence.
indicator("Cvd+Vol+Div (v2.0 - Dual Divergence)", overlay=true, max_labels_count=500)

// === INPUTS ===
lenVolMA = input.int(20, "Volume MA Length", minval=1, group="VSA Settings")
zscoreSens = input.float(1.8, "VSA Z-score Sensitivity", step=0.1, group="VSA Settings")
markerOffset = input.float(1.05, "Marker Offset Factor", step=0.01, group="VSA Settings")
lookbackScale = input.int(50, "Lookback for Volume Scaling", group="VSA Settings")

showBullish = input.bool(true, "Show Bullish Signals", group="Display Settings")
showBearish = input.bool(true, "Show Bearish Signals", group="Display Settings")
showNeutral = input.bool(true, "Show Neutral Signals", group="Display Settings")
volHeightPct = input.float(0.05, "Volume Height % of Price Range", step=0.01, group="Display Settings")

// === DIVERGENCE SETTINGS ===
divLookback = input.int(10, "Divergence Lookback", minval=5, maxval=30, group="Divergence Analysis")
showVolumeDivergence = input.bool(true, "Show Price-Volume Divergence", group="Divergence Analysis")
// MỚI: Thêm công tắc bật/tắt cho Phân kỳ CVD
showCvdDivergence = input.bool(true, "Show Price-CVD Divergence", group="Divergence Analysis")


// === CVD SETTINGS ===
anchorInput = input.timeframe("1D", "CVD Anchor Period", group="CVD Settings")
cvdLookback = input.int(50, "CVD Scaling Lookback", group="CVD Settings")
cvdTransparency = input.int(80, "CVD Transparency", minval=0, maxval=100, group="CVD Settings")
cvdBullColor = input.color(color.new(color.blue, 0), "CVD Bull Color", group="CVD Settings")
cvdBearColor = input.color(color.new(color.orange, 0), "CVD Bear Color", group="CVD Settings")

// === Volume Classification ===
f_zscore(v, len) =>
    mean = ta.sma(v, len)
    sd = ta.stdev(v, len)
    sd > 0 ? (v - mean) / sd : 0

volZ = f_zscore(volume, lenVolMA)
volMA = ta.sma(volume, lenVolMA)
isUltraHigh = volZ >= zscoreSens * 1.5
isVeryHigh  = volZ >= zscoreSens * 1.2 and volZ < zscoreSens * 1.5
isHigh      = volZ >= zscoreSens

// === Candle Geometry ===
spread = high - low
body   = math.abs(close - open)
upperWick = high - math.max(open, close)
lowerWick = math.min(open, close) - low
spreadMA = ta.sma(spread, 20)
spreadWide = spreadMA > 0 ? spread > spreadMA * 1.2 : true
closePos = spread > 0 ? (close - low) / spread : 0.5
isUp = close > open
isDown = close < open
lowVol = volume < volume[1] and volume < volume[2] and volume < volMA

// === 15 VSA Signals ===
isSC  = isDown and spreadWide and (isHigh or isVeryHigh or isUltraHigh) and (lowerWick/spread > 0.35) and (closePos > 0.35)
isSPR = isDown and (isHigh or isVeryHigh or isUltraHigh) and (lowerWick/spread > 0.4) and (closePos > 0.5)
isNS  = isDown and spread < spreadMA * 0.8 and lowVol and (closePos < 0.45)
isTest = isDown and spread < spreadMA * 0.8 and lowVol and (closePos > 0.6)
isShakeout = (lowerWick/spread > 0.5) and (isHigh or isVeryHigh or isUltraHigh) and (closePos > 0.6)
isSpring = low < ta.lowest(low, 20)[1] and close > open and (isHigh or isVeryHigh or isUltraHigh)
isAbsorption = isUp and (isHigh or isVeryHigh or isUltraHigh) and close >= close[1] and close[1] >= close[2]
isBC  = isUp and spreadWide and (isHigh or isVeryHigh or isUltraHigh) and (upperWick/spread > 0.35) and (closePos < 0.65)
isUT  = spread > 0 and (upperWick/spread > 0.55) and (closePos < 0.35) and (isHigh or isVeryHigh or isUltraHigh)
isND  = isUp and spread < spreadMA * 0.8 and lowVol and (closePos > 0.55)
isUTAD = high > ta.highest(high, 20)[1] and close < open and (isHigh or isVeryHigh or isUltraHigh)
isSupplyIn = isUp and (isHigh or isVeryHigh or isUltraHigh) and (closePos < 0.4)
isEffortFall = isDown and (isHigh or isVeryHigh or isUltraHigh) and spreadWide
isSquat = (isHigh or isVeryHigh or isUltraHigh) and spread < spreadMA * 0.8 and closePos > 0.4 and closePos < 0.6
isEffortVsResult = (isHigh or isVeryHigh or isUltraHigh) and spread < spreadMA * 0.8

// === Signal Mapping ===
bullishMap = array.from("SC","SR","NS","TE","SO","SP","AB")
bearishMap = array.from("BC","UT","ND","UA","SI","EF")
neutralMap = array.from("SQ","ER")
bullColor = color.new(color.green, 0)
bearColor = color.new(color.red, 0)
neutralColor = color.new(color.gray, 0)

// === CVD Calculation ===
// Ta.cum(ta.change(close) > 0 ? volume : ta.change(c) < 0 ? -volume : 0) is a simplified CVD.
// For higher precision, it's better to request lower timeframe data if available.
var float lastVol = 0.0
changeC = ta.change(close)
delta = changeC > 0 ? volume : changeC < 0 ? -volume : 0
isNewAnchor = ta.change(time(anchorInput)) != 0
if isNewAnchor
    lastVol := delta
else
    lastVol := nz(lastVol[1]) + delta

// === Divergence Calculation ===
var bool bullishVolDiv = na
var bool bearishVolDiv = na
var bool bullishCvdDiv = na
var bool bearishCvdDiv = na

priceMomentum = ta.mom(close, divLookback)

if showVolumeDivergence
    volumeMomentum = ta.mom(volume, divLookback)
    bullishVolDiv := priceMomentum < 0 and volumeMomentum > 0 and (isHigh or isVeryHigh or isUltraHigh)
    bearishVolDiv := priceMomentum > 0 and volumeMomentum < 0 and lowVol

// MỚI: Thêm khối logic để tính Phân kỳ CVD
if showCvdDivergence
    cvdMomentum = ta.mom(lastVol, divLookback)
    bullishCvdDiv := priceMomentum < 0 and cvdMomentum > 0
    bearishCvdDiv := priceMomentum > 0 and cvdMomentum < 0

plotshape(bullishVolDiv, "Bullish Volume Div", shape.triangleup, location.belowbar, color.new(color.blue, 0), size=size.small)
plotshape(bearishVolDiv, "Bearish Volume Div", shape.triangledown, location.abovebar, color.new(color.purple, 0), size=size.small)
// MỚI: Vẽ các tín hiệu Phân kỳ CVD
plotshape(bullishCvdDiv, "Bullish CVD Div", shape.labelup, location.belowbar, color.new(color.aqua, 0), text="CVD+", textcolor=color.white, size=size.tiny)
plotshape(bearishCvdDiv, "Bearish CVD Div", shape.labeldown, location.abovebar, color.new(color.fuchsia, 0), text="CVD-", textcolor=color.white, size=size.tiny)


// === Scale and Plot Volume & CVD ===
priceLow = ta.lowest(low, lookbackScale)
priceHigh = ta.highest(high, lookbackScale)
priceRange = priceHigh - priceLow
maxVol = ta.highest(volume, lookbackScale)
scaledVol = priceRange > 0 and maxVol > 0 ? (volume / maxVol) * (priceRange * volHeightPct) : 0
volBase = priceLow
plot(volBase + scaledVol, "Volume", color.new(color.gray, 70), style=plot.style_columns)

// --- CVD Plotting ---
openCvd  = nz(lastVol[1], lastVol)
highCvd  = math.max(openCvd, lastVol)
lowCvd   = math.min(openCvd, lastVol)
closeCvd = lastVol

cvdMax = ta.highest(lastVol, cvdLookback)
cvdMin = ta.lowest(lastVol, cvdLookback)
cvdRange = cvdMax - cvdMin
scaleFactorCVD = cvdRange > 0 ? (priceRange * volHeightPct) / cvdRange * 0.8 : 1
scaledOpen = volBase + (openCvd - cvdMin) * scaleFactorCVD
scaledHigh = volBase + (highCvd - cvdMin) * scaleFactorCVD
scaledLow = volBase + (lowCvd - cvdMin) * scaleFactorCVD
scaledClose = volBase + (closeCvd - cvdMin) * scaleFactorCVD
cvdIsBull = closeCvd >= openCvd
cvdBodyColor = cvdIsBull ? color.new(cvdBullColor, cvdTransparency) : color.new(cvdBearColor, cvdTransparency)
plotcandle(scaledOpen, scaledHigh, scaledLow, scaledClose, "CVD", color=cvdBodyColor, wickcolor=cvdBodyColor, bordercolor=na)

// === Marker Function ===
f_marker(cond, code) =>
    if cond
        isBull = array.includes(bullishMap, code)
        isBear = array.includes(bearishMap, code)
        col = isBull ? bullColor : isBear ? bearColor : neutralColor
        arrow = isBull ? "▲" : isBear ? "▼" : "◄►"
        if (isBull and showBullish) or (isBear and showBearish) or (not isBull and not isBear and showNeutral)
            label.new(bar_index, volBase + scaledVol * markerOffset, code + arrow, style=label.style_label_center, textcolor=color.white, color=col, size=size.tiny)

// === Plot Markers ===
f_marker(isSC, "SC")
f_marker(isSPR, "SR")
f_marker(isNS, "NS")
f_marker(isTest, "TE")
f_marker(isShakeout, "SO")
f_marker(isSpring, "SP")
f_marker(isAbsorption, "AB")

f_marker(isBC, "BC")
f_marker(isUT, "UT")
f_marker(isND, "ND")
f_marker(isUTAD, "UA")
f_marker(isSupplyIn, "SI")
f_marker(isEffortFall, "EF")

f_marker(isSquat, "SQ")
f_marker(isEffortVsResult, "ER")