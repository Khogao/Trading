// Â© 2025 Multi-Timeframe Precision Scalping VSA - Professional Edition v6
// @version=6
indicator("MTF Precision Scalp VSA", shorttitle="MTF VSA", overlay=true, max_labels_count=30)

// === CÃ€I Äáº¶T KHUNG THá»œI GIAN ÄA Cáº¤P ===
htf_trend = input.string("4H", "Khung Xu HÆ°á»›ng", options=["1H", "4H", "1D"], group="ğŸ“Š PHÃ‚N TÃCH ÄA KHUNG")
htf_structure = input.string("1H", "Khung Cáº¥u TrÃºc", options=["1H", "4H"], group="ğŸ“Š PHÃ‚N TÃCH ÄA KHUNG") 
enableHTFBias = input.bool(true, "Báº­t Lá»c Xu HÆ°á»›ng HTF", group="ğŸ“Š PHÃ‚N TÃCH ÄA KHUNG")
enableKeyLevels = input.bool(true, "PhÃ¡t Hiá»‡n Key Levels", group="ğŸ“Š PHÃ‚N TÃCH ÄA KHUNG")
confluenceRequired = input.int(2, "Sá»‘ Confluence Cáº§n Thiáº¿t", minval=1, maxval=4, group="ğŸ“Š PHÃ‚N TÃCH ÄA KHUNG")

// === THIáº¾T Láº¬P KEY LEVELS ===
showHTFLevels = input.bool(true, "Hiá»‡n HTF Support/Resistance", group="ğŸ¯ KEY LEVELS")
fibRetrace = input.bool(true, "Fibonacci Retracements", group="ğŸ¯ KEY LEVELS")
volumeProfile = input.bool(true, "Volume Profile Nodes", group="ğŸ¯ KEY LEVELS")
keyLevelTolerance = input.float(0.5, "Key Level Tolerance (%)", minval=0.1, maxval=2.0, step=0.1, group="ğŸ¯ KEY LEVELS")

// === QUáº¢N LÃ Rá»¦I RO ===
enableRiskReward = input.bool(true, "TÃ­nh ToÃ¡n Risk/Reward", group="âš–ï¸ QUáº¢N LÃ Rá»¦I RO")
minRiskReward = input.float(2.0, "R:R Tá»‘i Thiá»ƒu", minval=1.0, maxval=10.0, step=0.5, group="âš–ï¸ QUáº¢N LÃ Rá»¦I RO")
autoStopLoss = input.bool(true, "Tá»± Äá»™ng TÃ­nh Stop Loss", group="âš–ï¸ QUáº¢N LÃ Rá»¦I RO")

// === CHáº¾ Äá»˜ SCALPING ===
scalpMode = input.string("Precision", "Cháº¿ Äá»™", options=["Ultra Precision", "Precision", "Balanced"], group="ğŸ¯ PRECISION SCALPING")
patienceMode = input.bool(true, "Cháº¿ Äá»™ KiÃªn Nháº«n", group="ğŸ¯ PRECISION SCALPING")
onlyKeyLevelSignals = input.bool(true, "Chá»‰ Signal Táº¡i Key Levels", group="ğŸ¯ PRECISION SCALPING")

// === VSA CRYPTO CORE ===
liquidationDetection = input.bool(true, "PhÃ¡t Hiá»‡n Thanh LÃ½", group="ğŸš€ VSA CRYPTO")
whaleActivity = input.bool(true, "Hoáº¡t Äá»™ng CÃ¡ Voi", group="ğŸš€ VSA CRYPTO")
washTradingFilter = input.bool(true, "Lá»c Khá»‘i LÆ°á»£ng áº¢o", group="ğŸš€ VSA CRYPTO")
instantMomentum = input.bool(true, "Momentum Tá»©c Thá»i", group="ğŸš€ VSA CRYPTO")

// === Cáº¢M BÃO NÃ‚NG CAO ===
fakeBreakoutDetection = input.bool(true, "PhÃ¡t Hiá»‡n Fake Breakout", group="ğŸ¦ˆ Cáº¢M BÃO NÃ‚NG CAO")
longSqueezeDetection = input.bool(true, "PhÃ¡t Hiá»‡n Long Squeeze", group="ğŸ¦ˆ Cáº¢M BÃO NÃ‚NG CAO")
shortSqueezeDetection = input.bool(true, "PhÃ¡t Hiá»‡n Short Squeeze", group="ğŸ¦ˆ Cáº¢M BÃO NÃ‚NG CAO")

// === GIAO DIá»†N ===
showConfluence = input.bool(true, "Hiá»‡n Confluence Count", group="ğŸ“± GIAO DIá»†N") 
showRiskReward = input.bool(true, "Hiá»‡n R:R Ratio", group="ğŸ“± GIAO DIá»†N")
vietnameseUI = input.bool(true, "Giao Diá»‡n Tiáº¿ng Viá»‡t", group="ğŸ“± GIAO DIá»†N")

// === HIá»‚N THá»Š LEVELS ===
showKeyEntryLines = input.bool(false, "Káº» Key Entry Lines", group="ğŸ“ HIá»‚N THá»Š LEVELS")

// === AUTO TIMEFRAME DETECTION ===
current_tf_minutes = timeframe.in_seconds() / 60
is_scalping_tf = current_tf_minutes <= 15

// Adaptive parameters
precision_mult = switch scalpMode
    "Ultra Precision" => 0.5
    "Precision" => 0.8
    "Balanced" => 1.2

// === TYPE DEFINITIONS ===
type MTFSignal
    bool htf_bias_bull
    bool htf_bias_bear
    bool at_key_level
    int confluence_count
    float risk_reward_ratio
    bool vsa_signal_bull
    bool vsa_signal_bear
    float setup_quality
    string setup_type

// === UTILITY FUNCTIONS ===
f_zlema(src, length) =>
    lag = math.round((length - 1) / 2)
    ema_data = src + (src - src[lag])
    ta.ema(ema_data, length)

// === MULTI-TIMEFRAME ANALYSIS ===
f_getHTFTrend() =>
    htf_close = request.security(syminfo.tickerid, htf_trend, close, lookahead=barmerge.lookahead_off)
    htf_ema21 = request.security(syminfo.tickerid, htf_trend, ta.ema(close, 21), lookahead=barmerge.lookahead_off)
    htf_ema50 = request.security(syminfo.tickerid, htf_trend, ta.ema(close, 50), lookahead=barmerge.lookahead_off)
    
    strong_bull_bias = htf_close > htf_ema21 and htf_ema21 > htf_ema50
    strong_bear_bias = htf_close < htf_ema21 and htf_ema21 < htf_ema50
    bias_strength = math.abs(htf_close - htf_ema21) / htf_ema21 * 100
    
    [strong_bull_bias, strong_bear_bias, bias_strength]

f_getHTFLevels() =>
    htf_high = request.security(syminfo.tickerid, htf_structure, ta.highest(high, 20), lookahead=barmerge.lookahead_off)
    htf_low = request.security(syminfo.tickerid, htf_structure, ta.lowest(low, 20), lookahead=barmerge.lookahead_off)
    [htf_high, htf_low]

f_getFibonacciLevels() =>
    if not fibRetrace
        [na, na]
    else
        swing_high = ta.highest(high, 50)
        swing_low = ta.lowest(low, 50)
        range_val = swing_high - swing_low
        fib_618 = swing_high - (range_val * 0.618)
        fib_50 = swing_high - (range_val * 0.5)
        [fib_618, fib_50]

// === KEY LEVEL CONFLUENCE ===
f_detectConfluence(price) =>
    confluence_count = 0
    tolerance = keyLevelTolerance / 100
    
    [htf_high, htf_low] = f_getHTFLevels()
    if showHTFLevels
        if not na(htf_high) and math.abs(price - htf_high) / price < tolerance
            confluence_count += 1
        if not na(htf_low) and math.abs(price - htf_low) / price < tolerance
            confluence_count += 1
    
    [fib_618, fib_50] = f_getFibonacciLevels()
    if fibRetrace and not na(fib_618)
        if math.abs(price - fib_618) / price < tolerance
            confluence_count += 1
        if math.abs(price - fib_50) / price < tolerance
            confluence_count += 1
    
    confluence_count

// === VSA ANALYSIS ===
f_instantMomentum() =>
    if not instantMomentum
        [false, false]
    else
        fast_zlema = f_zlema(close, 3)
        slow_zlema = f_zlema(close, 7)
        momentum = (fast_zlema - slow_zlema) / slow_zlema * 100
        
        threshold = 0.08 * precision_mult
        bull_momentum = momentum > threshold
        bear_momentum = momentum < -threshold
        
        [bull_momentum, bear_momentum]

f_analyzeVolume() =>
    lookback = 15
    base_vol = ta.sma(volume, lookback)
    vol_ratio = volume / base_vol
    
    is_high_vol = vol_ratio > 1.4
    is_surge = vol_ratio > 1.8
    
    [is_high_vol, is_surge]

f_detectLiquidation() =>
    if not liquidationDetection
        [false, false]
    else
        [vol_high, vol_surge] = f_analyzeVolume()
        volume_spike = vol_surge
        wide_spread = (high - low) > ta.atr(20) * 1.5
        
        bull_liq = volume_spike and wide_spread and close > open
        bear_liq = volume_spike and wide_spread and close < open
        
        [bull_liq, bear_liq]

f_detectWhaleActivity() =>
    if not whaleActivity
        [false, false]
    else
        [vol_high, vol_surge] = f_analyzeVolume()
        large_volume = vol_high or vol_surge
        price_suppression = (high - low) < ta.atr(20) * 0.7
        close_location = (close - low) / (high - low)
        
        whale_accumulation = large_volume and price_suppression and close_location > 0.65
        whale_distribution = large_volume and price_suppression and close_location < 0.35
        
        [whale_accumulation, whale_distribution]

f_detectFakeBreakout() =>
    if not fakeBreakoutDetection
        [false, false]
    else
        lookback = 15
        resistance = ta.highest(high, lookback)
        support = ta.lowest(low, lookback)
        
        fake_break_up = high > resistance[1] and close < resistance[1] and volume > ta.sma(volume, 15) * 1.5
        fake_break_down = low < support[1] and close > support[1] and volume > ta.sma(volume, 15) * 1.5
        
        [fake_break_up, fake_break_down]

f_detectLongSqueeze() =>
    if not longSqueezeDetection
        false
    else
        sharp_drop = (close - open) / open < -0.005
        high_volume = volume > ta.sma(volume, 20) * 1.6
        cascade_pattern = close < close[1] and close[1] < close[2]
        
        sharp_drop and high_volume and cascade_pattern

f_detectShortSqueeze() =>
    if not shortSqueezeDetection
        false
    else
        sharp_rise = (close - open) / open > 0.005
        high_volume = volume > ta.sma(volume, 20) * 1.6
        squeeze_pattern = close > close[1] and close[1] > close[2]
        
        sharp_rise and high_volume and squeeze_pattern

// === RISK/REWARD CALCULATION ===
f_calculateRiskReward(entry_price, is_long) =>
    if not enableRiskReward
        [na, na, na]
    else
        atr_val = ta.atr(20)
        if autoStopLoss
            stop_distance = atr_val
            stop_loss = is_long ? entry_price - stop_distance : entry_price + stop_distance
        else
            stop_loss = na
        
        [htf_high, htf_low] = f_getHTFLevels()
        target = is_long ? htf_high : htf_low
        
        if not na(stop_loss) and not na(target)
            risk = math.abs(entry_price - stop_loss)
            reward = math.abs(target - entry_price)
            rr_ratio = reward / risk
            [stop_loss, target, rr_ratio]
        else
            [na, na, na]

// === MAIN SIGNAL GENERATION ===
f_generateMTFSignal() =>
    [htf_bull, htf_bear, bias_strength] = f_getHTFTrend()
    confluence_count = f_detectConfluence(close)
    at_key_level = confluence_count >= confluenceRequired
    
    [instant_bull, instant_bear] = f_instantMomentum()
    [liq_bull, liq_bear] = f_detectLiquidation()
    [whale_acc, whale_dist] = f_detectWhaleActivity()
    [fake_up, fake_down] = f_detectFakeBreakout()
    long_squeeze = f_detectLongSqueeze()
    short_squeeze = f_detectShortSqueeze()
    
    vsa_bull = instant_bull or liq_bull or whale_acc or fake_down or short_squeeze
    vsa_bear = instant_bear or liq_bear or whale_dist or fake_up or long_squeeze
    
    [stop_loss, target, rr_ratio] = f_calculateRiskReward(close, vsa_bull)
    rr_acceptable = na(rr_ratio) or rr_ratio >= minRiskReward
    
    quality = 0.0
    if enableHTFBias
        if (vsa_bull and htf_bull) or (vsa_bear and htf_bear)
            quality += 35
    
    if enableKeyLevels and at_key_level
        quality += math.min(confluence_count * 8, 25)
    
    vsa_points = 0
    if instant_bull or instant_bear
        vsa_points += 8
    if liq_bull or liq_bear
        vsa_points += 10
    if whale_acc or whale_dist
        vsa_points += 8
    if fake_up or fake_down
        vsa_points += 6
    if long_squeeze or short_squeeze
        vsa_points += 8
    quality += math.min(vsa_points, 25)
    
    if rr_acceptable
        quality += 15
    
    setup_type = ""
    if liq_bull or liq_bear
        setup_type += "LIQ "
    if whale_acc or whale_dist
        setup_type += "WHALE "
    if fake_up or fake_down
        setup_type += "FAKE "
    if long_squeeze or short_squeeze
        setup_type += "SQUEEZE "
    if confluence_count >= 3
        setup_type += "CONFLUENCE "
    
    final_rr = na(rr_ratio) ? 0 : rr_ratio
    
    MTFSignal.new(htf_bull, htf_bear, at_key_level, confluence_count, final_rr, vsa_bull, vsa_bear, quality, setup_type)

// === MAIN CALCULATIONS ===
mtf_signal = f_generateMTFSignal()

signal_threshold = switch scalpMode
    "Ultra Precision" => 80
    "Precision" => 65
    "Balanced" => 50

show_signal = mtf_signal.setup_quality >= signal_threshold

if patienceMode
    show_signal := show_signal and mtf_signal.at_key_level

if onlyKeyLevelSignals
    show_signal := show_signal and mtf_signal.confluence_count >= confluenceRequired

// === VISUALIZATION ===
[htf_high, htf_low] = f_getHTFLevels()
plot(showHTFLevels ? htf_high : na, "HTF High", color=color.new(color.red, 30), linewidth=1)
plot(showHTFLevels ? htf_low : na, "HTF Low", color=color.new(color.green, 30), linewidth=1)

[fib_618, fib_50] = f_getFibonacciLevels()
plot(fibRetrace ? fib_618 : na, "Fib 61.8", color=color.new(color.purple, 50), linewidth=1)
plot(fibRetrace ? fib_50 : na, "Fib 50", color=color.new(color.blue, 50), linewidth=1)

zlema_fast = f_zlema(close, 7)
plot(zlema_fast, "ZLEMA", color=color.black, linewidth=2)

// === SIGNAL LABELS ===
if show_signal and barstate.isconfirmed
    if mtf_signal.vsa_signal_bull
        pattern_text = ""
        if str.contains(mtf_signal.setup_type, "LIQ")
            pattern_text += "ğŸ’¥"
        if str.contains(mtf_signal.setup_type, "WHALE")
            pattern_text += "ğŸ‹"
        if str.contains(mtf_signal.setup_type, "FAKE")
            pattern_text += "ğŸ¦ˆ"
        if str.contains(mtf_signal.setup_type, "SQUEEZE")
            pattern_text += "ğŸš€"
        
        label_text = "ğŸ”¼" + pattern_text + " Q:" + str.tostring(mtf_signal.setup_quality, "#") + "%"
        if showRiskReward and mtf_signal.risk_reward_ratio > 0
            label_text += " R:" + str.tostring(mtf_signal.risk_reward_ratio, "#.#")
        
        label.new(bar_index, low - ta.atr(8), label_text, 
                 style=label.style_label_up, size=size.small,
                 color=color.new(color.green, 20), textcolor=color.black)
    
    if mtf_signal.vsa_signal_bear
        pattern_text = ""
        if str.contains(mtf_signal.setup_type, "LIQ")
            pattern_text += "ğŸ’¥"
        if str.contains(mtf_signal.setup_type, "WHALE")
            pattern_text += "ğŸ‹"
        if str.contains(mtf_signal.setup_type, "FAKE")
            pattern_text += "ğŸ¦ˆ"
        if str.contains(mtf_signal.setup_type, "SQUEEZE")
            pattern_text += "ğŸ”»"
        
        label_text = "ğŸ”½" + pattern_text + " Q:" + str.tostring(mtf_signal.setup_quality, "#") + "%"
        if showRiskReward and mtf_signal.risk_reward_ratio > 0
            label_text += " R:" + str.tostring(mtf_signal.risk_reward_ratio, "#.#")
        
        label.new(bar_index, high + ta.atr(8), label_text,
                 style=label.style_label_down, size=size.small,
                 color=color.new(color.red, 20), textcolor=color.black)

// === DASHBOARD ===
if barstate.islast
    var table dashboard = table.new(position.top_right, 2, 6, bgcolor=color.new(color.black, 85), border_width=1)
    
    table.clear(dashboard, 0, 0, 1, 5)
    
    mode_emoji = switch scalpMode
        "Ultra Precision" => "ğŸ’"
        "Precision" => "ğŸ¯"
        "Balanced" => "âš–ï¸"
    
    table.cell(dashboard, 0, 0, "ğŸ›ï¸ MTF VSA", bgcolor=color.blue, text_color=color.black)
    table.cell(dashboard, 1, 0, str.tostring(current_tf_minutes) + "m " + mode_emoji, bgcolor=color.blue, text_color=color.black)
    
    bias_text = vietnameseUI ? "HTF:" : "HTF:"
    bias_value = mtf_signal.htf_bias_bull ? "ğŸ”¼" : mtf_signal.htf_bias_bear ? "ğŸ”½" : "â¡ï¸"
    table.cell(dashboard, 0, 1, bias_text, text_color=color.silver)
    table.cell(dashboard, 1, 1, bias_value, text_color=mtf_signal.htf_bias_bull ? color.green : mtf_signal.htf_bias_bear ? color.red : color.gray)
    
    table.cell(dashboard, 0, 2, "Quality:", text_color=color.silver)
    quality_color = mtf_signal.setup_quality >= 80 ? color.lime : mtf_signal.setup_quality >= 65 ? color.yellow : mtf_signal.setup_quality >= 50 ? color.orange : color.red
    table.cell(dashboard, 1, 2, str.tostring(mtf_signal.setup_quality, "#") + "%", text_color=quality_color)
    
    table.cell(dashboard, 0, 3, "Key Level:", text_color=color.silver)
    key_value = mtf_signal.at_key_level ? "âœ…(" + str.tostring(mtf_signal.confluence_count) + ")" : "âŒ"
    table.cell(dashboard, 1, 3, key_value, text_color=mtf_signal.at_key_level ? color.lime : color.gray)
    
    table.cell(dashboard, 0, 4, "Signal:", text_color=color.silver)
    signal_value = show_signal ? "ğŸ””" : "â³"
    table.cell(dashboard, 1, 4, signal_value, text_color=show_signal ? color.lime : color.yellow)
    
    table.cell(dashboard, 0, 5, "Pattern:", text_color=color.silver)
    pattern_short = str.contains(mtf_signal.setup_type, "LIQ") ? "LIQ" : str.contains(mtf_signal.setup_type, "WHALE") ? "WHALE" : str.contains(mtf_signal.setup_type, "FAKE") ? "FAKE" : str.contains(mtf_signal.setup_type, "SQUEEZE") ? "SQUEEZE" : "MOM"
    table.cell(dashboard, 1, 5, pattern_short, text_color=color.black)

// === ALERTS ===
alert_condition = show_signal and (not enableHTFBias or (mtf_signal.htf_bias_bull and mtf_signal.vsa_signal_bull) or (mtf_signal.htf_bias_bear and mtf_signal.vsa_signal_bear)) and (not onlyKeyLevelSignals or mtf_signal.at_key_level)

alertcondition(alert_condition and mtf_signal.vsa_signal_bull, "ğŸ¯ MTF Bull Setup", "ğŸ¯ PRECISION BULL SETUP\nCháº¥t LÆ°á»£ng: " + str.tostring(mtf_signal.setup_quality, "#") + "%\nConfluence: " + str.tostring(mtf_signal.confluence_count))

alertcondition(alert_condition and mtf_signal.vsa_signal_bear, "ğŸ¯ MTF Bear Setup", "ğŸ¯ PRECISION BEAR SETUP\nCháº¥t LÆ°á»£ng: " + str.tostring(mtf_signal.setup_quality, "#") + "%\nConfluence: " + str.tostring(mtf_signal.confluence_count))

alertcondition(mtf_signal.setup_quality >= 80 and mtf_signal.confluence_count >= 3, "ğŸ’ Premium Setup", "ğŸ’ PREMIUM SETUP DETECTED\nCháº¥t LÆ°á»£ng: " + str.tostring(mtf_signal.setup_quality, "#") + "%")

alertcondition(mtf_signal.at_key_level and mtf_signal.confluence_count >= confluenceRequired, "ğŸ¯ At Key Level", "ğŸ¯ PRICE AT KEY LEVEL\nConfluence: " + str.tostring(mtf_signal.confluence_count))

long_squeeze = f_detectLongSqueeze()
short_squeeze = f_detectShortSqueeze()
[fake_up, fake_down] = f_detectFakeBreakout()

alertcondition(long_squeeze, "ğŸ”» Long Squeeze", "ğŸ”» LONG SQUEEZE DETECTED")
alertcondition(short_squeeze, "ğŸš€ Short Squeeze", "ğŸš€ SHORT SQUEEZE DETECTED")
alertcondition(fake_up, "ğŸ¦ˆ Fake Breakout Up", "ğŸ¦ˆ FAKE BREAKOUT UP DETECTED")
alertcondition(fake_down, "ğŸ¦ˆ Fake Breakout Down", "ğŸ¦ˆ FAKE BREAKOUT DOWN DETECTED")