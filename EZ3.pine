// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © lenguyenphi

//@version=5
indicator("EZ2", overlay=true, max_boxes_count=5, max_lines_count=20, scale=scale.right)

vol_multiplier = input.float(2.0, title="Volume Spike Multiplier", minval=1.0)
trap_zone_length = input.int(3, title="Trap Zone Length (bars)")
lookback = input.int(20, title="Volume Lookback Period")
show_sr = input.bool(true, title="Show Auto S/R")
show_rsi_div = input.bool(true, title="Show RSI Divergence")
div_lookback = input.int(20, title="RSI Div Lookback")
max_trap_boxes = 5

// VSA Wyckoff Trap Zone logic
avg_vol = ta.sma(volume, lookback)
vol_spike = volume > avg_vol * vol_multiplier

is_pin_bar(bull) =>
    body = math.abs(close - open)
    wick = bull ? (close - low) : (high - close)
    wick > body * 2

bull_pin = vol_spike and is_pin_bar(true) and close > open
bear_pin = vol_spike and is_pin_bar(false) and close < open
bull_engulf = vol_spike and close > open and close > ta.highest(close[1], trap_zone_length)
bear_engulf = vol_spike and close < open and close < ta.lowest(close[1], trap_zone_length)
trap_bull = bull_pin or bull_engulf
trap_bear = bear_pin or bear_engulf

// Auto S/R (Native + MTF)
sr_len = 40
sr_width = 1

// Native S/R (for current timeframe)
native_support = ta.lowest(low, sr_len)
native_resist = ta.highest(high, sr_len)
// plot(show_sr ? native_support : na, color=color.new(color.gray, 50), linewidth=sr_width, style=plot.style_linebr, title="Native Sup")
// plot(show_sr ? native_resist  : na, color=color.new(color.gray, 50), linewidth=sr_width, style=plot.style_linebr, title="Native Res")

// Add native S/R line objects
var line l_nat_sup = na
var line l_nat_res = na

f_line_horiz(ln_id, y, col, w) =>
    ln = ln_id
    if na(ln)
        ln := line.new(bar_index - 500, y, bar_index, y, xloc=xloc.bar_index, extend=extend.right, color=col, width=w)
    else
        line.set_xy1(ln, bar_index - 500, y)
        line.set_xy2(ln, bar_index, y)
        line.set_color(ln, col)
        line.set_width(ln, w)
    ln

f_line_del(ln_id) =>
    if not na(ln_id)
        line.delete(ln_id)

if show_sr
    l_nat_sup := f_line_horiz(l_nat_sup, native_support, color.new(color.gray, 50), sr_width)
    l_nat_res := f_line_horiz(l_nat_res, native_resist,  color.new(color.gray, 50), sr_width)
else
    f_line_del(l_nat_sup), l_nat_sup := na
    f_line_del(l_nat_res), l_nat_res := na

// MTF S/R Logic
is_low_tf = timeframe.isintraday and timeframe.multiplier <= 15

// Fetch H1 S/R Data
h1_support = request.security(syminfo.tickerid, "60", ta.lowest(low, sr_len)[1])
h1_resist  = request.security(syminfo.tickerid, "60", ta.highest(high, sr_len)[1])

// Fetch H4 S/R Data
h4_support = request.security(syminfo.tickerid, "240", ta.lowest(low, sr_len)[1])
h4_resist  = request.security(syminfo.tickerid, "240", ta.highest(high, sr_len)[1])

// Plot MTF S/R lines only on low timeframes
// plot(show_sr and is_low_tf ? h1_support : na, color=color.new(color.blue, 60), linewidth=2, style=plot.style_line,  title="H1 Support")
// plot(show_sr and is_low_tf ? h1_resist  : na, color=color.new(color.blue, 60), linewidth=2, style=plot.style_line,  title="H1 Resist")
// plot(show_sr and is_low_tf ? h4_support : na, color=color.new(color.purple, 50), linewidth=2, style=plot.style_line, title="H4 Support")
// plot(show_sr and is_low_tf ? h4_resist  : na, color=color.new(color.purple, 50), linewidth=2, style=plot.style_line, title="H4 Resist")

// Draw S/R as line objects (stable vertically when zooming/scaling)
var line l_h1_sup = na
var line l_h1_res = na
var line l_h4_sup = na
var line l_h4_res = na

f_sr_update(ln_id, y, col) =>
    ln_local = ln_id
    if na(ln_local)
        ln_local := line.new(bar_index - 500, y, bar_index, y, xloc=xloc.bar_index, extend=extend.right, color=col, width=2)
    else
        line.set_xy1(ln_local, bar_index - 500, y)
        line.set_xy2(ln_local, bar_index, y)
        line.set_color(ln_local, col)
    ln_local

// Do not return na; just delete if exists
f_sr_delete(ln_id) =>
    if not na(ln_id)
        line.delete(ln_id)

// Update or remove S/R lines
if show_sr and is_low_tf
    l_h1_sup := f_sr_update(l_h1_sup, h1_support, color.new(color.blue, 60))
    l_h1_res := f_sr_update(l_h1_res, h1_resist,  color.new(color.blue, 60))
    l_h4_sup := f_sr_update(l_h4_sup, h4_support, color.new(color.purple, 50))
    l_h4_res := f_sr_update(l_h4_res, h4_resist,  color.new(color.purple, 50))
else
    f_sr_delete(l_h1_sup), l_h1_sup := na
    f_sr_delete(l_h1_res), l_h1_res := na
    f_sr_delete(l_h4_sup), l_h4_sup := na
    f_sr_delete(l_h4_res), l_h4_res := na

// (Optional) remove if unused:
// ms_per_bar = nz(time - time[1], timeframe.in_seconds(timeframe.period) * 1000)

// Trap zone only valid near S/R (filters weak traps) - UPDATED with MTF S/R
near_native_sr = (math.abs(low - native_support) / native_support < 0.002) or (math.abs(high - native_resist) / native_resist < 0.002)
near_h1_sr = is_low_tf and na(h1_support) == false and ((math.abs(low - h1_support) / h1_support < 0.002) or (math.abs(high - h1_resist) / h1_resist < 0.002))
near_h4_sr = is_low_tf and na(h4_support) == false and ((math.abs(low - h4_support) / h4_support < 0.002) or (math.abs(high - h4_resist) / h4_resist < 0.002))

is_in_sr_zone = near_native_sr or near_h1_sr or near_h4_sr
final_trap_bull = trap_bull and is_in_sr_zone
final_trap_bear = trap_bear and is_in_sr_zone

// Manage number of trap zone boxes
var box[] trap_boxes = array.new<box>()
if final_trap_bull
    // Draw by bar index so zoom/scale changes don't shift boxes
    new_box = box.new(left=bar_index, right=bar_index + trap_zone_length, top=high, bottom=low, xloc=xloc.bar_index)
    box.set_bgcolor(new_box, color.new(color.green, 80))
    box.set_border_color(new_box, color.green)
    array.unshift(trap_boxes, new_box)
if final_trap_bear
    // Draw by bar index so zoom/scale changes don't shift boxes
    new_box = box.new(left=bar_index, right=bar_index + trap_zone_length, top=high, bottom=low, xloc=xloc.bar_index)
    box.set_bgcolor(new_box, color.new(color.red, 80))
    box.set_border_color(new_box, color.red)
    array.unshift(trap_boxes, new_box)
while array.size(trap_boxes) > max_trap_boxes
    box.delete(array.pop(trap_boxes))

// Entry signal (simplified)
entry_buy = final_trap_bull and close > open and close[1] < open[1]
entry_sell = final_trap_bear and close < open and close[1] > open[1]
if entry_buy
    label.new(bar_index, low, "B", xloc=xloc.bar_index, yloc=yloc.price, style=label.style_label_up,   textcolor=color.white, color=color.new(color.lime, 0), size=size.tiny)
if entry_sell
    label.new(bar_index, high, "S", xloc=xloc.bar_index, yloc=yloc.price, style=label.style_label_down, textcolor=color.white, color=color.new(color.red, 0),  size=size.tiny)

// RSI Divergence logic (compact, dynamic lookback)
rsi_len = 14
rsi = ta.rsi(close, rsi_len)
bull_div = low < ta.lowest(low, div_lookback) and rsi > ta.lowest(rsi, div_lookback)
bear_div = high > ta.highest(high, div_lookback) and rsi < ta.highest(rsi, div_lookback)
if show_rsi_div and bull_div
    label.new(bar_index, low,  "BD", xloc=xloc.bar_index, yloc=yloc.price, style=label.style_label_up,   textcolor=color.white, color=color.new(color.aqua, 0),   size=size.tiny)
if show_rsi_div and bear_div
    label.new(bar_index, high, "SD", xloc=xloc.bar_index, yloc=yloc.price, style=label.style_label_down, textcolor=color.white, color=color.new(color.orange, 0), size=size.tiny)

// Alerts
alertcondition(entry_buy, title="Buy Entry Alert", message="Trap Scalping BUY (B)!")
alertcondition(entry_sell, title="Sell Entry Alert", message="Trap Scalping SELL (S)!")
alertcondition(show_rsi_div and bull_div, title="RSI Bull Div", message="RSI BD!")
alertcondition(show_rsi_div and bear_div, title="RSI Bear Div", message="RSI SD!")